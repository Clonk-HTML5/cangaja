/*******************************************************************************
*                                                                              *
* Author    :  Angus Johnson                                                   *
* Version   :  5.0.2                                                           *
* Date      :  30 December 2012                                                *
* Website   :  http://www.angusj.com                                           *
* Copyright :  Angus Johnson 2010-2012                                         *
*                                                                              *
* License:                                                                     *
* Use, modification & distribution is subject to Boost Software License Ver 1. *
* http://www.boost.org/LICENSE_1_0.txt                                         *
*                                                                              *
* Attributions:                                                                *
* The code in this library is an extension of Bala Vatti's clipping algorithm: *
* "A generic solution to polygon clipping"                                     *
* Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *
* http://portal.acm.org/citation.cfm?id=129906                                 *
*                                                                              *
* Computer graphics and geometric modeling: implementation and algorithms      *
* By Max K. Agoston                                                            *
* Springer; 1 edition (January 4, 2005)                                        *
* http://books.google.com/books?q=vatti+clipping+agoston                       *
*                                                                              *
* See also:                                                                    *
* "Polygon Offsetting by Computing Winding Numbers"                            *
* Paper no. DETC2005-85513 pp. 565-575                                         *
* ASME 2005 International Design Engineering Technical Conferences             *
* and Computers and Information in Engineering Conference (IDETC/CIE2005)      *
* September 24–28, 2005 , Long Beach, California, USA                          *
* http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *
*                                                                              *
*******************************************************************************/

/*******************************************************************************
*                                                                              *
* Author    :  Timo                                                            *
* Version   :  5.0.2.2                                                         *
* Date      :  11 September 2013                                               *
*                                                                              *
* This is a translation of the C# Clipper library to Javascript.               *
* Int128 struct of C# is implemented using JSBN of Tom Wu.                     *
* Because Javascript lacks support for 64-bit integers, the space              *
* is a little more restricted than in C# version.                              *
*                                                                              *
* C# version has support for coordinate space:                                 *
* +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *
* while Javascript version has support for space:                              *
* +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *
*                                                                              *
* Tom Wu's JSBN proved to be the fastest big integer library:                  *
* http://jsperf.com/big-integer-library-test                                   *
*                                                                              *
* This class can be made simpler when (if ever) 64-bit integer support comes.  *
*                                                                              *
*******************************************************************************/

/*******************************************************************************
*                                                                              *
* Basic JavaScript BN library - subset useful for RSA encryption.              *
* http://www-cs-students.stanford.edu/~tjw/jsbn/                               *
* Copyright (c) 2005  Tom Wu                                                   *
* All Rights Reserved.                                                         *
* See "LICENSE" for details:                                                   *
* http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *
*                                                                              *
*******************************************************************************/

(function(){function k(a,b,c){d.biginteger_used=1;null!=a&&("number"==typeof a?this.fromString(Math.floor(a).toString(),10):null==b&&"string"!=typeof a?this.fromString(a,256):(-1!=a.indexOf(".")&&(a=a.substring(0,a.indexOf("."))),this.fromString(a,b)))}function n(){return new k(null)}function R(a,b,c,e,d,f){for(;0<=--f;){var h=b*this[a++]+c[e]+d;d=Math.floor(h/67108864);c[e++]=h&67108863}return d}function S(a,b,c,e,d,f){var h=b&32767;for(b>>=15;0<=--f;){var l=this[a]&32767,k=this[a++]>>15,m=b*l+k*
h,l=h*l+((m&32767)<<15)+c[e]+(d&1073741823);d=(l>>>30)+(m>>>15)+b*k+(d>>>30);c[e++]=l&1073741823}return d}function T(a,b,c,e,d,f){var h=b&16383;for(b>>=14;0<=--f;){var l=this[a]&16383,k=this[a++]>>14,m=b*l+k*h,l=h*l+((m&16383)<<14)+c[e]+d;d=(l>>28)+(m>>14)+b*k;c[e++]=l&268435455}return d}function M(a,b){var c=G[a.charCodeAt(b)];return null==c?-1:c}function B(a){var b=n();b.fromInt(a);return b}function H(a){var b=1,c;0!=(c=a>>>16)&&(a=c,b+=16);0!=(c=a>>8)&&(a=c,b+=8);0!=(c=a>>4)&&(a=c,b+=4);0!=(c=
a>>2)&&(a=c,b+=2);0!=a>>1&&(b+=1);return b}function C(a){this.m=a}function D(a){this.m=a;this.mp=a.invDigit();this.mpl=this.mp&32767;this.mph=this.mp>>15;this.um=(1<<a.DB-15)-1;this.mt2=2*a.t}function U(a,b){return a&b}function L(a,b){return a|b}function N(a,b){return a^b}function O(a,b){return a&~b}function F(){}function P(a){return a}function E(a){this.r2=n();this.q3=n();k.ONE.dlShiftTo(2*a.t,this.r2);this.mu=this.r2.divide(a);this.m=a}var q=navigator.userAgent.toString().toLowerCase(),z,v,y,I,
J,K,Q;z=-1!=q.indexOf("chrome")&&-1==q.indexOf("chromium")?1:0;v=-1!=q.indexOf("chromium")?1:0;y=-1!=q.indexOf("safari")&&-1==q.indexOf("chrome")&&-1==q.indexOf("chromium")?1:0;I=-1!=q.indexOf("firefox")?1:0;q.indexOf("firefox/17");q.indexOf("firefox/15");q.indexOf("firefox/3");J=-1!=q.indexOf("opera")?1:0;q.indexOf("msie 10");q.indexOf("msie 9");K=-1!=q.indexOf("msie 8")?1:0;Q=-1!=q.indexOf("msie 7")?1:0;var q=-1!=q.indexOf("msie ")?1:0,d={biginteger_used:null},u;"Microsoft Internet Explorer"==navigator.appName?
(k.prototype.am=S,u=30):"Netscape"!=navigator.appName?(k.prototype.am=R,u=26):(k.prototype.am=T,u=28);k.prototype.DB=u;k.prototype.DM=(1<<u)-1;k.prototype.DV=1<<u;k.prototype.FV=Math.pow(2,52);k.prototype.F1=52-u;k.prototype.F2=2*u-52;var G=[],x;u=48;for(x=0;9>=x;++x)G[u++]=x;u=97;for(x=10;36>x;++x)G[u++]=x;u=65;for(x=10;36>x;++x)G[u++]=x;C.prototype.convert=function(a){return 0>a.s||0<=a.compareTo(this.m)?a.mod(this.m):a};C.prototype.revert=function(a){return a};C.prototype.reduce=function(a){a.divRemTo(this.m,
null,a)};C.prototype.mulTo=function(a,b,c){a.multiplyTo(b,c);this.reduce(c)};C.prototype.sqrTo=function(a,b){a.squareTo(b);this.reduce(b)};D.prototype.convert=function(a){var b=n();a.abs().dlShiftTo(this.m.t,b);b.divRemTo(this.m,null,b);0>a.s&&0<b.compareTo(k.ZERO)&&this.m.subTo(b,b);return b};D.prototype.revert=function(a){var b=n();a.copyTo(b);this.reduce(b);return b};D.prototype.reduce=function(a){for(;a.t<=this.mt2;)a[a.t++]=0;for(var b=0;b<this.m.t;++b){var c=a[b]&32767,e=c*this.mpl+((c*this.mph+
(a[b]>>15)*this.mpl&this.um)<<15)&a.DM,c=b+this.m.t;for(a[c]+=this.m.am(0,e,a,b,0,this.m.t);a[c]>=a.DV;)a[c]-=a.DV,a[++c]++}a.clamp();a.drShiftTo(this.m.t,a);0<=a.compareTo(this.m)&&a.subTo(this.m,a)};D.prototype.mulTo=function(a,b,c){a.multiplyTo(b,c);this.reduce(c)};D.prototype.sqrTo=function(a,b){a.squareTo(b);this.reduce(b)};k.prototype.copyTo=function(a){for(var b=this.t-1;0<=b;--b)a[b]=this[b];a.t=this.t;a.s=this.s};k.prototype.fromInt=function(a){this.t=1;this.s=0>a?-1:0;0<a?this[0]=a:-1>a?
this[0]=a+this.DV:this.t=0};k.prototype.fromString=function(a,b){var c;if(16==b)c=4;else if(8==b)c=3;else if(256==b)c=8;else if(2==b)c=1;else if(32==b)c=5;else if(4==b)c=2;else{this.fromRadix(a,b);return}this.s=this.t=0;for(var e=a.length,d=!1,f=0;0<=--e;){var h=8==c?a[e]&255:M(a,e);0>h?"-"==a.charAt(e)&&(d=!0):(d=!1,0==f?this[this.t++]=h:f+c>this.DB?(this[this.t-1]|=(h&(1<<this.DB-f)-1)<<f,this[this.t++]=h>>this.DB-f):this[this.t-1]|=h<<f,f+=c,f>=this.DB&&(f-=this.DB))}8==c&&0!=(a[0]&128)&&(this.s=
-1,0<f&&(this[this.t-1]|=(1<<this.DB-f)-1<<f));this.clamp();d&&k.ZERO.subTo(this,this)};k.prototype.clamp=function(){for(var a=this.s&this.DM;0<this.t&&this[this.t-1]==a;)--this.t};k.prototype.dlShiftTo=function(a,b){var c;for(c=this.t-1;0<=c;--c)b[c+a]=this[c];for(c=a-1;0<=c;--c)b[c]=0;b.t=this.t+a;b.s=this.s};k.prototype.drShiftTo=function(a,b){for(var c=a;c<this.t;++c)b[c-a]=this[c];b.t=Math.max(this.t-a,0);b.s=this.s};k.prototype.lShiftTo=function(a,b){var c=a%this.DB,e=this.DB-c,d=(1<<e)-1,f=
Math.floor(a/this.DB),h=this.s<<c&this.DM,l;for(l=this.t-1;0<=l;--l)b[l+f+1]=this[l]>>e|h,h=(this[l]&d)<<c;for(l=f-1;0<=l;--l)b[l]=0;b[f]=h;b.t=this.t+f+1;b.s=this.s;b.clamp()};k.prototype.rShiftTo=function(a,b){b.s=this.s;var c=Math.floor(a/this.DB);if(c>=this.t)b.t=0;else{var e=a%this.DB,d=this.DB-e,f=(1<<e)-1;b[0]=this[c]>>e;for(var h=c+1;h<this.t;++h)b[h-c-1]|=(this[h]&f)<<d,b[h-c]=this[h]>>e;0<e&&(b[this.t-c-1]|=(this.s&f)<<d);b.t=this.t-c;b.clamp()}};k.prototype.subTo=function(a,b){for(var c=
0,e=0,d=Math.min(a.t,this.t);c<d;)e+=this[c]-a[c],b[c++]=e&this.DM,e>>=this.DB;if(a.t<this.t){for(e-=a.s;c<this.t;)e+=this[c],b[c++]=e&this.DM,e>>=this.DB;e+=this.s}else{for(e+=this.s;c<a.t;)e-=a[c],b[c++]=e&this.DM,e>>=this.DB;e-=a.s}b.s=0>e?-1:0;-1>e?b[c++]=this.DV+e:0<e&&(b[c++]=e);b.t=c;b.clamp()};k.prototype.multiplyTo=function(a,b){var c=this.abs(),e=a.abs(),d=c.t;for(b.t=d+e.t;0<=--d;)b[d]=0;for(d=0;d<e.t;++d)b[d+c.t]=c.am(0,e[d],b,d,0,c.t);b.s=0;b.clamp();this.s!=a.s&&k.ZERO.subTo(b,b)};k.prototype.squareTo=
function(a){for(var b=this.abs(),c=a.t=2*b.t;0<=--c;)a[c]=0;for(c=0;c<b.t-1;++c){var e=b.am(c,b[c],a,2*c,0,1);(a[c+b.t]+=b.am(c+1,2*b[c],a,2*c+1,e,b.t-c-1))>=b.DV&&(a[c+b.t]-=b.DV,a[c+b.t+1]=1)}0<a.t&&(a[a.t-1]+=b.am(c,b[c],a,2*c,0,1));a.s=0;a.clamp()};k.prototype.divRemTo=function(a,b,c){var e=a.abs();if(!(0>=e.t)){var d=this.abs();if(d.t<e.t)null!=b&&b.fromInt(0),null!=c&&this.copyTo(c);else{null==c&&(c=n());var f=n(),h=this.s;a=a.s;var l=this.DB-H(e[e.t-1]);0<l?(e.lShiftTo(l,f),d.lShiftTo(l,c)):
(e.copyTo(f),d.copyTo(c));e=f.t;d=f[e-1];if(0!=d){var p=d*(1<<this.F1)+(1<e?f[e-2]>>this.F2:0),m=this.FV/p,p=(1<<this.F1)/p,r=1<<this.F2,w=c.t,q=w-e,t=null==b?n():b;f.dlShiftTo(q,t);0<=c.compareTo(t)&&(c[c.t++]=1,c.subTo(t,c));k.ONE.dlShiftTo(e,t);for(t.subTo(f,f);f.t<e;)f[f.t++]=0;for(;0<=--q;){var s=c[--w]==d?this.DM:Math.floor(c[w]*m+(c[w-1]+r)*p);if((c[w]+=f.am(0,s,c,q,0,e))<s)for(f.dlShiftTo(q,t),c.subTo(t,c);c[w]<--s;)c.subTo(t,c)}null!=b&&(c.drShiftTo(e,b),h!=a&&k.ZERO.subTo(b,b));c.t=e;c.clamp();
0<l&&c.rShiftTo(l,c);0>h&&k.ZERO.subTo(c,c)}}}};k.prototype.invDigit=function(){if(1>this.t)return 0;var a=this[0];if(0==(a&1))return 0;var b=a&3,b=b*(2-(a&15)*b)&15,b=b*(2-(a&255)*b)&255,b=b*(2-((a&65535)*b&65535))&65535,b=b*(2-a*b%this.DV)%this.DV;return 0<b?this.DV-b:-b};k.prototype.isEven=function(){return 0==(0<this.t?this[0]&1:this.s)};k.prototype.exp=function(a,b){if(4294967295<a||1>a)return k.ONE;var c=n(),e=n(),d=b.convert(this),f=H(a)-1;for(d.copyTo(c);0<=--f;)if(b.sqrTo(c,e),0<(a&1<<f))b.mulTo(e,
d,c);else var h=c,c=e,e=h;return b.revert(c)};k.prototype.toString=function(a){if(0>this.s)return"-"+this.negate().toString(a);if(16==a)a=4;else if(8==a)a=3;else if(2==a)a=1;else if(32==a)a=5;else if(4==a)a=2;else return this.toRadix(a);var b=(1<<a)-1,c,e=!1,d="",f=this.t,h=this.DB-f*this.DB%a;if(0<f--)for(h<this.DB&&0<(c=this[f]>>h)&&(e=!0,d="0123456789abcdefghijklmnopqrstuvwxyz".charAt(c));0<=f;)h<a?(c=(this[f]&(1<<h)-1)<<a-h,c|=this[--f]>>(h+=this.DB-a)):(c=this[f]>>(h-=a)&b,0>=h&&(h+=this.DB,
--f)),0<c&&(e=!0),e&&(d+="0123456789abcdefghijklmnopqrstuvwxyz".charAt(c));return e?d:"0"};k.prototype.negate=function(){var a=n();k.ZERO.subTo(this,a);return a};k.prototype.abs=function(){return 0>this.s?this.negate():this};k.prototype.compareTo=function(a){var b=this.s-a.s;if(0!=b)return b;var c=this.t,b=c-a.t;if(0!=b)return 0>this.s?-b:b;for(;0<=--c;)if(0!=(b=this[c]-a[c]))return b;return 0};k.prototype.bitLength=function(){return 0>=this.t?0:this.DB*(this.t-1)+H(this[this.t-1]^this.s&this.DM)};
k.prototype.mod=function(a){var b=n();this.abs().divRemTo(a,null,b);0>this.s&&0<b.compareTo(k.ZERO)&&a.subTo(b,b);return b};k.prototype.modPowInt=function(a,b){var c;c=256>a||b.isEven()?new C(b):new D(b);return this.exp(a,c)};k.ZERO=B(0);k.ONE=B(1);F.prototype.convert=P;F.prototype.revert=P;F.prototype.mulTo=function(a,b,c){a.multiplyTo(b,c)};F.prototype.sqrTo=function(a,b){a.squareTo(b)};E.prototype.convert=function(a){if(0>a.s||a.t>2*this.m.t)return a.mod(this.m);if(0>a.compareTo(this.m))return a;
var b=n();a.copyTo(b);this.reduce(b);return b};E.prototype.revert=function(a){return a};E.prototype.reduce=function(a){a.drShiftTo(this.m.t-1,this.r2);a.t>this.m.t+1&&(a.t=this.m.t+1,a.clamp());this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);for(this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);0>a.compareTo(this.r2);)a.dAddOffset(1,this.m.t+1);for(a.subTo(this.r2,a);0<=a.compareTo(this.m);)a.subTo(this.m,a)};E.prototype.mulTo=function(a,b,c){a.multiplyTo(b,c);this.reduce(c)};E.prototype.sqrTo=
function(a,b){a.squareTo(b);this.reduce(b)};var s=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,
661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997],V=67108864/s[s.length-1];k.prototype.chunkSize=function(a){return Math.floor(Math.LN2*this.DB/Math.log(a))};k.prototype.toRadix=function(a){null==a&&(a=10);if(0==this.signum()||2>a||36<a)return"0";var b=this.chunkSize(a),b=Math.pow(a,b),c=B(b),e=n(),d=n(),f="";for(this.divRemTo(c,e,d);0<e.signum();)f=(b+d.intValue()).toString(a).substr(1)+
f,e.divRemTo(c,e,d);return d.intValue().toString(a)+f};k.prototype.fromRadix=function(a,b){this.fromInt(0);null==b&&(b=10);for(var c=this.chunkSize(b),e=Math.pow(b,c),d=!1,f=0,h=0,l=0;l<a.length;++l){var p=M(a,l);0>p?"-"==a.charAt(l)&&0==this.signum()&&(d=!0):(h=b*h+p,++f>=c&&(this.dMultiply(e),this.dAddOffset(h,0),h=f=0))}0<f&&(this.dMultiply(Math.pow(b,f)),this.dAddOffset(h,0));d&&k.ZERO.subTo(this,this)};k.prototype.fromNumber=function(a,b,c){if("number"==typeof b)if(2>a)this.fromInt(1);else for(this.fromNumber(a,
c),this.testBit(a-1)||this.bitwiseTo(k.ONE.shiftLeft(a-1),L,this),this.isEven()&&this.dAddOffset(1,0);!this.isProbablePrime(b);)this.dAddOffset(2,0),this.bitLength()>a&&this.subTo(k.ONE.shiftLeft(a-1),this);else{c=[];var e=a&7;c.length=(a>>3)+1;b.nextBytes(c);c[0]=0<e?c[0]&(1<<e)-1:0;this.fromString(c,256)}};k.prototype.bitwiseTo=function(a,b,c){var e,d,f=Math.min(a.t,this.t);for(e=0;e<f;++e)c[e]=b(this[e],a[e]);if(a.t<this.t){d=a.s&this.DM;for(e=f;e<this.t;++e)c[e]=b(this[e],d);c.t=this.t}else{d=
this.s&this.DM;for(e=f;e<a.t;++e)c[e]=b(d,a[e]);c.t=a.t}c.s=b(this.s,a.s);c.clamp()};k.prototype.changeBit=function(a,b){var c=k.ONE.shiftLeft(a);this.bitwiseTo(c,b,c);return c};k.prototype.addTo=function(a,b){for(var c=0,e=0,d=Math.min(a.t,this.t);c<d;)e+=this[c]+a[c],b[c++]=e&this.DM,e>>=this.DB;if(a.t<this.t){for(e+=a.s;c<this.t;)e+=this[c],b[c++]=e&this.DM,e>>=this.DB;e+=this.s}else{for(e+=this.s;c<a.t;)e+=a[c],b[c++]=e&this.DM,e>>=this.DB;e+=a.s}b.s=0>e?-1:0;0<e?b[c++]=e:-1>e&&(b[c++]=this.DV+
e);b.t=c;b.clamp()};k.prototype.dMultiply=function(a){this[this.t]=this.am(0,a-1,this,0,0,this.t);++this.t;this.clamp()};k.prototype.dAddOffset=function(a,b){if(0!=a){for(;this.t<=b;)this[this.t++]=0;for(this[b]+=a;this[b]>=this.DV;)this[b]-=this.DV,++b>=this.t&&(this[this.t++]=0),++this[b]}};k.prototype.multiplyLowerTo=function(a,b,c){var e=Math.min(this.t+a.t,b);c.s=0;for(c.t=e;0<e;)c[--e]=0;var d;for(d=c.t-this.t;e<d;++e)c[e+this.t]=this.am(0,a[e],c,e,0,this.t);for(d=Math.min(a.t,b);e<d;++e)this.am(0,
a[e],c,e,0,b-e);c.clamp()};k.prototype.multiplyUpperTo=function(a,b,c){--b;var e=c.t=this.t+a.t-b;for(c.s=0;0<=--e;)c[e]=0;for(e=Math.max(b-this.t,0);e<a.t;++e)c[this.t+e-b]=this.am(b-e,a[e],c,0,0,this.t+e-b);c.clamp();c.drShiftTo(1,c)};k.prototype.modInt=function(a){if(0>=a)return 0;var b=this.DV%a,c=0>this.s?a-1:0;if(0<this.t)if(0==b)c=this[0]%a;else for(var e=this.t-1;0<=e;--e)c=(b*c+this[e])%a;return c};k.prototype.millerRabin=function(a){var b=this.subtract(k.ONE),c=b.getLowestSetBit();if(0>=
c)return!1;var e=b.shiftRight(c);a=a+1>>1;a>s.length&&(a=s.length);for(var d=n(),f=0;f<a;++f){d.fromInt(s[Math.floor(Math.random()*s.length)]);var h=d.modPow(e,this);if(0!=h.compareTo(k.ONE)&&0!=h.compareTo(b)){for(var l=1;l++<c&&0!=h.compareTo(b);)if(h=h.modPowInt(2,this),0==h.compareTo(k.ONE))return!1;if(0!=h.compareTo(b))return!1}}return!0};k.prototype.clone=function(){var a=n();this.copyTo(a);return a};k.prototype.intValue=function(){if(0>this.s){if(1==this.t)return this[0]-this.DV;if(0==this.t)return-1}else{if(1==
this.t)return this[0];if(0==this.t)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]};k.prototype.byteValue=function(){return 0==this.t?this.s:this[0]<<24>>24};k.prototype.shortValue=function(){return 0==this.t?this.s:this[0]<<16>>16};k.prototype.signum=function(){return 0>this.s?-1:0>=this.t||1==this.t&&0>=this[0]?0:1};k.prototype.toByteArray=function(){var a=this.t,b=[];b[0]=this.s;var c=this.DB-a*this.DB%8,e,d=0;if(0<a--)for(c<this.DB&&(e=this[a]>>c)!=(this.s&this.DM)>>c&&(b[d++]=e|this.s<<
this.DB-c);0<=a;)if(8>c?(e=(this[a]&(1<<c)-1)<<8-c,e|=this[--a]>>(c+=this.DB-8)):(e=this[a]>>(c-=8)&255,0>=c&&(c+=this.DB,--a)),0!=(e&128)&&(e|=-256),0==d&&(this.s&128)!=(e&128)&&++d,0<d||e!=this.s)b[d++]=e;return b};k.prototype.equals=function(a){return 0==this.compareTo(a)};k.prototype.min=function(a){return 0>this.compareTo(a)?this:a};k.prototype.max=function(a){return 0<this.compareTo(a)?this:a};k.prototype.and=function(a){var b=n();this.bitwiseTo(a,U,b);return b};k.prototype.or=function(a){var b=
n();this.bitwiseTo(a,L,b);return b};k.prototype.xor=function(a){var b=n();this.bitwiseTo(a,N,b);return b};k.prototype.andNot=function(a){var b=n();this.bitwiseTo(a,O,b);return b};k.prototype.not=function(){for(var a=n(),b=0;b<this.t;++b)a[b]=this.DM&~this[b];a.t=this.t;a.s=~this.s;return a};k.prototype.shiftLeft=function(a){var b=n();0>a?this.rShiftTo(-a,b):this.lShiftTo(a,b);return b};k.prototype.shiftRight=function(a){var b=n();0>a?this.lShiftTo(-a,b):this.rShiftTo(a,b);return b};k.prototype.getLowestSetBit=
function(){for(var a=0;a<this.t;++a)if(0!=this[a]){var b=a*this.DB;a=this[a];if(0==a)a=-1;else{var c=0;0==(a&65535)&&(a>>=16,c+=16);0==(a&255)&&(a>>=8,c+=8);0==(a&15)&&(a>>=4,c+=4);0==(a&3)&&(a>>=2,c+=2);0==(a&1)&&++c;a=c}return b+a}return 0>this.s?this.t*this.DB:-1};k.prototype.bitCount=function(){for(var a=0,b=this.s&this.DM,c=0;c<this.t;++c){for(var e=this[c]^b,d=0;0!=e;)e&=e-1,++d;a+=d}return a};k.prototype.testBit=function(a){var b=Math.floor(a/this.DB);return b>=this.t?0!=this.s:0!=(this[b]&
1<<a%this.DB)};k.prototype.setBit=function(a){return this.changeBit(a,L)};k.prototype.clearBit=function(a){return this.changeBit(a,O)};k.prototype.flipBit=function(a){return this.changeBit(a,N)};k.prototype.add=function(a){var b=n();this.addTo(a,b);return b};k.prototype.subtract=function(a){var b=n();this.subTo(a,b);return b};k.prototype.multiply=function(a){var b=n();this.multiplyTo(a,b);return b};k.prototype.divide=function(a){var b=n();this.divRemTo(a,b,null);return b};k.prototype.remainder=function(a){var b=
n();this.divRemTo(a,null,b);return b};k.prototype.divideAndRemainder=function(a){var b=n(),c=n();this.divRemTo(a,b,c);return[b,c]};k.prototype.modPow=function(a,b){var c=a.bitLength(),e,d=B(1),f;if(0>=c)return d;e=18>c?1:48>c?3:144>c?4:768>c?5:6;f=8>c?new C(b):b.isEven()?new E(b):new D(b);var h=[],l=3,k=e-1,m=(1<<e)-1;h[1]=f.convert(this);if(1<e)for(c=n(),f.sqrTo(h[1],c);l<=m;)h[l]=n(),f.mulTo(c,h[l-2],h[l]),l+=2;for(var r=a.t-1,w,q=!0,t=n(),c=H(a[r])-1;0<=r;){c>=k?w=a[r]>>c-k&m:(w=(a[r]&(1<<c+1)-
1)<<k-c,0<r&&(w|=a[r-1]>>this.DB+c-k));for(l=e;0==(w&1);)w>>=1,--l;0>(c-=l)&&(c+=this.DB,--r);if(q)h[w].copyTo(d),q=!1;else{for(;1<l;)f.sqrTo(d,t),f.sqrTo(t,d),l-=2;0<l?f.sqrTo(d,t):(l=d,d=t,t=l);f.mulTo(t,h[w],d)}for(;0<=r&&0==(a[r]&1<<c);)f.sqrTo(d,t),l=d,d=t,t=l,0>--c&&(c=this.DB-1,--r)}return f.revert(d)};k.prototype.modInverse=function(a){var b=a.isEven();if(this.isEven()&&b||0==a.signum())return k.ZERO;for(var c=a.clone(),d=this.clone(),g=B(1),f=B(0),h=B(0),l=B(1);0!=c.signum();){for(;c.isEven();)c.rShiftTo(1,
c),b?(g.isEven()&&f.isEven()||(g.addTo(this,g),f.subTo(a,f)),g.rShiftTo(1,g)):f.isEven()||f.subTo(a,f),f.rShiftTo(1,f);for(;d.isEven();)d.rShiftTo(1,d),b?(h.isEven()&&l.isEven()||(h.addTo(this,h),l.subTo(a,l)),h.rShiftTo(1,h)):l.isEven()||l.subTo(a,l),l.rShiftTo(1,l);0<=c.compareTo(d)?(c.subTo(d,c),b&&g.subTo(h,g),f.subTo(l,f)):(d.subTo(c,d),b&&h.subTo(g,h),l.subTo(f,l))}if(0!=d.compareTo(k.ONE))return k.ZERO;if(0<=l.compareTo(a))return l.subtract(a);if(0>l.signum())l.addTo(a,l);else return l;return 0>
l.signum()?l.add(a):l};k.prototype.pow=function(a){return this.exp(a,new F)};k.prototype.gcd=function(a){var b=0>this.s?this.negate():this.clone();a=0>a.s?a.negate():a.clone();if(0>b.compareTo(a)){var c=b,b=a;a=c}var c=b.getLowestSetBit(),d=a.getLowestSetBit();if(0>d)return b;c<d&&(d=c);0<d&&(b.rShiftTo(d,b),a.rShiftTo(d,a));for(;0<b.signum();)0<(c=b.getLowestSetBit())&&b.rShiftTo(c,b),0<(c=a.getLowestSetBit())&&a.rShiftTo(c,a),0<=b.compareTo(a)?(b.subTo(a,b),b.rShiftTo(1,b)):(a.subTo(b,a),a.rShiftTo(1,
a));0<d&&a.lShiftTo(d,a);return a};k.prototype.isProbablePrime=function(a){var b,c=this.abs();if(1==c.t&&c[0]<=s[s.length-1]){for(b=0;b<s.length;++b)if(c[0]==s[b])return!0;return!1}if(c.isEven())return!1;for(b=1;b<s.length;){for(var d=s[b],g=b+1;g<s.length&&d<V;)d*=s[g++];for(d=c.modInt(d);b<g;)if(0==d%s[b++])return!1}return c.millerRabin(a)};k.prototype.square=function(){var a=n();this.squareTo(a);return a};d.Math_Abs_Int64=d.Math_Abs_Int32=d.Math_Abs_Double=function(a){return Math.abs(a)};d.Math_Max_Int32_Int32=
function(a,b){return Math.max(a,b)};d.Cast_Int32=q||J||y?function(a){return a|0}:function(a){return~~a};d.Cast_Int64=z?function(a){return-2147483648>a||2147483647<a?0>a?Math.ceil(a):Math.floor(a):~~a}:I&&"function"==typeof Number.toInteger?function(a){return Number.toInteger(a)}:Q||K?function(a){return parseInt(a,10)}:q?function(a){return-2147483648>a||2147483647<a?0>a?Math.ceil(a):Math.floor(a):a|0}:function(a){return 0>a?Math.ceil(a):Math.floor(a)};d.Clear=function(a){a.length=0};d.MaxSteps=64;
d.PI=3.141592653589793;d.PI2=6.283185307179586;d.IntPoint=function(){var a=arguments;1==a.length&&(this.x=a[0].x,this.y=a[0].y);2==a.length&&(this.x=a[0],this.y=a[1])};d.IntRect=function(){var a=arguments;if(4==a.length){var b=a[1],c=a[2],d=a[3];this.left=a[0];this.top=b;this.right=c;this.bottom=d}else this.bottom=this.right=this.top=this.left=0};d.Polygon=function(){return[]};d.Polygons=function(){return[]};d.ExPolygons=function(){var a=[];a.exPolygons=!0;return a};d.ExPolygon=function(){this.holes=
this.outer=null};d.ClipType={ctIntersection:0,ctUnion:1,ctDifference:2,ctXor:3};d.PolyType={ptSubject:0,ptClip:1};d.PolyFillType={pftEvenOdd:0,pftNonZero:1,pftPositive:2,pftNegative:3};d.JoinType={jtSquare:0,jtRound:1,jtMiter:2};d.EdgeSide={esLeft:1,esRight:2};d.Protects={ipNone:0,ipLeft:1,ipRight:2,ipBoth:3};d.Direction={dRightToLeft:0,dLeftToRight:1};d.TEdge=function(){this.tmpX=this.deltaY=this.deltaX=this.dx=this.ytop=this.xtop=this.ycurr=this.xcurr=this.ybot=this.xbot=0;this.polyType=d.PolyType.ptSubject;
this.side=null;this.outIdx=this.windCnt2=this.windCnt=this.windDelta=0;this.prevInSEL=this.nextInSEL=this.prevInAEL=this.nextInAEL=this.nextInLML=this.prev=this.next=null};d.IntersectNode=function(){this.next=this.pt=this.edge2=this.edge1=null};d.LocalMinima=function(){this.y=0;this.next=this.rightBound=this.leftBound=null};d.Scanbeam=function(){this.y=0;this.next=null};d.OutRec=function(){this.idx=0;this.isHole=!1;this.bottomPt=this.pts=this.AppendLink=this.FirstLeft=null};d.OutPt=function(){this.idx=
0;this.prev=this.next=this.pt=null};d.JoinRec=function(){this.pt1b=this.pt1a=null;this.poly1Idx=0;this.pt2b=this.pt2a=null;this.poly2Idx=0};d.HorzJoinRec=function(){this.edge=null;this.savedIdx=0};d.ClipperBase=function(){this.m_CurrentLM=this.m_MinimaList=null;this.m_edges=[[]];this.m_UseFullRange=!1};d.ClipperBase.horizontal=-9007199254740992;d.ClipperBase.loRange=47453132;d.ClipperBase.hiRange=0xfffffffffffff;d.ClipperBase.PointsEqual=function(a,b){return a.x==b.x&&a.y==b.y};d.ClipperBase.prototype.PointIsVertex=
function(a,b){var c=b;do{if(d.ClipperBase.PointsEqual(c.pt,a))return!0;c=c.next}while(c!=b);return!1};d.ClipperBase.prototype.PointInPolygon=function(a,b,c){var d=b,g=!1;if(c){do(d.pt.y<=a.y&&a.y<d.prev.pt.y||d.prev.pt.y<=a.y&&a.y<d.pt.y)&&0>(new k(a.x-d.pt.x)).compareTo((new k(d.prev.pt.x-d.pt.x)).multiply(new k(a.y-d.pt.y)).divide(new k(d.prev.pt.y-d.pt.y)))&&(g=!g),d=d.next;while(d!=b)}else{do(d.pt.y<=a.y&&a.y<d.prev.pt.y||d.prev.pt.y<=a.y&&a.y<d.pt.y)&&a.x-d.pt.x<(d.prev.pt.x-d.pt.x)*(a.y-d.pt.y)/
(d.prev.pt.y-d.pt.y)&&(g=!g),d=d.next;while(d!=b)}return g};d.ClipperBase.prototype.SlopesEqual=d.ClipperBase.SlopesEqual=function(){var a=arguments,b,c,d,g;if(3==a.length)return b=a[0],c=a[1],(a=a[2])?(new k(b.deltaY)).multiply(new k(c.deltaX)).toString()==(new k(b.deltaX)).multiply(new k(c.deltaY)).toString():b.deltaY*c.deltaX==b.deltaX*c.deltaY;if(4==a.length)return b=a[0],c=a[1],d=a[2],(a=a[3])?(new k(b.y-c.y)).multiply(new k(c.x-d.x)).toString()==(new k(b.x-c.x)).multiply(new k(c.y-d.y)).toString():
0==(b.y-c.y)*(c.x-d.x)-(b.x-c.x)*(c.y-d.y);if(5==a.length)return b=a[0],c=a[1],d=a[2],g=a[3],(a=a[4])?(new k(b.y-c.y)).multiply(new k(d.x-g.x)).toString()==(new k(b.x-c.x)).multiply(new k(d.y-g.y)).toString():0==(b.y-c.y)*(d.x-g.x)-(b.x-c.x)*(d.y-g.y)};d.ClipperBase.prototype.Clear=function(){this.DisposeLocalMinimaList();for(var a=0;a<this.m_edges.length;++a){for(var b=0;b<this.m_edges[a].length;++b)this.m_edges[a][b]=null;d.Clear(this.m_edges[a])}d.Clear(this.m_edges);this.m_UseFullRange=!1};d.ClipperBase.prototype.DisposeLocalMinimaList=
function(){for(;null!=this.m_MinimaList;){var a=this.m_MinimaList.next;this.m_MinimaList=null;this.m_MinimaList=a}this.m_CurrentLM=null};d.ClipperBase.prototype.AddPolygons=function(a,b){var c=!1,e=!1;if(!(a instanceof Array))return c;for(var g=0;g<a.length;++g)if((e=this.AddPolygon(a[g],b,!0))&&"exceed"!=e)c=!0;else if("exceed"==e)break;"exceed"==e&&d.Error("Coordinate exceeds range bounds in AddPolygons().");return c};d.ClipperBase.prototype.AddPolygon=function(a,b,c){if(!(a instanceof Array))return!1;
var e=a.length;if(3>e)return!1;var g=new d.Polygon;g.push(new d.IntPoint(a[0].x,a[0].y));var f=0,h,l=!1;for(h=1;h<e;++h){var k;k=this.m_UseFullRange?d.ClipperBase.hiRange:d.ClipperBase.loRange;if(d.Math_Abs_Int64(a[h].x)>k||d.Math_Abs_Int64(a[h].y)>k){if(d.Math_Abs_Int64(a[h].x)>d.ClipperBase.hiRange||d.Math_Abs_Int64(a[h].y)>d.ClipperBase.hiRange){if("undefined"!=typeof c)return"exceed";l=!0;break}this.m_UseFullRange=!0}d.ClipperBase.PointsEqual(g[f],a[h])||(0<f&&this.SlopesEqual(g[f-1],g[f],a[h],
this.m_UseFullRange)?d.ClipperBase.PointsEqual(g[f-1],a[h])&&f--:f++,f<g.length?g[f]=a[h]:g.push(new d.IntPoint(a[h].x,a[h].y)))}l&&"undefined"==typeof c&&d.Error("Coordinate exceeds range bounds in AddPolygon()");if(2>f)return!1;for(e=f+1;2<e;){if(d.ClipperBase.PointsEqual(g[f],g[0]))f--;else if(d.ClipperBase.PointsEqual(g[0],g[1])||this.SlopesEqual(g[f],g[0],g[1],this.m_UseFullRange))g[0]=g[f--];else if(this.SlopesEqual(g[f-1],g[f],g[0],this.m_UseFullRange))f--;else if(this.SlopesEqual(g[0],g[1],
g[2],this.m_UseFullRange)){for(h=2;h<=f;++h)g[h-1]=g[h];f--}else break;e--}if(3>e)return!1;a=[];for(h=0;h<e;h++)a.push(new d.TEdge);this.m_edges.push(a);a[0].xcurr=g[0].x;a[0].ycurr=g[0].y;this.InitEdge(a[e-1],a[0],a[e-2],g[e-1],b);for(h=e-2;0<h;--h)this.InitEdge(a[h],a[h+1],a[h-1],g[h],b);this.InitEdge(a[0],a[1],a[e-1],g[0],b);e=b=a[0];do b.xcurr=b.xbot,b.ycurr=b.ybot,b.ytop<e.ytop&&(e=b),b=b.next;while(b!=a[0]);0<e.windDelta&&(e=e.next);e.dx==d.ClipperBase.horizontal&&(e=e.next);b=e;do b=this.AddBoundsToLML(b);
while(b!=e);return!0};d.ClipperBase.prototype.InitEdge=function(a,b,c,d,g){a.next=b;a.prev=c;a.xcurr=d.x;a.ycurr=d.y;a.ycurr>=a.next.ycurr?(a.xbot=a.xcurr,a.ybot=a.ycurr,a.xtop=a.next.xcurr,a.ytop=a.next.ycurr,a.windDelta=1):(a.xtop=a.xcurr,a.ytop=a.ycurr,a.xbot=a.next.xcurr,a.ybot=a.next.ycurr,a.windDelta=-1);this.SetDx(a);a.polyType=g;a.outIdx=-1};d.ClipperBase.prototype.SetDx=function(a){a.deltaX=a.xtop-a.xbot;a.deltaY=a.ytop-a.ybot;a.dx=0==a.deltaY?d.ClipperBase.horizontal:a.deltaX/a.deltaY};
d.ClipperBase.prototype.AddBoundsToLML=function(a){a.nextInLML=null;for(a=a.next;;){if(a.dx==d.ClipperBase.horizontal){if(a.next.ytop<a.ytop&&a.next.xbot>a.prev.xbot)break;a.xtop!=a.prev.xbot&&this.SwapX(a);a.nextInLML=a.prev}else if(a.ycurr==a.prev.ycurr)break;else a.nextInLML=a.prev;a=a.next}var b=new d.LocalMinima;b.next=null;b.y=a.prev.ybot;a.dx==d.ClipperBase.horizontal?(a.xbot!=a.prev.xbot&&this.SwapX(a),b.leftBound=a.prev,b.rightBound=a):a.dx<a.prev.dx?(b.leftBound=a.prev,b.rightBound=a):(b.leftBound=
a,b.rightBound=a.prev);b.leftBound.side=d.EdgeSide.esLeft;b.rightBound.side=d.EdgeSide.esRight;for(this.InsertLocalMinima(b);a.next.ytop!=a.ytop||a.next.dx==d.ClipperBase.horizontal;)a=a.nextInLML=a.next,a.dx==d.ClipperBase.horizontal&&a.xbot!=a.prev.xtop&&this.SwapX(a);return a.next};d.ClipperBase.prototype.InsertLocalMinima=function(a){if(null==this.m_MinimaList)this.m_MinimaList=a;else if(a.y>=this.m_MinimaList.y)a.next=this.m_MinimaList,this.m_MinimaList=a;else{for(var b=this.m_MinimaList;null!=
b.next&&a.y<b.next.y;)b=b.next;a.next=b.next;b.next=a}};d.ClipperBase.prototype.PopLocalMinima=function(){null!=this.m_CurrentLM&&(this.m_CurrentLM=this.m_CurrentLM.next)};d.ClipperBase.prototype.SwapX=function(a){a.xcurr=a.xtop;a.xtop=a.xbot;a.xbot=a.xcurr};d.ClipperBase.prototype.Reset=function(){for(var a=this.m_CurrentLM=this.m_MinimaList;null!=a;){for(var b=a.leftBound;null!=b;)b.xcurr=b.xbot,b.ycurr=b.ybot,b.side=d.EdgeSide.esLeft,b.outIdx=-1,b=b.nextInLML;for(b=a.rightBound;null!=b;)b.xcurr=
b.xbot,b.ycurr=b.ybot,b.side=d.EdgeSide.esRight,b.outIdx=-1,b=b.nextInLML;a=a.next}};d.ClipperBase.prototype.GetBounds=function(){var a=new d.IntRect,b=this.m_MinimaList;if(null==b)return a;a.left=b.leftBound.xbot;a.top=b.leftBound.ybot;a.right=b.leftBound.xbot;for(a.bottom=b.leftBound.ybot;null!=b;){b.leftBound.ybot>a.bottom&&(a.bottom=b.leftBound.ybot);for(var c=b.leftBound;;){for(var e=c;null!=c.nextInLML;)c.xbot<a.left&&(a.left=c.xbot),c.xbot>a.right&&(a.right=c.xbot),c=c.nextInLML;c.xbot<a.left&&
(a.left=c.xbot);c.xbot>a.right&&(a.right=c.xbot);c.xtop<a.left&&(a.left=c.xtop);c.xtop>a.right&&(a.right=c.xtop);c.ytop<a.top&&(a.top=c.ytop);if(e==b.leftBound)c=b.rightBound;else break}b=b.next}return a};d.Clipper=function(){this.m_PolyOuts=null;this.m_ClipType=d.ClipType.ctIntersection;this.m_IntersectNodes=this.m_SortedEdges=this.m_ActiveEdges=this.m_Scanbeam=null;this.m_ExecuteLocked=!1;this.m_SubjFillType=this.m_ClipFillType=d.PolyFillType.pftEvenOdd;this.m_HorizJoins=this.m_Joins=null;this.m_UsingExPolygons=
this.m_ReverseOutput=!1;d.ClipperBase.call(this);this.m_IntersectNodes=this.m_SortedEdges=this.m_ActiveEdges=this.m_Scanbeam=null;this.m_ExecuteLocked=!1;this.m_PolyOuts=[];this.m_Joins=[];this.m_HorizJoins=[];this.m_UsingExPolygons=this.m_ReverseOutput=!1};d.Clipper.prototype.Clear=function(){0!=this.m_edges.length&&(this.DisposeAllPolyPts(),d.ClipperBase.prototype.Clear.call(this))};d.Clipper.prototype.DisposeScanbeamList=function(){for(;null!=this.m_Scanbeam;){var a=this.m_Scanbeam.next;this.m_Scanbeam=
null;this.m_Scanbeam=a}};d.Clipper.prototype.Reset=function(){d.ClipperBase.prototype.Reset.call(this);this.m_SortedEdges=this.m_ActiveEdges=this.m_Scanbeam=null;this.DisposeAllPolyPts();for(var a=this.m_MinimaList;null!=a;)this.InsertScanbeam(a.y),this.InsertScanbeam(a.leftBound.ytop),a=a.next};d.Clipper.prototype.get_ReverseSolution=function(){return this.m_ReverseOutput};d.Clipper.prototype.set_ReverseSolution=function(a){this.m_ReverseOutput=a};d.Clipper.prototype.InsertScanbeam=function(a){var b;
if(null==this.m_Scanbeam)this.m_Scanbeam=new d.Scanbeam,this.m_Scanbeam.next=null,this.m_Scanbeam.y=a;else if(a>this.m_Scanbeam.y)b=new d.Scanbeam,b.y=a,b.next=this.m_Scanbeam,this.m_Scanbeam=b;else{for(var c=this.m_Scanbeam;null!=c.next&&a<=c.next.y;)c=c.next;a!=c.y&&(b=new d.Scanbeam,b.y=a,b.next=c.next,c.next=b)}};d.Clipper.prototype.Execute=function(a,b,c,e){var g;2==arguments.length&&(e=c=d.PolyFillType.pftEvenOdd);if("undefined"==typeof b.exPolygons){if(this.m_ExecuteLocked)return!1;this.m_ExecuteLocked=
!0;d.Clear(b);this.m_SubjFillType=c;this.m_ClipFillType=e;this.m_ClipType=a;this.m_UsingExPolygons=!1;(g=this.ExecuteInternal())&&this.BuildResult(b)}else{if(this.m_ExecuteLocked)return!1;this.m_ExecuteLocked=!0;d.Clear(b);this.m_SubjFillType=c;this.m_ClipFillType=e;this.m_ClipType=a;this.m_UsingExPolygons=!0;(g=this.ExecuteInternal())&&this.BuildResultEx(b)}this.m_ExecuteLocked=!1;return g};d.Clipper.prototype.PolySort=function(a,b){if(a==b)return 0;if(null==a.pts||null==b.pts)return null==a.pts!=
(null==b.pts)?null==a.pts?1:-1:0;var c=(a.isHole?a.FirstLeft.idx:a.idx)-(b.isHole?b.FirstLeft.idx:b.idx);return 0==c&&a.isHole!=b.isHole?a.isHole?1:-1:c};d.Clipper.prototype.FindAppendLinkEnd=function(a){for(;null!=a.AppendLink;)a=a.AppendLink;return a};d.Clipper.prototype.FixHoleLinkage=function(a){var b;b=null!=a.bottomPt?this.m_PolyOuts[a.bottomPt.idx].FirstLeft:a.FirstLeft;a==b&&d.Error("HoleLinkage error");null!=b&&(null!=b.AppendLink&&(b=this.FindAppendLinkEnd(b)),b==a?b=null:b.isHole&&(this.FixHoleLinkage(b),
b=b.FirstLeft));a.FirstLeft=b;null==b&&(a.isHole=!1);a.AppendLink=null};d.Clipper.prototype.ExecuteInternal=function(){var a;try{this.Reset();if(null==this.m_CurrentLM)return!0;var b=this.PopScanbeam();do{this.InsertLocalMinimaIntoAEL(b);d.Clear(this.m_HorizJoins);this.ProcessHorizontals();var c=this.PopScanbeam();a=this.ProcessIntersections(b,c);if(!a)break;this.ProcessEdgesAtTopOfScanbeam(c);b=c}while(null!=this.m_Scanbeam)}catch(e){a=!1}if(a){for(c=0;c<this.m_PolyOuts.length;c++)b=this.m_PolyOuts[c],
null!=b.pts&&(this.FixupOutPolygon(b),null!=b.pts&&(b.isHole&&this.m_UsingExPolygons&&this.FixHoleLinkage(b),(b.isHole^this.m_ReverseOutput)==0<this.Area(b,this.m_UseFullRange)&&this.ReversePolyPtLinks(b.pts)));this.JoinCommonEdges();this.m_UsingExPolygons&&this.m_PolyOuts.sort(this.PolySort)}d.Clear(this.m_Joins);d.Clear(this.m_HorizJoins);return a};d.Clipper.prototype.PopScanbeam=function(){var a=this.m_Scanbeam.y;this.m_Scanbeam=this.m_Scanbeam.next;return a};d.Clipper.prototype.DisposeAllPolyPts=
function(){for(var a=0;a<this.m_PolyOuts.length;++a)this.DisposeOutRec(a);d.Clear(this.m_PolyOuts)};d.Clipper.prototype.DisposeOutRec=function(a){var b=this.m_PolyOuts[a];null!=b.pts&&this.DisposeOutPts(b.pts);this.m_PolyOuts[a]=null};d.Clipper.prototype.DisposeOutPts=function(a){if(null!=a)for(a.prev.next=null;null!=a;)a=a.next};d.Clipper.prototype.AddJoin=function(a,b,c,e){var g=new d.JoinRec;g.poly1Idx=0<=c?c:a.outIdx;g.pt1a=new d.IntPoint(a.xcurr,a.ycurr);g.pt1b=new d.IntPoint(a.xtop,a.ytop);
g.poly2Idx=0<=e?e:b.outIdx;g.pt2a=new d.IntPoint(b.xcurr,b.ycurr);g.pt2b=new d.IntPoint(b.xtop,b.ytop);this.m_Joins.push(g)};d.Clipper.prototype.AddHorzJoin=function(a,b){var c=new d.HorzJoinRec;c.edge=a;c.savedIdx=b;this.m_HorizJoins.push(c)};d.Clipper.prototype.InsertLocalMinimaIntoAEL=function(a){for(var b,c;null!=this.m_CurrentLM&&this.m_CurrentLM.y==a;){var e=this.m_CurrentLM.leftBound,g=this.m_CurrentLM.rightBound;this.InsertEdgeIntoAEL(e);this.InsertScanbeam(e.ytop);this.InsertEdgeIntoAEL(g);
this.IsEvenOddFillType(e)?(e.windDelta=1,g.windDelta=1):g.windDelta=-e.windDelta;this.SetWindingCount(e);g.windCnt=e.windCnt;g.windCnt2=e.windCnt2;g.dx==d.ClipperBase.horizontal?(this.AddEdgeToSEL(g),this.InsertScanbeam(g.nextInLML.ytop)):this.InsertScanbeam(g.ytop);this.IsContributing(e)&&this.AddLocalMinPoly(e,g,new d.IntPoint(e.xcurr,this.m_CurrentLM.y));if(0<=g.outIdx&&g.dx==d.ClipperBase.horizontal)for(var f=0;f<this.m_HorizJoins.length;f++){b=new d.IntPoint;c=new d.IntPoint;var h=this.m_HorizJoins[f];
b={Value:b};c={Value:c};this.GetOverlapSegment(new d.IntPoint(h.edge.xbot,h.edge.ybot),new d.IntPoint(h.edge.xtop,h.edge.ytop),new d.IntPoint(g.xbot,g.ybot),new d.IntPoint(g.xtop,g.ytop),b,c)&&this.AddJoin(h.edge,g,h.savedIdx,-1)}if(e.nextInAEL!=g)for(0<=g.outIdx&&0<=g.prevInAEL.outIdx&&this.SlopesEqual(g.prevInAEL,g,this.m_UseFullRange)&&this.AddJoin(g,g.prevInAEL,-1,-1),c=e.nextInAEL,b=new d.IntPoint(e.xcurr,e.ycurr);c!=g;)null==c&&d.Error("InsertLocalMinimaIntoAEL: missing rightbound!"),this.IntersectEdges(g,
c,b,d.Protects.ipNone),c=c.nextInAEL;this.PopLocalMinima()}};d.Clipper.prototype.InsertEdgeIntoAEL=function(a){a.prevInAEL=null;a.nextInAEL=null;if(null==this.m_ActiveEdges)this.m_ActiveEdges=a;else if(this.E2InsertsBeforeE1(this.m_ActiveEdges,a))a.nextInAEL=this.m_ActiveEdges,this.m_ActiveEdges=this.m_ActiveEdges.prevInAEL=a;else{for(var b=this.m_ActiveEdges;null!=b.nextInAEL&&!this.E2InsertsBeforeE1(b.nextInAEL,a);)b=b.nextInAEL;a.nextInAEL=b.nextInAEL;null!=b.nextInAEL&&(b.nextInAEL.prevInAEL=
a);a.prevInAEL=b;b.nextInAEL=a}};d.Clipper.prototype.E2InsertsBeforeE1=function(a,b){return b.xcurr==a.xcurr?b.dx>a.dx:b.xcurr<a.xcurr};d.Clipper.prototype.IsEvenOddFillType=function(a){return a.polyType==d.PolyType.ptSubject?this.m_SubjFillType==d.PolyFillType.pftEvenOdd:this.m_ClipFillType==d.PolyFillType.pftEvenOdd};d.Clipper.prototype.IsEvenOddAltFillType=function(a){return a.polyType==d.PolyType.ptSubject?this.m_ClipFillType==d.PolyFillType.pftEvenOdd:this.m_SubjFillType==d.PolyFillType.pftEvenOdd};
d.Clipper.prototype.IsContributing=function(a){var b,c;a.polyType==d.PolyType.ptSubject?(b=this.m_SubjFillType,c=this.m_ClipFillType):(b=this.m_ClipFillType,c=this.m_SubjFillType);switch(b){case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:if(1!=d.Math_Abs_Int32(a.windCnt))return!1;break;case d.PolyFillType.pftPositive:if(1!=a.windCnt)return!1;break;default:if(-1!=a.windCnt)return!1}switch(this.m_ClipType){case d.ClipType.ctIntersection:switch(c){case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:return 0!=
a.windCnt2;case d.PolyFillType.pftPositive:return 0<a.windCnt2;default:return 0>a.windCnt2}case d.ClipType.ctUnion:switch(c){case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:return 0==a.windCnt2;case d.PolyFillType.pftPositive:return 0>=a.windCnt2;default:return 0<=a.windCnt2}case d.ClipType.ctDifference:if(a.polyType==d.PolyType.ptSubject)switch(c){case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:return 0==a.windCnt2;case d.PolyFillType.pftPositive:return 0>=a.windCnt2;
default:return 0<=a.windCnt2}else switch(c){case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:return 0!=a.windCnt2;case d.PolyFillType.pftPositive:return 0<a.windCnt2;default:return 0>a.windCnt2}}return!0};d.Clipper.prototype.SetWindingCount=function(a){for(var b=a.prevInAEL;null!=b&&b.polyType!=a.polyType;)b=b.prevInAEL;null==b?(a.windCnt=a.windDelta,a.windCnt2=0,b=this.m_ActiveEdges):(this.IsEvenOddFillType(a)?a.windCnt=1:0>b.windCnt*b.windDelta?1<d.Math_Abs_Int32(b.windCnt)?a.windCnt=
0>b.windDelta*a.windDelta?b.windCnt:b.windCnt+a.windDelta:a.windCnt=b.windCnt+b.windDelta+a.windDelta:1<d.Math_Abs_Int32(b.windCnt)&&0>b.windDelta*a.windDelta?a.windCnt=b.windCnt:a.windCnt=0==b.windCnt+a.windDelta?b.windCnt:b.windCnt+a.windDelta,a.windCnt2=b.windCnt2,b=b.nextInAEL);if(this.IsEvenOddAltFillType(a))for(;b!=a;)a.windCnt2=0==a.windCnt2?1:0,b=b.nextInAEL;else for(;b!=a;)a.windCnt2+=b.windDelta,b=b.nextInAEL};d.Clipper.prototype.AddEdgeToSEL=function(a){null==this.m_SortedEdges?(this.m_SortedEdges=
a,a.prevInSEL=null,a.nextInSEL=null):(a.nextInSEL=this.m_SortedEdges,a.prevInSEL=null,this.m_SortedEdges=this.m_SortedEdges.prevInSEL=a)};d.Clipper.prototype.CopyAELToSEL=function(){var a=this.m_ActiveEdges;this.m_SortedEdges=a;if(null!=this.m_ActiveEdges)for(this.m_SortedEdges.prevInSEL=null,a=a.nextInAEL;null!=a;)a.prevInSEL=a.prevInAEL,a.prevInSEL.nextInSEL=a,a.nextInSEL=null,a=a.nextInAEL};d.Clipper.prototype.SwapPositionsInAEL=function(a,b){var c,d;if(null!=a.nextInAEL||null!=a.prevInAEL)if(null!=
b.nextInAEL||null!=b.prevInAEL)a.nextInAEL==b?(c=b.nextInAEL,null!=c&&(c.prevInAEL=a),d=a.prevInAEL,null!=d&&(d.nextInAEL=b),b.prevInAEL=d,b.nextInAEL=a,a.prevInAEL=b,a.nextInAEL=c):b.nextInAEL==a?(c=a.nextInAEL,null!=c&&(c.prevInAEL=b),d=b.prevInAEL,null!=d&&(d.nextInAEL=a),a.prevInAEL=d,a.nextInAEL=b,b.prevInAEL=a,b.nextInAEL=c):(c=a.nextInAEL,d=a.prevInAEL,a.nextInAEL=b.nextInAEL,null!=a.nextInAEL&&(a.nextInAEL.prevInAEL=a),a.prevInAEL=b.prevInAEL,null!=a.prevInAEL&&(a.prevInAEL.nextInAEL=a),b.nextInAEL=
c,null!=b.nextInAEL&&(b.nextInAEL.prevInAEL=b),b.prevInAEL=d,null!=b.prevInAEL&&(b.prevInAEL.nextInAEL=b)),null==a.prevInAEL?this.m_ActiveEdges=a:null==b.prevInAEL&&(this.m_ActiveEdges=b)};d.Clipper.prototype.SwapPositionsInSEL=function(a,b){var c,d;if(null!=a.nextInSEL||null!=a.prevInSEL)if(null!=b.nextInSEL||null!=b.prevInSEL)a.nextInSEL==b?(c=b.nextInSEL,null!=c&&(c.prevInSEL=a),d=a.prevInSEL,null!=d&&(d.nextInSEL=b),b.prevInSEL=d,b.nextInSEL=a,a.prevInSEL=b,a.nextInSEL=c):b.nextInSEL==a?(c=a.nextInSEL,
null!=c&&(c.prevInSEL=b),d=b.prevInSEL,null!=d&&(d.nextInSEL=a),a.prevInSEL=d,a.nextInSEL=b,b.prevInSEL=a,b.nextInSEL=c):(c=a.nextInSEL,d=a.prevInSEL,a.nextInSEL=b.nextInSEL,null!=a.nextInSEL&&(a.nextInSEL.prevInSEL=a),a.prevInSEL=b.prevInSEL,null!=a.prevInSEL&&(a.prevInSEL.nextInSEL=a),b.nextInSEL=c,null!=b.nextInSEL&&(b.nextInSEL.prevInSEL=b),b.prevInSEL=d,null!=b.prevInSEL&&(b.prevInSEL.nextInSEL=b)),null==a.prevInSEL?this.m_SortedEdges=a:null==b.prevInSEL&&(this.m_SortedEdges=b)};d.Clipper.prototype.AddLocalMaxPoly=
function(a,b,c){this.AddOutPt(a,c);a.outIdx==b.outIdx?(a.outIdx=-1,b.outIdx=-1):a.outIdx<b.outIdx?this.AppendPolygon(a,b):this.AppendPolygon(b,a)};d.Clipper.prototype.AddLocalMinPoly=function(a,b,c){var e;b.dx==d.ClipperBase.horizontal||a.dx>b.dx?(this.AddOutPt(a,c),b.outIdx=a.outIdx,a.side=d.EdgeSide.esLeft,b.side=d.EdgeSide.esRight,e=a,a=e.prevInAEL==b?b.prevInAEL:e.prevInAEL):(this.AddOutPt(b,c),a.outIdx=b.outIdx,a.side=d.EdgeSide.esRight,b.side=d.EdgeSide.esLeft,e=b,a=e.prevInAEL==a?a.prevInAEL:
e.prevInAEL);null!=a&&0<=a.outIdx&&d.Clipper.TopX(a,c.y)==d.Clipper.TopX(e,c.y)&&this.SlopesEqual(e,a,this.m_UseFullRange)&&this.AddJoin(e,a,-1,-1)};d.Clipper.prototype.CreateOutRec=function(){var a=new d.OutRec;a.idx=-1;a.isHole=!1;a.FirstLeft=null;a.AppendLink=null;a.pts=null;a.bottomPt=null;return a};d.Clipper.prototype.AddOutPt=function(a,b){var c,e,g=a.side==d.EdgeSide.esLeft;if(0>a.outIdx)c=this.CreateOutRec(),this.m_PolyOuts.push(c),c.idx=this.m_PolyOuts.length-1,a.outIdx=c.idx,e=new d.OutPt,
c.pts=e,c.bottomPt=e,e.pt=b,e.idx=c.idx,e.next=e,e.prev=e,this.SetHoleState(a,c);else{c=this.m_PolyOuts[a.outIdx];e=c.pts;var f;g&&d.ClipperBase.PointsEqual(b,e.pt)||!g&&d.ClipperBase.PointsEqual(b,e.prev.pt)||(f=new d.OutPt,f.pt=b,f.idx=c.idx,f.pt.y==c.bottomPt.pt.y&&f.pt.x<c.bottomPt.pt.x&&(c.bottomPt=f),f.next=e,f.prev=e.prev,f.prev.next=f,e.prev=f,g&&(c.pts=f))}};d.Clipper.prototype.SwapPoints=function(a,b){var c=a.Value;a.Value=b.Value;b.Value=c};d.Clipper.prototype.GetOverlapSegment=function(a,
b,c,e,g,f){if(d.Math_Abs_Int64(a.x-b.x)>d.Math_Abs_Int64(a.y-b.y))return a.x>b.x&&function(){a={Value:a};b={Value:b};var c=this.SwapPoints(a,b);a=a.Value;b=b.Value;return c}.call(this),c.x>e.x&&function(){c={Value:c};e={Value:e};var a=this.SwapPoints(c,e);c=c.Value;e=e.Value;return a}.call(this),g.Value=a.x>c.x?a:c,f.Value=b.x<e.x?b:e,g.Value.x<f.Value.x;a.y<b.y&&function(){a={Value:a};b={Value:b};var c=this.SwapPoints(a,b);a=a.Value;b=b.Value;return c}.call(this);c.y<e.y&&function(){c={Value:c};
e={Value:e};var a=this.SwapPoints(c,e);c=c.Value;e=e.Value;return a}.call(this);g.Value=a.y<c.y?a:c;f.Value=b.y>e.y?b:e;return g.Value.y>f.Value.y};d.Clipper.prototype.FindSegment=function(a,b,c,e){if(null==a.Value)return!1;var g=a.Value,f=new d.IntPoint(c.Value),h=new d.IntPoint(e.Value);do{if(this.SlopesEqual(f,h,a.Value.pt,a.Value.prev.pt,b)&&this.SlopesEqual(f,h,a.Value.pt,b)&&this.GetOverlapSegment(f,h,a.Value.pt,a.Value.prev.pt,c,e))return!0;a.Value=a.Value.next}while(a.Value!=g);return!1};
d.Clipper.prototype.Pt3IsBetweenPt1AndPt2=function(a,b,c){return d.ClipperBase.PointsEqual(a,c)||d.ClipperBase.PointsEqual(b,c)?!0:a.x!=b.x?a.x<c.x==c.x<b.x:a.y<c.y==c.y<b.y};d.Clipper.prototype.InsertPolyPtBetween=function(a,b,c){var e=new d.OutPt;e.pt=c;b==a.next?(a.next=e,b.prev=e,e.next=b,e.prev=a):(b.next=e,a.prev=e,e.next=a,e.prev=b);return e};d.Clipper.prototype.SetHoleState=function(a,b){for(var c=!1,d=a.prevInAEL;null!=d;)0<=d.outIdx&&(c=!c,null==b.FirstLeft&&(b.FirstLeft=this.m_PolyOuts[d.outIdx])),
d=d.prevInAEL;c&&(b.isHole=!0)};d.Clipper.prototype.GetDx=function(a,b){return a.y==b.y?d.ClipperBase.horizontal:(b.x-a.x)/(b.y-a.y)};d.Clipper.prototype.FirstIsBottomPt=function(a,b){for(var c=a.prev;d.ClipperBase.PointsEqual(c.pt,a.pt)&&c!=a;)c=c.prev;for(var e=d.Math_Abs_Double(this.GetDx(a.pt,c.pt)),c=a.next;d.ClipperBase.PointsEqual(c.pt,a.pt)&&c!=a;)c=c.next;for(var g=d.Math_Abs_Double(this.GetDx(a.pt,c.pt)),c=b.prev;d.ClipperBase.PointsEqual(c.pt,b.pt)&&c!=b;)c=c.prev;for(var f=d.Math_Abs_Double(this.GetDx(b.pt,
c.pt)),c=b.next;d.ClipperBase.PointsEqual(c.pt,b.pt)&&c!=b;)c=c.next;c=d.Math_Abs_Double(this.GetDx(b.pt,c.pt));return e>=f&&e>=c||g>=f&&g>=c};d.Clipper.prototype.GetBottomPt=function(a){for(var b=null,c=a.next;c!=a;)c.pt.y>a.pt.y?(a=c,b=null):c.pt.y==a.pt.y&&c.pt.x<=a.pt.x&&(c.pt.x<a.pt.x?(b=null,a=c):c.next!=a&&c.prev!=a&&(b=c)),c=c.next;if(null!=b)for(;b!=c;)for(this.FirstIsBottomPt(c,b)||(a=b),b=b.next;!d.ClipperBase.PointsEqual(b.pt,a.pt);)b=b.next;return a};d.Clipper.prototype.GetLowermostRec=
function(a,b){var c=a.bottomPt,d=b.bottomPt;return c.pt.y>d.pt.y?a:c.pt.y<d.pt.y?b:c.pt.x<d.pt.x?a:c.pt.x>d.pt.x?b:c.next==c?b:d.next==d?a:this.FirstIsBottomPt(c,d)?a:b};d.Clipper.prototype.Param1RightOfParam2=function(a,b){do if(a=a.FirstLeft,a==b)return!0;while(null!=a);return!1};d.Clipper.prototype.AppendPolygon=function(a,b){var c=this.m_PolyOuts[a.outIdx],e=this.m_PolyOuts[b.outIdx],g;g=this.Param1RightOfParam2(c,e)?e:this.Param1RightOfParam2(e,c)?c:this.GetLowermostRec(c,e);var f=c.pts,h=f.prev,
l=e.pts,k=l.prev;a.side==d.EdgeSide.esLeft?(b.side==d.EdgeSide.esLeft?(this.ReversePolyPtLinks(l),l.next=f,f.prev=l,h.next=k,k.prev=h,c.pts=k):(k.next=f,f.prev=k,l.prev=h,h.next=l,c.pts=l),f=d.EdgeSide.esLeft):(b.side==d.EdgeSide.esRight?(this.ReversePolyPtLinks(l),h.next=k,k.prev=h,l.next=f,f.prev=l):(h.next=l,l.prev=h,f.prev=k,k.next=f),f=d.EdgeSide.esRight);g==e&&(c.bottomPt=e.bottomPt,c.bottomPt.idx=c.idx,e.FirstLeft!=c&&(c.FirstLeft=e.FirstLeft),c.isHole=e.isHole);e.pts=null;e.bottomPt=null;
e.AppendLink=c;c=a.outIdx;e=b.outIdx;a.outIdx=-1;b.outIdx=-1;for(g=this.m_ActiveEdges;null!=g;){if(g.outIdx==e){g.outIdx=c;g.side=f;break}g=g.nextInAEL}for(g=0;g<this.m_Joins.length;++g)this.m_Joins[g].poly1Idx==e&&(this.m_Joins[g].poly1Idx=c),this.m_Joins[g].poly2Idx==e&&(this.m_Joins[g].poly2Idx=c);for(g=0;g<this.m_HorizJoins.length;++g)this.m_HorizJoins[g].savedIdx==e&&(this.m_HorizJoins[g].savedIdx=c)};d.Clipper.prototype.ReversePolyPtLinks=function(a){if(null!=a){var b,c;b=a;do c=b.next,b.next=
b.prev,b=b.prev=c;while(b!=a)}};d.Clipper.SwapSides=function(a,b){var c=a.side;a.side=b.side;b.side=c};d.Clipper.SwapPolyIndexes=function(a,b){var c=a.outIdx;a.outIdx=b.outIdx;b.outIdx=c};d.Clipper.prototype.DoEdge1=function(a,b,c){this.AddOutPt(a,c);d.Clipper.SwapSides(a,b);d.Clipper.SwapPolyIndexes(a,b)};d.Clipper.prototype.DoEdge2=function(a,b,c){this.AddOutPt(b,c);d.Clipper.SwapSides(a,b);d.Clipper.SwapPolyIndexes(a,b)};d.Clipper.prototype.DoBothEdges=function(a,b,c){this.AddOutPt(a,c);this.AddOutPt(b,
c);d.Clipper.SwapSides(a,b);d.Clipper.SwapPolyIndexes(a,b)};d.Clipper.prototype.IntersectEdges=function(a,b,c,e){var g=0==(d.Protects.ipLeft&e)&&null==a.nextInLML&&a.xtop==c.x&&a.ytop==c.y;e=0==(d.Protects.ipRight&e)&&null==b.nextInLML&&b.xtop==c.x&&b.ytop==c.y;var f=0<=a.outIdx,h=0<=b.outIdx;if(a.polyType==b.polyType)if(this.IsEvenOddFillType(a)){var l=a.windCnt;a.windCnt=b.windCnt;b.windCnt=l}else a.windCnt=0==a.windCnt+b.windDelta?-a.windCnt:a.windCnt+b.windDelta,b.windCnt=0==b.windCnt-a.windDelta?
-b.windCnt:b.windCnt-a.windDelta;else this.IsEvenOddFillType(b)?a.windCnt2=0==a.windCnt2?1:0:a.windCnt2+=b.windDelta,this.IsEvenOddFillType(a)?b.windCnt2=0==b.windCnt2?1:0:b.windCnt2-=a.windDelta;var k,m,r;a.polyType==d.PolyType.ptSubject?(k=this.m_SubjFillType,r=this.m_ClipFillType):(k=this.m_ClipFillType,r=this.m_SubjFillType);b.polyType==d.PolyType.ptSubject?(m=this.m_SubjFillType,l=this.m_ClipFillType):(m=this.m_ClipFillType,l=this.m_SubjFillType);switch(k){case d.PolyFillType.pftPositive:k=a.windCnt;
break;case d.PolyFillType.pftNegative:k=-a.windCnt;break;default:k=d.Math_Abs_Int32(a.windCnt)}switch(m){case d.PolyFillType.pftPositive:m=b.windCnt;break;case d.PolyFillType.pftNegative:m=-b.windCnt;break;default:m=d.Math_Abs_Int32(b.windCnt)}if(f&&h)g||e||0!=k&&1!=k||0!=m&&1!=m||a.polyType!=b.polyType&&this.m_ClipType!=d.ClipType.ctXor?this.AddLocalMaxPoly(a,b,c):this.DoBothEdges(a,b,c);else if(f)0!=m&&1!=m||this.m_ClipType==d.ClipType.ctIntersection&&b.polyType!=d.PolyType.ptSubject&&0==b.windCnt2||
this.DoEdge1(a,b,c);else if(h)0!=k&&1!=k||this.m_ClipType==d.ClipType.ctIntersection&&a.polyType!=d.PolyType.ptSubject&&0==a.windCnt2||this.DoEdge2(a,b,c);else if(!(0!=k&&1!=k||0!=m&&1!=m||g||e)){switch(r){case d.PolyFillType.pftPositive:f=a.windCnt2;break;case d.PolyFillType.pftNegative:f=-a.windCnt2;break;default:f=d.Math_Abs_Int32(a.windCnt2)}switch(l){case d.PolyFillType.pftPositive:h=b.windCnt2;break;case d.PolyFillType.pftNegative:h=-b.windCnt2;break;default:h=d.Math_Abs_Int32(b.windCnt2)}if(a.polyType!=
b.polyType)this.AddLocalMinPoly(a,b,c);else if(1==k&&1==m)switch(this.m_ClipType){case d.ClipType.ctIntersection:0<f&&0<h&&this.AddLocalMinPoly(a,b,c);break;case d.ClipType.ctUnion:0>=f&&0>=h&&this.AddLocalMinPoly(a,b,c);break;case d.ClipType.ctDifference:(a.polyType==d.PolyType.ptClip&&0<f&&0<h||a.polyType==d.PolyType.ptSubject&&0>=f&&0>=h)&&this.AddLocalMinPoly(a,b,c);break;case d.ClipType.ctXor:this.AddLocalMinPoly(a,b,c)}else d.Clipper.SwapSides(a,b)}g!=e&&(g&&0<=a.outIdx||e&&0<=b.outIdx)&&(d.Clipper.SwapSides(a,
b),d.Clipper.SwapPolyIndexes(a,b));g&&this.DeleteFromAEL(a);e&&this.DeleteFromAEL(b)};d.Clipper.prototype.DeleteFromAEL=function(a){var b=a.prevInAEL,c=a.nextInAEL;if(null!=b||null!=c||a==this.m_ActiveEdges)null!=b?b.nextInAEL=c:this.m_ActiveEdges=c,null!=c&&(c.prevInAEL=b),a.nextInAEL=null,a.prevInAEL=null};d.Clipper.prototype.DeleteFromSEL=function(a){var b=a.prevInSEL,c=a.nextInSEL;if(null!=b||null!=c||a==this.m_SortedEdges)null!=b?b.nextInSEL=c:this.m_SortedEdges=c,null!=c&&(c.prevInSEL=b),a.nextInSEL=
null,a.prevInSEL=null};d.Clipper.prototype.UpdateEdgeIntoAEL=function(a){null==a.Value.nextInLML&&d.Error("UpdateEdgeIntoAEL: invalid call");var b=a.Value.prevInAEL,c=a.Value.nextInAEL;a.Value.nextInLML.outIdx=a.Value.outIdx;null!=b?b.nextInAEL=a.Value.nextInLML:this.m_ActiveEdges=a.Value.nextInLML;null!=c&&(c.prevInAEL=a.Value.nextInLML);a.Value.nextInLML.side=a.Value.side;a.Value.nextInLML.windDelta=a.Value.windDelta;a.Value.nextInLML.windCnt=a.Value.windCnt;a.Value.nextInLML.windCnt2=a.Value.windCnt2;
a.Value=a.Value.nextInLML;a.Value.prevInAEL=b;a.Value.nextInAEL=c;a.Value.dx!=d.ClipperBase.horizontal&&this.InsertScanbeam(a.Value.ytop)};d.Clipper.prototype.ProcessHorizontals=function(){for(var a=this.m_SortedEdges;null!=a;)this.DeleteFromSEL(a),this.ProcessHorizontal(a),a=this.m_SortedEdges};d.Clipper.prototype.ProcessHorizontal=function(a){var b,c,e;a.xcurr<a.xtop?(c=a.xcurr,e=a.xtop,b=d.Direction.dLeftToRight):(c=a.xtop,e=a.xcurr,b=d.Direction.dRightToLeft);var g;g=null!=a.nextInLML?null:this.GetMaximaPair(a);
for(var f=this.GetNextInAEL(a,b);null!=f;){var h=this.GetNextInAEL(f,b);if(null!=g||b==d.Direction.dLeftToRight&&f.xcurr<=e||b==d.Direction.dRightToLeft&&f.xcurr>=c){if(f.xcurr==a.xtop&&null==g)if(this.SlopesEqual(f,a.nextInLML,this.m_UseFullRange)){0<=a.outIdx&&0<=f.outIdx&&this.AddJoin(a.nextInLML,f,a.outIdx,-1);break}else if(f.dx<a.nextInLML.dx)break;if(f==g){b==d.Direction.dLeftToRight?this.IntersectEdges(a,f,new d.IntPoint(f.xcurr,a.ycurr),0):this.IntersectEdges(f,a,new d.IntPoint(f.xcurr,a.ycurr),
0);0<=g.outIdx&&d.Error("ProcessHorizontal error");return}f.dx!=d.ClipperBase.horizontal||this.IsMinima(f);b==d.Direction.dLeftToRight?this.IntersectEdges(a,f,new d.IntPoint(f.xcurr,a.ycurr),this.IsTopHorz(a,f.xcurr)?d.Protects.ipLeft:d.Protects.ipBoth):this.IntersectEdges(f,a,new d.IntPoint(f.xcurr,a.ycurr),this.IsTopHorz(a,f.xcurr)?d.Protects.ipRight:d.Protects.ipBoth);this.SwapPositionsInAEL(a,f)}else if(b==d.Direction.dLeftToRight&&f.xcurr>e&&null==a.nextInSEL||b==d.Direction.dRightToLeft&&f.xcurr<
c&&null==a.nextInSEL)break;f=h}null!=a.nextInLML?(0<=a.outIdx&&this.AddOutPt(a,new d.IntPoint(a.xtop,a.ytop)),a={Value:a},this.UpdateEdgeIntoAEL(a)):(0<=a.outIdx&&this.IntersectEdges(a,g,new d.IntPoint(a.xtop,a.ycurr),d.Protects.ipBoth),this.DeleteFromAEL(g),this.DeleteFromAEL(a))};d.Clipper.prototype.IsTopHorz=function(a,b){for(var c=this.m_SortedEdges;null!=c;){if(b>=Math.min(c.xcurr,c.xtop)&&b<=Math.max(c.xcurr,c.xtop))return!1;c=c.nextInSEL}return!0};d.Clipper.prototype.GetNextInAEL=function(a,
b){return b==d.Direction.dLeftToRight?a.nextInAEL:a.prevInAEL};d.Clipper.prototype.IsMinima=function(a){return null!=a&&a.prev.nextInLML!=a&&a.next.nextInLML!=a};d.Clipper.prototype.IsMaxima=function(a,b){return null!=a&&a.ytop==b&&null==a.nextInLML};d.Clipper.prototype.IsIntermediate=function(a,b){return a.ytop==b&&null!=a.nextInLML};d.Clipper.prototype.GetMaximaPair=function(a){return this.IsMaxima(a.next,a.ytop)&&a.next.xtop==a.xtop?a.next:a.prev};d.Clipper.prototype.ProcessIntersections=function(a,
b){if(null==this.m_ActiveEdges)return!0;try{this.BuildIntersectList(a,b);if(null==this.m_IntersectNodes)return!0;if(this.FixupIntersections())this.ProcessIntersectList();else return!1}catch(c){this.m_SortedEdges=null,this.DisposeIntersectNodes(),d.Error("ProcessIntersections error")}return!0};d.Clipper.prototype.BuildIntersectList=function(a,b){if(null!=this.m_ActiveEdges){var c=this.m_ActiveEdges;c.tmpX=d.Clipper.TopX(c,b);this.m_SortedEdges=c;this.m_SortedEdges.prevInSEL=null;for(c=c.nextInAEL;null!=
c;)c.prevInSEL=c.prevInAEL,c.prevInSEL.nextInSEL=c,c.nextInSEL=null,c.tmpX=d.Clipper.TopX(c,b),c=c.nextInAEL;for(var e=!0;e&&null!=this.m_SortedEdges;){e=!1;for(c=this.m_SortedEdges;null!=c.nextInSEL;){var g=c.nextInSEL,f=new d.IntPoint,h;if(h=c.tmpX>g.tmpX)f={Value:f},h=this.IntersectPoint(c,g,f),f=f.Value;h?(f.y>a&&(f.y=a,f.x=d.Clipper.TopX(c,f.y)),this.AddIntersectNode(c,g,f),this.SwapPositionsInSEL(c,g),e=!0):c=g}if(null!=c.prevInSEL)c.prevInSEL.nextInSEL=null;else break}this.m_SortedEdges=null}};
d.Clipper.prototype.FixupIntersections=function(){if(null==this.m_IntersectNodes.next)return!0;this.CopyAELToSEL();for(var a=this.m_IntersectNodes,b=this.m_IntersectNodes.next;null!=b;){var c=a.edge1;if(c.prevInSEL==a.edge2)b=c.prevInSEL;else if(c.nextInSEL==a.edge2)b=c.nextInSEL;else{for(;null!=b&&b.edge1.nextInSEL!=b.edge2&&b.edge1.prevInSEL!=b.edge2;)b=b.next;if(null==b)return!1;this.SwapIntersectNodes(a,b);c=a.edge1;b=a.edge2}this.SwapPositionsInSEL(c,b);a=a.next;b=a.next}this.m_SortedEdges=null;
return a.edge1.prevInSEL==a.edge2||a.edge1.nextInSEL==a.edge2};d.Clipper.prototype.ProcessIntersectList=function(){for(;null!=this.m_IntersectNodes;){var a=this.m_IntersectNodes.next;this.IntersectEdges(this.m_IntersectNodes.edge1,this.m_IntersectNodes.edge2,this.m_IntersectNodes.pt,d.Protects.ipBoth);this.SwapPositionsInAEL(this.m_IntersectNodes.edge1,this.m_IntersectNodes.edge2);this.m_IntersectNodes=null;this.m_IntersectNodes=a}};z=function(a){return 0>a?Math.ceil(a-0.5):Math.round(a)};I=function(a){return 0>
a?Math.ceil(a-0.5):Math.floor(a+0.5)};J=function(a){return 0>a?-Math.round(Math.abs(a)):Math.round(a)};K=function(a){if(0>a)return a-=0.5,-2147483648>a?Math.ceil(a):a|0;a+=0.5;return 2147483647<a?Math.floor(a):a|0};d.Clipper.Round=q?z:v?J:y?K:I;d.Clipper.TopX=function(a,b){return b==a.ytop?a.xtop:a.xbot+d.Clipper.Round(a.dx*(b-a.ybot))};d.Clipper.prototype.AddIntersectNode=function(a,b,c){var e=new d.IntersectNode;e.edge1=a;e.edge2=b;e.pt=c;e.next=null;if(null==this.m_IntersectNodes)this.m_IntersectNodes=
e;else if(this.ProcessParam1BeforeParam2(e,this.m_IntersectNodes))e.next=this.m_IntersectNodes,this.m_IntersectNodes=e;else{for(a=this.m_IntersectNodes;null!=a.next&&this.ProcessParam1BeforeParam2(a.next,e);)a=a.next;e.next=a.next;a.next=e}};d.Clipper.prototype.ProcessParam1BeforeParam2=function(a,b){var c;return a.pt.y==b.pt.y?a.edge1==b.edge1||a.edge2==b.edge1?(c=b.pt.x>a.pt.x,0<b.edge1.dx?!c:c):a.edge1==b.edge2||a.edge2==b.edge2?(c=b.pt.x>a.pt.x,0<b.edge2.dx?!c:c):b.pt.x>a.pt.x:a.pt.y>b.pt.y};
d.Clipper.prototype.SwapIntersectNodes=function(a,b){var c=a.edge1,d=a.edge2,g=a.pt;a.edge1=b.edge1;a.edge2=b.edge2;a.pt=b.pt;b.edge1=c;b.edge2=d;b.pt=g};d.Clipper.prototype.IntersectPoint=function(a,b,c){var e,g;if(this.SlopesEqual(a,b,this.m_UseFullRange))return!1;if(0==a.dx)c.Value.x=a.xbot,b.dx==d.ClipperBase.horizontal?c.Value.y=b.ybot:(g=b.ybot-b.xbot/b.dx,c.Value.y=d.Clipper.Round(c.Value.x/b.dx+g));else if(0==b.dx)c.Value.x=b.xbot,a.dx==d.ClipperBase.horizontal?c.Value.y=a.ybot:(e=a.ybot-
a.xbot/a.dx,c.Value.y=d.Clipper.Round(c.Value.x/a.dx+e));else{e=a.xbot-a.ybot*a.dx;g=b.xbot-b.ybot*b.dx;var f=(g-e)/(a.dx-b.dx);c.Value.y=d.Clipper.Round(f);d.Math_Abs_Double(a.dx)<d.Math_Abs_Double(b.dx)?c.Value.x=d.Clipper.Round(a.dx*f+e):c.Value.x=d.Clipper.Round(b.dx*f+g)}if(c.Value.y<a.ytop||c.Value.y<b.ytop){if(a.ytop>b.ytop)return c.Value.x=a.xtop,c.Value.y=a.ytop,d.Clipper.TopX(b,a.ytop)<a.xtop;c.Value.x=b.xtop;c.Value.y=b.ytop;return d.Clipper.TopX(a,b.ytop)>b.xtop}return!0};d.Clipper.prototype.DisposeIntersectNodes=
function(){for(;null!=this.m_IntersectNodes;){var a=this.m_IntersectNodes.next;this.m_IntersectNodes=null;this.m_IntersectNodes=a}};d.Clipper.prototype.ProcessEdgesAtTopOfScanbeam=function(a){for(var b=this.m_ActiveEdges,c;null!=b;)if(this.IsMaxima(b,a)&&this.GetMaximaPair(b).dx!=d.ClipperBase.horizontal)c=b.prevInAEL,this.DoMaxima(b,a),b=null==c?this.m_ActiveEdges:c.nextInAEL;else{if(this.IsIntermediate(b,a)&&b.nextInLML.dx==d.ClipperBase.horizontal){if(0<=b.outIdx){this.AddOutPt(b,new d.IntPoint(b.xtop,
b.ytop));for(c=0;c<this.m_HorizJoins.length;++c){var e=new d.IntPoint,g=new d.IntPoint,f=this.m_HorizJoins[c];(function(){e={Value:e};g={Value:g};var a=this.GetOverlapSegment(new d.IntPoint(f.edge.xbot,f.edge.ybot),new d.IntPoint(f.edge.xtop,f.edge.ytop),new d.IntPoint(b.nextInLML.xbot,b.nextInLML.ybot),new d.IntPoint(b.nextInLML.xtop,b.nextInLML.ytop),e,g);e=e.Value;g=g.Value;return a}).call(this)&&this.AddJoin(f.edge,b.nextInLML,f.savedIdx,b.outIdx)}this.AddHorzJoin(b.nextInLML,b.outIdx)}(function(){b=
{Value:b};var a=this.UpdateEdgeIntoAEL(b);b=b.Value;return a}).call(this);this.AddEdgeToSEL(b)}else b.xcurr=d.Clipper.TopX(b,a),b.ycurr=a;b=b.nextInAEL}this.ProcessHorizontals();for(b=this.m_ActiveEdges;null!=b;){if(this.IsIntermediate(b,a)){0<=b.outIdx&&this.AddOutPt(b,new d.IntPoint(b.xtop,b.ytop));(function(){b={Value:b};var a=this.UpdateEdgeIntoAEL(b);b=b.Value;return a}).call(this);c=b.prevInAEL;var h=b.nextInAEL;null!=c&&c.xcurr==b.xbot&&c.ycurr==b.ybot&&0<=b.outIdx&&0<=c.outIdx&&c.ycurr>c.ytop&&
this.SlopesEqual(b,c,this.m_UseFullRange)?(this.AddOutPt(c,new d.IntPoint(b.xbot,b.ybot)),this.AddJoin(b,c,-1,-1)):null!=h&&h.xcurr==b.xbot&&h.ycurr==b.ybot&&0<=b.outIdx&&0<=h.outIdx&&h.ycurr>h.ytop&&this.SlopesEqual(b,h,this.m_UseFullRange)&&(this.AddOutPt(h,new d.IntPoint(b.xbot,b.ybot)),this.AddJoin(b,h,-1,-1))}b=b.nextInAEL}};d.Clipper.prototype.DoMaxima=function(a,b){for(var c=this.GetMaximaPair(a),e=a.xtop,g=a.nextInAEL;g!=c;)null==g&&d.Error("DoMaxima error"),this.IntersectEdges(a,g,new d.IntPoint(e,
b),d.Protects.ipBoth),g=g.nextInAEL;0>a.outIdx&&0>c.outIdx?(this.DeleteFromAEL(a),this.DeleteFromAEL(c)):0<=a.outIdx&&0<=c.outIdx?this.IntersectEdges(a,c,new d.IntPoint(e,b),d.Protects.ipNone):d.Error("DoMaxima error")};d.Clipper.ReversePolygons=function(a){for(var b=a.length,c=0;c<b;c++)a[c]instanceof Array&&a[c].reverse()};d.Clipper.Orientation=function(a){return 0<=this.Area(a)};d.Clipper.prototype.PointCount=function(a){if(null==a)return 0;var b=0,c=a;do b++,c=c.next;while(c!=a);return b};d.Clipper.prototype.BuildResult=
function(a){d.Clear(a);for(var b,c=this.m_PolyOuts.length,e=0;e<c;e++)if(b=this.m_PolyOuts[e],null!=b.pts){b=b.pts;var g=this.PointCount(b);if(!(3>g)){for(var f=new d.Polygon(g),h=0;h<g;h++)f.push(new d.IntPoint(b.pt.x,b.pt.y)),b=b.prev;a.push(f)}}};d.Clipper.prototype.BuildResultEx=function(a){d.Clear(a);for(var b=0;b<this.m_PolyOuts.length;){var c=this.m_PolyOuts[b++];if(null==c.pts)break;var e=c.pts,c=this.PointCount(e);if(!(3>c)){var g=new d.ExPolygon;g.outer=new d.Polygon;g.holes=new d.Polygons;
for(var f=0;f<c;f++)g.outer.push(new d.IntPoint(e.pt.x,e.pt.y)),e=e.prev;for(;b<this.m_PolyOuts.length;){c=this.m_PolyOuts[b];if(null==c.pts||!c.isHole)break;f=new d.Polygon;e=c.pts;do f.push(new d.IntPoint(e.pt.x,e.pt.y)),e=e.prev;while(e!=c.pts);g.holes.push(f);b++}a.push(g)}}};d.Clipper.prototype.FixupOutPolygon=function(a){for(var b=null,c=a.pts=a.bottomPt;;){if(c.prev==c||c.prev==c.next){this.DisposeOutPts(c);a.pts=null;a.bottomPt=null;return}if(d.ClipperBase.PointsEqual(c.pt,c.next.pt)||this.SlopesEqual(c.prev.pt,
c.pt,c.next.pt,this.m_UseFullRange))b=null,c==a.bottomPt&&(a.bottomPt=null),c.prev.next=c.next,c=c.next.prev=c.prev;else if(c==b)break;else null==b&&(b=c),c=c.next}null==a.bottomPt&&(a.bottomPt=this.GetBottomPt(c),a.bottomPt.idx=a.idx,a.pts=a.bottomPt)};d.Clipper.prototype.JoinPoints=function(a,b,c){b.Value=null;c.Value=null;var e=this.m_PolyOuts[a.poly1Idx],g=this.m_PolyOuts[a.poly2Idx];if(null==e||null==g)return!1;var f=e.pts,h=g.pts,k=a.pt2a,p=a.pt2b,m=a.pt1a,r=a.pt1b;if(!function(){f={Value:f};
k={Value:k};p={Value:p};var a=this.FindSegment(f,this.m_UseFullRange,k,p);f=f.Value;k=k.Value;p=p.Value;return a}.call(this))return!1;if(e==g){if(h=f.next,!function(){h={Value:h};m={Value:m};r={Value:r};var a=this.FindSegment(h,this.m_UseFullRange,m,r);h=h.Value;m=m.Value;r=r.Value;return a}.call(this)||h==f)return!1}else if(!function(){h={Value:h};m={Value:m};r={Value:r};var a=this.FindSegment(h,this.m_UseFullRange,m,r);h=h.Value;m=m.Value;r=r.Value;return a}.call(this))return!1;if(!function(){k=
{Value:k};p={Value:p};var a=this.GetOverlapSegment(k.Value,p.Value,m,r,k,p);k=k.Value;p=p.Value;return a}.call(this))return!1;e=f.prev;d.ClipperBase.PointsEqual(f.pt,k)?b.Value=f:d.ClipperBase.PointsEqual(e.pt,k)?b.Value=e:b.Value=this.InsertPolyPtBetween(f,e,k);d.ClipperBase.PointsEqual(f.pt,p)?c.Value=f:d.ClipperBase.PointsEqual(e.pt,p)?c.Value=e:b.Value==f||b.Value==e?c.Value=this.InsertPolyPtBetween(f,e,p):this.Pt3IsBetweenPt1AndPt2(f.pt,b.Value.pt,p)?c.Value=this.InsertPolyPtBetween(f,b.Value,
p):c.Value=this.InsertPolyPtBetween(b.Value,e,p);e=h.prev;a=d.ClipperBase.PointsEqual(h.pt,k)?h:d.ClipperBase.PointsEqual(e.pt,k)?e:this.InsertPolyPtBetween(h,e,k);e=d.ClipperBase.PointsEqual(h.pt,p)?h:d.ClipperBase.PointsEqual(e.pt,p)?e:a==h||a==e?this.InsertPolyPtBetween(h,e,p):this.Pt3IsBetweenPt1AndPt2(h.pt,a.pt,p)?this.InsertPolyPtBetween(h,a,p):this.InsertPolyPtBetween(a,e,p);return b.Value.next==c.Value&&a.prev==e?(b.Value.next=a,a.prev=b.Value,c.Value.prev=e,e.next=c.Value,!0):b.Value.prev==
c.Value&&a.next==e?(b.Value.prev=a,a.next=b.Value,c.Value.next=e,e.prev=c.Value,!0):!1};d.Clipper.prototype.FixupJoinRecs=function(a,b,c){for(;c<this.m_Joins.length;c++){var d=this.m_Joins[c];d.poly1Idx==a.poly1Idx&&this.PointIsVertex(d.pt1a,b)&&(d.poly1Idx=a.poly2Idx);d.poly2Idx==a.poly1Idx&&this.PointIsVertex(d.pt2a,b)&&(d.poly2Idx=a.poly2Idx)}};d.Clipper.prototype.JoinCommonEdges=function(){for(var a,b,c=0;c<this.m_Joins.length;c++){a=this.m_Joins[c];var d,g;d={Value:d};g={Value:g};var f=this.JoinPoints(a,
d,g);d=d.Value;g=g.Value;if(f){var f=this.m_PolyOuts[a.poly1Idx],h=this.m_PolyOuts[a.poly2Idx];if(f==h)if(f.pts=this.GetBottomPt(d),f.bottomPt=f.pts,f.bottomPt.idx=f.idx,h=this.CreateOutRec(),this.m_PolyOuts.push(h),h.idx=this.m_PolyOuts.length-1,a.poly2Idx=h.idx,h.pts=this.GetBottomPt(g),h.bottomPt=h.pts,h.bottomPt.idx=h.idx,this.PointInPolygon(h.pts.pt,f.pts,this.m_UseFullRange))h.isHole=!f.isHole,h.FirstLeft=f,this.FixupJoinRecs(a,g,c+1),this.FixupOutPolygon(f),this.FixupOutPolygon(h),(h.isHole^
this.m_ReverseOutput)==0<this.Area(h,this.m_UseFullRange)&&this.ReversePolyPtLinks(h.pts);else if(this.PointInPolygon(f.pts.pt,h.pts,this.m_UseFullRange)){if(h.isHole=f.isHole,f.isHole=!h.isHole,h.FirstLeft=f.FirstLeft,f.FirstLeft=h,this.FixupJoinRecs(a,g,c+1),this.FixupOutPolygon(f),this.FixupOutPolygon(h),(f.isHole^this.m_ReverseOutput)==0<this.Area(f,this.m_UseFullRange)&&this.ReversePolyPtLinks(f.pts),this.m_UsingExPolygons&&f.isHole)for(a=0;a<this.m_PolyOuts.length;++a)b=this.m_PolyOuts[a],b.isHole&&
null!=b.bottomPt&&b.FirstLeft==f&&(b.FirstLeft=h)}else{if(h.isHole=f.isHole,h.FirstLeft=f.FirstLeft,this.FixupJoinRecs(a,g,c+1),this.FixupOutPolygon(f),this.FixupOutPolygon(h),this.m_UsingExPolygons&&null!=h.pts)for(a=0;a<this.m_PolyOuts.length;++a)b=this.m_PolyOuts[a],b.isHole&&null!=b.bottomPt&&b.FirstLeft==f&&this.PointInPolygon(b.bottomPt.pt,h.pts,this.m_UseFullRange)&&(b.FirstLeft=h)}else{if(this.m_UsingExPolygons)for(a=0;a<this.m_PolyOuts.length;++a)this.m_PolyOuts[a].isHole&&null!=this.m_PolyOuts[a].bottomPt&&
this.m_PolyOuts[a].FirstLeft==h&&(this.m_PolyOuts[a].FirstLeft=f);this.FixupOutPolygon(f);null!=f.pts&&(f.isHole=0>this.Area(f,this.m_UseFullRange),f.isHole&&null==f.FirstLeft&&(f.FirstLeft=h.FirstLeft));b=f.idx;var k=h.idx;h.pts=null;h.bottomPt=null;h.AppendLink=f;for(a=c+1;a<this.m_Joins.length;a++)f=this.m_Joins[a],f.poly1Idx==k&&(f.poly1Idx=b),f.poly2Idx==k&&(f.poly2Idx=b)}}}};d.Clipper.FullRangeNeeded=function(a){for(var b=!1,c=0;c<a.length;c++)if(d.Math_Abs_Int64(a[c].x)>d.ClipperBase.hiRange||
d.Math_Abs_Int64(a[c].y)>d.ClipperBase.hiRange)d.Error("Coordinate exceeds range bounds in FullRangeNeeded().");else if(d.Math_Abs_Int64(a[c].x)>d.ClipperBase.loRange||d.Math_Abs_Int64(a[c].y)>d.ClipperBase.loRange)b=!0;return b};d.Clipper.prototype.Area=d.Clipper.Area=function(){var a=arguments,b;if(1==a.length){var c=a[0],e=c.length-1;if(2>e)return 0;if(d.Clipper.FullRangeNeeded(c)){a=(new k(c[e].x+c[0].x)).multiply(new k(c[0].y-c[e].y));for(b=1;b<=e;++b)a=a.add((new k(c[b-1].x+c[b].x)).multiply(new k(c[b].y-
c[b-1].y)));return parseFloat(a.toString())/2}a=(c[e].x+c[0].x)*(c[0].y-c[e].y);for(b=1;b<=e;++b)a+=(c[b-1].x+c[b].x)*(c[b].y-c[b-1].y);return a/2}if(2==a.length){b=a[0];c=b.pts;if(null==c)return 0;if(a[1]){a=new k(k.ZERO);do a=a.add((new k(c.pt.x+c.prev.pt.x)).multiply(new k(c.prev.pt.y-c.pt.y))),c=c.next;while(c!=b.pts);return parseFloat(a.toString())/2}a=0;do a+=(c.pt.x+c.prev.pt.x)*(c.prev.pt.y-c.pt.y),c=c.next;while(c!=b.pts);return a/2}};d.Clipper.BuildArc=function(a,b,c,e){var g=Math.sqrt(d.Math_Abs_Double(e))*
d.Math_Abs_Double(c-b),g=g/4;6>g&&(g=6);64<g&&(g=d.MaxSteps);var g=d.Cast_Int32(g),f=new d.Polygon;c=(c-b)/(g-1);for(var h=0;h<g;++h)f.push(new d.IntPoint(a.x+d.Clipper.Round(Math.cos(b)*e),a.y+d.Clipper.Round(Math.sin(b)*e))),b+=c;return f};d.Clipper.GetUnitNormal=function(a,b){var c=b.x-a.x,e=b.y-a.y;if(0==c&&0==e)return new d.Clipper.DoublePoint(0,0);var g=1/Math.sqrt(c*c+e*e);return new d.Clipper.DoublePoint(e*g,-(c*g))};d.Clipper.prototype.OffsetPolygons=function(a,b,c,e,g){var f=arguments;4==
f.length?g=!0:3==f.length?(e=2,g=!0):2==f.length&&(c=d.JoinType.jtSquare,e=2,g=!0);isNaN(b)?d.Error("Delta is not a number"):isNaN(e)&&d.Error("MiterLimit is not a number");f={};new d.Clipper.PolyOffsetBuilder(a,f,b,c,e,g);return f=f.Value?f.Value:[[]]};d.Clipper.prototype.SimplifyPolygon=function(a,b){var c=new d.Polygons,e=new d.Clipper;e.AddPolygon(a,d.PolyType.ptSubject)&&e.Execute(d.ClipType.ctUnion,c,b,b);return c};d.Clipper.prototype.SimplifyPolygons=function(a,b){var c=new d.Polygons,e=new d.Clipper;
e.AddPolygons(a,d.PolyType.ptSubject)&&e.Execute(d.ClipType.ctUnion,c,b,b);return c};v=d.Clipper;y=d.ClipperBase;var A;if("undefined"==typeof Object.getOwnPropertyNames)for(A in y.prototype){if("undefined"==typeof v.prototype[A]||v.prototype[A]==Object.prototype[A])v.prototype[A]=y.prototype[A]}else for(q=Object.getOwnPropertyNames(y.prototype),z=0;z<q.length;z++)"undefined"==typeof Object.getOwnPropertyDescriptor(v.prototype,q[z])&&Object.defineProperty(v.prototype,q[z],Object.getOwnPropertyDescriptor(y.prototype,
q[z]));for(A in y)"undefined"==typeof v[A]&&(v[A]=y[A]);v.$baseCtor=y;d.Clipper.DoublePoint=function(a,b){this.x=a;this.y=b};d.Clipper.PolyOffsetBuilder=function(a,b,c,e,g,f){this.normals=this.currentPoly=this.pts=null;this.m_k=this.m_j=this.m_i=this.m_R=this.delta=0;this.botPt=null;if(0==c)b.Value=a;else{this.pts=a;this.delta=c;if(f){for(var h=this.pts.length,k=0;k<h&&0==this.pts[k].length;)k++;if(k==h)return;this.botPt=this.pts[k][0];for(f=k;f<h;++f)for(this.UpdateBotPt(this.pts[f][0])&&(k=f),a=
this.pts[f].length-1;0<a;a--)d.ClipperBase.PointsEqual(this.pts[f][a],this.pts[f][a-1])?this.pts[f].splice(a,1):this.UpdateBotPt(this.pts[f][a])&&(k=f);d.Clipper.Orientation(this.pts[k])||d.Clipper.ReversePolygons(this.pts)}1>=g&&(g=1);f=2/(g*g);this.normals=[];b.Value=new d.Polygons;for(this.m_i=0;this.m_i<this.pts.length;this.m_i++)if(h=this.pts[this.m_i].length,1<h&&this.pts[this.m_i][0].x==this.pts[this.m_i][h-1].x&&this.pts[this.m_i][0].y==this.pts[this.m_i][h-1].y&&h--,!(0==h||3>h&&0>=c))if(1==
h)a=d.Clipper.BuildArc(this.pts[this.m_i][h-1],0,d.PI2,c),b.Value.push(a);else{d.Clear(this.normals);for(a=0;a<h-1;++a)this.normals.push(d.Clipper.GetUnitNormal(this.pts[this.m_i][a],this.pts[this.m_i][a+1]));this.normals.push(d.Clipper.GetUnitNormal(this.pts[this.m_i][h-1],this.pts[this.m_i][0]));this.currentPoly=new d.Polygon;this.m_k=h-1;for(this.m_j=0;this.m_j<h;++this.m_j){switch(e){case d.JoinType.jtMiter:this.m_R=1+(this.normals[this.m_j].x*this.normals[this.m_k].x+this.normals[this.m_j].y*
this.normals[this.m_k].y);this.m_R>=f?this.DoMiter():this.DoSquare(g);break;case d.JoinType.jtRound:this.DoRound();break;case d.JoinType.jtSquare:this.DoSquare(1)}this.m_k=this.m_j}b.Value.push(this.currentPoly)}e=new d.Clipper;e.AddPolygons(b.Value,d.PolyType.ptSubject);if(0<c)e.Execute(d.ClipType.ctUnion,b.Value,d.PolyFillType.pftPositive,d.PolyFillType.pftPositive);else if(c=e.GetBounds(),g=new d.Polygon,g.push(new d.IntPoint(c.left-10,c.bottom+10)),g.push(new d.IntPoint(c.right+10,c.bottom+10)),
g.push(new d.IntPoint(c.right+10,c.top-10)),g.push(new d.IntPoint(c.left-10,c.top-10)),e.AddPolygon(g,d.PolyType.ptSubject),e.Execute(d.ClipType.ctUnion,b.Value,d.PolyFillType.pftNegative,d.PolyFillType.pftNegative),0<b.Value.length)for(b.Value.splice(0,1),f=0;f<b.Value.length;f++)b.Value[f].reverse()}};d.Clipper.PolyOffsetBuilder.prototype.UpdateBotPt=function(a){return a.y>this.botPt.y||a.y==this.botPt.y&&a.x<this.botPt.x?(this.botPt=a,!0):!1};d.Clipper.PolyOffsetBuilder.prototype.AddPoint=function(a){this.currentPoly.push(a)};
d.Clipper.PolyOffsetBuilder.prototype.DoSquare=function(a){var b=new d.IntPoint(d.Cast_Int64(d.Clipper.Round(this.pts[this.m_i][this.m_j].x+this.normals[this.m_k].x*this.delta)),d.Cast_Int64(d.Clipper.Round(this.pts[this.m_i][this.m_j].y+this.normals[this.m_k].y*this.delta))),c=new d.IntPoint(d.Cast_Int64(d.Clipper.Round(this.pts[this.m_i][this.m_j].x+this.normals[this.m_j].x*this.delta)),d.Cast_Int64(d.Clipper.Round(this.pts[this.m_i][this.m_j].y+this.normals[this.m_j].y*this.delta)));if(0<=(this.normals[this.m_k].x*
this.normals[this.m_j].y-this.normals[this.m_j].x*this.normals[this.m_k].y)*this.delta){var e=Math.atan2(this.normals[this.m_k].y,this.normals[this.m_k].x),g=Math.atan2(-this.normals[this.m_j].y,-this.normals[this.m_j].x),e=Math.abs(g-e);e>d.PI&&(e=d.PI2-e);a=Math.tan((d.PI-e)/4)*Math.abs(this.delta*a);b=new d.IntPoint(d.Cast_Int64(b.x-this.normals[this.m_k].y*a),d.Cast_Int64(b.y+this.normals[this.m_k].x*a));this.AddPoint(b);c=new d.IntPoint(d.Cast_Int64(c.x+this.normals[this.m_j].y*a),d.Cast_Int64(c.y-
this.normals[this.m_j].x*a))}else this.AddPoint(b),this.AddPoint(this.pts[this.m_i][this.m_j]);this.AddPoint(c)};d.Clipper.PolyOffsetBuilder.prototype.DoMiter=function(){if(0<=(this.normals[this.m_k].x*this.normals[this.m_j].y-this.normals[this.m_j].x*this.normals[this.m_k].y)*this.delta){var a=this.delta/this.m_R;this.AddPoint(new d.IntPoint(d.Cast_Int64(d.Clipper.Round(this.pts[this.m_i][this.m_j].x+(this.normals[this.m_k].x+this.normals[this.m_j].x)*a)),d.Cast_Int64(d.Clipper.Round(this.pts[this.m_i][this.m_j].y+
(this.normals[this.m_k].y+this.normals[this.m_j].y)*a))))}else{var a=new d.IntPoint(d.Cast_Int64(d.Clipper.Round(this.pts[this.m_i][this.m_j].x+this.normals[this.m_k].x*this.delta)),d.Cast_Int64(d.Clipper.Round(this.pts[this.m_i][this.m_j].y+this.normals[this.m_k].y*this.delta))),b=new d.IntPoint(d.Cast_Int64(d.Clipper.Round(this.pts[this.m_i][this.m_j].x+this.normals[this.m_j].x*this.delta)),d.Cast_Int64(d.Clipper.Round(this.pts[this.m_i][this.m_j].y+this.normals[this.m_j].y*this.delta)));this.AddPoint(a);
this.AddPoint(this.pts[this.m_i][this.m_j]);this.AddPoint(b)}};d.Clipper.PolyOffsetBuilder.prototype.DoRound=function(){var a=new d.IntPoint(d.Clipper.Round(this.pts[this.m_i][this.m_j].x+this.normals[this.m_k].x*this.delta),d.Clipper.Round(this.pts[this.m_i][this.m_j].y+this.normals[this.m_k].y*this.delta)),b=new d.IntPoint(d.Clipper.Round(this.pts[this.m_i][this.m_j].x+this.normals[this.m_j].x*this.delta),d.Clipper.Round(this.pts[this.m_i][this.m_j].y+this.normals[this.m_j].y*this.delta));this.AddPoint(a);
if(0<=(this.normals[this.m_k].x*this.normals[this.m_j].y-this.normals[this.m_j].x*this.normals[this.m_k].y)*this.delta){if(0.985>this.normals[this.m_j].x*this.normals[this.m_k].x+this.normals[this.m_j].y*this.normals[this.m_k].y){var a=Math.atan2(this.normals[this.m_k].y,this.normals[this.m_k].x),c=Math.atan2(this.normals[this.m_j].y,this.normals[this.m_j].x);0<this.delta&&c<a?c+=d.PI2:0>this.delta&&c>a&&(c-=d.PI2);a=d.Clipper.BuildArc(this.pts[this.m_i][this.m_j],a,c,this.delta);for(c=0;c<a.length;c++)this.AddPoint(a[c])}}else this.AddPoint(this.pts[this.m_i][this.m_j]);
this.AddPoint(b)};d.Error=function(a){try{throw Error(a);}catch(b){alert(b.message)}};d.Clone=function(a){if(!(a instanceof Array)||0==a.length)return[];if(1==a.length&&0==a[0].length)return[[]];var b=a[0]instanceof Array;b||(a=[a]);var c=a.length,d,g,f,h,k=[];for(g=0;g<c;g++){d=a[g].length;h=[];for(f=0;f<d;f++)h.push({x:a[g][f].x,y:a[g][f].y});k.push(h)}b||(k=k[0]);return k};d.Clean=function(a,b){if(!(a instanceof Array))return[];var c=a[0]instanceof Array;a=d.Clone(a);if("number"!=typeof b||null===
b)return d.Error("Delta is not a number in Clean()."),a;if(0==a.length||1==a.length&&0==a[0].length||0>b)return a;c||(a=[a]);for(var e=a.length,g,f,h,k,p,m,r,n=[],q=0;q<e;q++)if(f=a[q],g=f.length,0!=g)if(3>g)h=f,n.push(h);else{h=f;k=b*b;p=f[0];for(r=m=1;r<g;r++)(f[r].x-p.x)*(f[r].x-p.x)+(f[r].y-p.y)*(f[r].y-p.y)<=k||(h[m]=f[r],p=f[r],m++);p=f[m-1];(f[0].x-p.x)*(f[0].x-p.x)+(f[0].y-p.y)*(f[0].y-p.y)<=k&&m--;m<g&&h.splice(m,g-m);h.length&&n.push(h)}!c&&n.length?n=n[0]:c||0!=n.length?c&&0==n.length&&
(n=[[]]):n=[];return n};d.Lighten=function(a,b){if(!(a instanceof Array))return[];if("number"!=typeof b||null===b)return d.Error("Tolerance is not a number in Lighten()."),d.Clone(a);if(0===a.length||1==a.length&&0===a[0].length||0>b)return d.Clone(a);a[0]instanceof Array||(a=[a]);var c,e,g,f,h,k,p,m,n,q,s,t,u,x=a.length,v=[];for(c=0;c<x;c++){g=a[c];for(f=0;1E6>f;f++){h=[];k=g.length;g[k-1].x!=g[0].x||g[k-1].y!=g[0].y?(t=1,g.push({x:g[0].x,y:g[0].y}),k=g.length):t=0;s=[];for(e=0;e<k-2;e++){p=g[e];
n=g[e+1];m=g[e+2];u=m.x-p.x;m=m.y-p.y;q=0;if(0!==u||0!==m)q=Math.sqrt(u*u+m*m),q=Math.abs((n.x-p.x)*m-(n.y-p.y)*u)/q;q<=b&&(s[e+1]=1,e++)}h.push({x:g[0].x,y:g[0].y});for(e=1;e<k-1;e++)s[e]||h.push({x:g[e].x,y:g[e].y});h.push({x:g[k-1].x,y:g[k-1].y});t&&g.pop();if(s.length)g=h;else break}k=h.length;h[k-1].x==h[0].x&&h[k-1].y==h[0].y&&h.pop();2<h.length&&v.push(h)}!a[0]instanceof Array&&(v=v[0]);"undefined"==typeof v&&(v=[[]]);return v};"undefined"!==typeof document?window.ClipperLib=d:self.ClipperLib=
d})();/*
 * Poly2Tri Copyright (c) 2009-2013, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of Poly2Tri nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* jshint browser:false, forin:true, noarg:true, noempty:true, eqeqeq:true, bitwise:true, 
   strict:true, undef:true, unused:true, curly:true, immed:true, latedef:true, 
   newcap:true, trailing:true, maxcomplexity:11, indent:4 
 */


/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionnaly follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */


/**
 * Module encapsulation
 * @param {Object} global a reference to the global object :
 *                      window in the browser, global on the server
 */
(function(global) {
    "use strict";

// --------------------------------------------------------------poly2tri module

    // Save the previous value of the poly2tri variable, 
    // so that it can be restored later on, if noConflict is used.
    var previousPoly2tri = global.poly2tri;

    // The top-level namespace. All public poly2tri classes and functions will
    // be attached to it. Exported for both the browser and the server (Node.js).
    var poly2tri;
    /* global exports */
    if (typeof exports !== 'undefined') {
        poly2tri = exports;
    } else {
        poly2tri = global.poly2tri = {};
    }

    // Runs the library in noConflict mode, returning the poly2tri variable 
    // to its previous owner. Returns a reference to this library object.
    poly2tri.noConflict = function() {
        global.poly2tri = previousPoly2tri;
        return this;
    };

// -------------------------------------------------------------------PointError

    /**
     * Custom exception class to indicate invalid Point values
     * @param {String} message          error message
     * @param {array<Point>} points     invalid points
     */
    // Class added in the JavaScript version (was not present in the c++ version)
    var PointError = function (message, points) {
        this.name    = "PointError";
        this.points  = points = points || [];
        this.message = message || "Invalid Points!";
        for (var i = 0; i < points.length; i++) {
            this.message += " " + Point.toString(points[i]);
        }
    };
    PointError.prototype = new Error();
    PointError.prototype.constructor = PointError;


// ------------------------------------------------------------------------Point
    /**
     * Construct a point
     * @param {Number} x    coordinate (0 if undefined)
     * @param {Number} y    coordinate (0 if undefined)
     */
    var Point = function(x, y) {
        this.x = +x || 0;
        this.y = +y || 0;

        // All extra fields added to Point are prefixed with _p2t_
        // to avoid collisions if custom Point class is used.

        // The edges this point constitutes an upper ending point
        this._p2t_edge_list = null;
    };

    /**
     * For pretty printing ex. <i>"(5;42)"</i>)
     */
    Point.prototype.toString = function() {
        return ("(" + this.x + ";" + this.y + ")");
    };

    /**
     * Creates a copy of this Point object.
     * @returns Point
     */
    Point.prototype.clone = function() {
        return new Point(this.x, this.y);
    };

    /**
     * Set this Point instance to the origo. <code>(0; 0)</code>
     */
    Point.prototype.set_zero = function() {
        this.x = 0.0;
        this.y = 0.0;
        return this; // for chaining
    };

    /**
     * Set the coordinates of this instance.
     * @param   x   number.
     * @param   y   number;
     */
    Point.prototype.set = function(x, y) {
        this.x = +x || 0;
        this.y = +y || 0;
        return this; // for chaining
    };

    /**
     * Negate this Point instance. (component-wise)
     */
    Point.prototype.negate = function() {
        this.x = -this.x;
        this.y = -this.y;
        return this; // for chaining
    };

    /**
     * Add another Point object to this instance. (component-wise)
     * @param   n   Point object.
     */
    Point.prototype.add = function(n) {
        this.x += n.x;
        this.y += n.y;
        return this; // for chaining
    };

    /**
     * Subtract this Point instance with another point given. (component-wise)
     * @param   n   Point object.
     */
    Point.prototype.sub = function(n) {
        this.x -= n.x;
        this.y -= n.y;
        return this; // for chaining
    };

    /**
     * Multiply this Point instance by a scalar. (component-wise)
     * @param   s   scalar.
     */
    Point.prototype.mul = function(s) {
        this.x *= s;
        this.y *= s;
        return this; // for chaining
    };

    /**
     * Return the distance of this Point instance from the origo.
     */
    Point.prototype.length = function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    };

    /**
     * Normalize this Point instance (as a vector).
     * @return The original distance of this instance from the origo.
     */
    Point.prototype.normalize = function() {
        var len = this.length();
        this.x /= len;
        this.y /= len;
        return len;
    };

    /**
     * Test this Point object with another for equality.
     * @param   p   any "Point like" object with {x,y} (duck typing)
     * @return <code>True</code> if <code>this == p</code>, <code>false</code> otherwise.
     */
    Point.prototype.equals = function(p) {
        return this.x === p.x && this.y === p.y;
    };

// -----------------------------------------------------Point ("static" methods)

    /**
     * Negate a point component-wise and return the result as a new Point object.
     * @param   p   Point object.
     * @return the resulting Point object.
     */
    Point.negate = function(p) {
        return new Point(-p.x, -p.y);
    };

    /**
     * Add two points component-wise and return the result as a new Point object.
     * @param   a   Point object.
     * @param   b   Point object.
     * @return the resulting Point object.
     */
    Point.add = function(a, b) {
        return new Point(a.x + b.x, a.y + b.y);
    };

    /**
     * Subtract two points component-wise and return the result as a new Point object.
     * @param   a   Point object.
     * @param   b   Point object.
     * @return the resulting Point object.
     */
    Point.sub = function(a, b) {
        return new Point(a.x - b.x, a.y - b.y);
    };

    /**
     * Multiply a point by a scalar and return the result as a new Point object.
     * @param   s   the scalar (a number).
     * @param   p   Point object.
     * @return the resulting Point object.
     */
    Point.mul = function(s, p) {
        return new Point(s * p.x, s * p.y);
    };

    /**
     * Perform the cross product on either two points (this produces a scalar)
     * or a point and a scalar (this produces a point).
     * This function requires two parameters, either may be a Point object or a
     * number.
     * @param   a   Point object or scalar.
     * @param   b   Point object or scalar.
     * @return  a   Point object or a number, depending on the parameters.
     */
    Point.cross = function(a, b) {
        if (typeof(a) === 'number') {
            if (typeof(b) === 'number') {
                return a * b;
            } else {
                return new Point(-a * b.y, a * b.x);
            }
        } else {
            if (typeof(b) === 'number') {
                return new Point(b * a.y, -b * a.x);
            } else {
                return a.x * b.y - a.y * b.x;
            }
        }
    };


// -----------------------------------------------------------------"Point-Like"
    /*
     * The following functions operate on "Point" or any "Point like" object 
     * with {x,y} (duck typing).
     */


    /**
     * Point pretty printing ex. <i>"(5;42)"</i>)
     * @param   p   any "Point like" object with {x,y} 
     * @returns {String}
     */
    Point.toString = function(p) {
        // Try a custom toString first, and fallback to Point.prototype.toString if none
        var s = p.toString();
        return (s === '[object Object]' ? Point.prototype.toString.call(p) : s);
    };

    /**
     * Compare two points component-wise.
     * @param   a,b   any "Point like" objects with {x,y} 
     * @return <code>&lt; 0</code> if <code>a &lt; b</code>, 
     *         <code>&gt; 0</code> if <code>a &gt; b</code>, 
     *         <code>0</code> otherwise.
     */
    Point.compare = function(a, b) {
        if (a.y === b.y) {
            return a.x - b.x;
        } else {
            return a.y - b.y;
        }
    };
    Point.cmp = Point.compare; // backward compatibility

    /**
     * Test two Point objects for equality.
     * @param   a,b   any "Point like" objects with {x,y} 
     * @return <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.
     */
    Point.equals = function(a, b) {
        return a.x === b.x && a.y === b.y;
    };

    /**
     * Peform the dot product on two vectors.
     * @param   a,b   any "Point like" objects with {x,y} 
     * @return The dot product (as a number).
     */
    Point.dot = function(a, b) {
        return a.x * b.x + a.y * b.y;
    };


// -------------------------------------------------------------------------Edge
    /**
     * Represents a simple polygon's edge
     * @param {Point} p1
     * @param {Point} p2
     */
    var Edge = function(p1, p2) {
        this.p = p1;
        this.q = p2;

        if (p1.y > p2.y) {
            this.q = p1;
            this.p = p2;
        } else if (p1.y === p2.y) {
            if (p1.x > p2.x) {
                this.q = p1;
                this.p = p2;
            } else if (p1.x === p2.x) {
                throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);
            }
        }

        if (! this.q._p2t_edge_list) {
            this.q._p2t_edge_list = [];
        }
        this.q._p2t_edge_list.push(this);
    };

// ---------------------------------------------------------------------Triangle
    /**
     * Triangle class.<br>
     * Triangle-based data structures are known to have better performance than
     * quad-edge structures.
     * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
     * Delaunay Triangulator", "Triangulations in CGAL"
     * 
     * @param   a,b,c   any "Point like" objects with {x,y} (duck typing)
     */
    var Triangle = function(a, b, c) {
        // Triangle points
        this.points_ = [a, b, c];
        // Neighbor list
        this.neighbors_ = [null, null, null];
        // Has this triangle been marked as an interior triangle?
        this.interior_ = false;
        // Flags to determine if an edge is a Constrained edge
        this.constrained_edge = [false, false, false];
        // Flags to determine if an edge is a Delauney edge
        this.delaunay_edge = [false, false, false];
    };

    /**
     * For pretty printing ex. <i>"[(5;42)(10;20)(21;30)]"</i>)
     */
    Triangle.prototype.toString = function() {
        var p2s = Point.toString;
        return ("[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]");
    };

    Triangle.prototype.getPoint = function(index) {
        return this.points_[index];
    };
    // for backward compatibility
    Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

    Triangle.prototype.getNeighbor = function(index) {
        return this.neighbors_[index];
    };

    /**
     * Test if this Triangle contains the Point object given as parameters as its
     * vertices. Only point references are compared, not values.
     * @return <code>True</code> if the Point object is of the Triangle's vertices,
     *         <code>false</code> otherwise.
     */
    Triangle.prototype.containsPoint = function(point) {
        var points = this.points_;
        // Here we are comparing point references, not values
        return (point === points[0] || point === points[1] || point === points[2]);
    };

    /**
     * Test if this Triangle contains the Edge object given as parameter as its
     * bounding edges. Only point references are compared, not values.
     * @return <code>True</code> if the Edge object is of the Triangle's bounding
     *         edges, <code>false</code> otherwise.
     */
    Triangle.prototype.containsEdge = function(edge) {
        return this.containsPoint(edge.p) && this.containsPoint(edge.q);
    };
    Triangle.prototype.containsPoints = function(p1, p2) {
        return this.containsPoint(p1) && this.containsPoint(p2);
    };


    Triangle.prototype.isInterior = function() {
        return this.interior_;
    };
    Triangle.prototype.setInterior = function(interior) {
        this.interior_ = interior;
        return this;
    };

    /**
     * Update neighbor pointers.
     * @param {Point} p1 Point object.
     * @param {Point} p2 Point object.
     * @param {Triangle} t Triangle object.
     */
    Triangle.prototype.markNeighborPointers = function(p1, p2, t) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {
            this.neighbors_[0] = t;
        } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {
            this.neighbors_[1] = t;
        } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {
            this.neighbors_[2] = t;
        } else {
            throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');
        }
    };

    /**
     * Exhaustive search to update neighbor pointers
     * @param {Triangle} t
     */
    Triangle.prototype.markNeighbor = function(t) {
        var points = this.points_;
        if (t.containsPoints(points[1], points[2])) {
            this.neighbors_[0] = t;
            t.markNeighborPointers(points[1], points[2], this);
        } else if (t.containsPoints(points[0], points[2])) {
            this.neighbors_[1] = t;
            t.markNeighborPointers(points[0], points[2], this);
        } else if (t.containsPoints(points[0], points[1])) {
            this.neighbors_[2] = t;
            t.markNeighborPointers(points[0], points[1], this);
        }
    };


    Triangle.prototype.clearNeigbors = function() {
        this.neighbors_[0] = null;
        this.neighbors_[1] = null;
        this.neighbors_[2] = null;
    };

    Triangle.prototype.clearDelunayEdges = function() {
        this.delaunay_edge[0] = false;
        this.delaunay_edge[1] = false;
        this.delaunay_edge[2] = false;
    };

    /**
     * Returns the point clockwise to the given point.
     */
    Triangle.prototype.pointCW = function(p) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p === points[0]) {
            return points[2];
        } else if (p === points[1]) {
            return points[0];
        } else if (p === points[2]) {
            return points[1];
        } else {
            return null;
        }
    };

    /**
     * Returns the point counter-clockwise to the given point.
     */
    Triangle.prototype.pointCCW = function(p) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p === points[0]) {
            return points[1];
        } else if (p === points[1]) {
            return points[2];
        } else if (p === points[2]) {
            return points[0];
        } else {
            return null;
        }
    };

    /**
     * Returns the neighbor clockwise to given point.
     */
    Triangle.prototype.neighborCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.neighbors_[1];
        } else if (p === this.points_[1]) {
            return this.neighbors_[2];
        } else {
            return this.neighbors_[0];
        }
    };

    /**
     * Returns the neighbor counter-clockwise to given point.
     */
    Triangle.prototype.neighborCCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.neighbors_[2];
        } else if (p === this.points_[1]) {
            return this.neighbors_[0];
        } else {
            return this.neighbors_[1];
        }
    };

    Triangle.prototype.getConstrainedEdgeCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.constrained_edge[1];
        } else if (p === this.points_[1]) {
            return this.constrained_edge[2];
        } else {
            return this.constrained_edge[0];
        }
    };

    Triangle.prototype.getConstrainedEdgeCCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.constrained_edge[2];
        } else if (p === this.points_[1]) {
            return this.constrained_edge[0];
        } else {
            return this.constrained_edge[1];
        }
    };

    Triangle.prototype.setConstrainedEdgeCW = function(p, ce) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.constrained_edge[1] = ce;
        } else if (p === this.points_[1]) {
            this.constrained_edge[2] = ce;
        } else {
            this.constrained_edge[0] = ce;
        }
    };

    Triangle.prototype.setConstrainedEdgeCCW = function(p, ce) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.constrained_edge[2] = ce;
        } else if (p === this.points_[1]) {
            this.constrained_edge[0] = ce;
        } else {
            this.constrained_edge[1] = ce;
        }
    };

    Triangle.prototype.getDelaunayEdgeCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.delaunay_edge[1];
        } else if (p === this.points_[1]) {
            return this.delaunay_edge[2];
        } else {
            return this.delaunay_edge[0];
        }
    };

    Triangle.prototype.getDelaunayEdgeCCW = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.delaunay_edge[2];
        } else if (p === this.points_[1]) {
            return this.delaunay_edge[0];
        } else {
            return this.delaunay_edge[1];
        }
    };

    Triangle.prototype.setDelaunayEdgeCW = function(p, e) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.delaunay_edge[1] = e;
        } else if (p === this.points_[1]) {
            this.delaunay_edge[2] = e;
        } else {
            this.delaunay_edge[0] = e;
        }
    };

    Triangle.prototype.setDelaunayEdgeCCW = function(p, e) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.delaunay_edge[2] = e;
        } else if (p === this.points_[1]) {
            this.delaunay_edge[0] = e;
        } else {
            this.delaunay_edge[1] = e;
        }
    };

    /**
     * The neighbor across to given point.
     */
    Triangle.prototype.neighborAcross = function(p) {
        // Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.neighbors_[0];
        } else if (p === this.points_[1]) {
            return this.neighbors_[1];
        } else {
            return this.neighbors_[2];
        }
    };

    Triangle.prototype.oppositePoint = function(t, p) {
        var cw = t.pointCW(p);
        return this.pointCW(cw);
    };

    /**
     * Legalize triangle by rotating clockwise around oPoint
     * @param {Point} opoint
     * @param {Point} npoint
     */
    Triangle.prototype.legalize = function(opoint, npoint) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (opoint === points[0]) {
            points[1] = points[0];
            points[0] = points[2];
            points[2] = npoint;
        } else if (opoint === points[1]) {
            points[2] = points[1];
            points[1] = points[0];
            points[0] = npoint;
        } else if (opoint === points[2]) {
            points[0] = points[2];
            points[2] = points[1];
            points[1] = npoint;
        } else {
            throw new Error('poly2tri Invalid Triangle.legalize() call');
        }
    };

    /**
     * Returns the index of a point in the triangle. 
     * The point *must* be a reference to one of the triangle's vertices.
     * @param {Point} p Point object
     * @returns {Number} index 0, 1 or 2
     */
    Triangle.prototype.index = function(p) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p === points[0]) {
            return 0;
        } else if (p === points[1]) {
            return 1;
        } else if (p === points[2]) {
            return 2;
        } else {
            throw new Error('poly2tri Invalid Triangle.index() call');
        }
    };

    Triangle.prototype.edgeIndex = function(p1, p2) {
        var points = this.points_;
        // Here we are comparing point references, not values
        if (p1 === points[0]) {
            if (p2 === points[1]) {
                return 2;
            } else if (p2 === points[2]) {
                return 1;
            }
        } else if (p1 === points[1]) {
            if (p2 === points[2]) {
                return 0;
            } else if (p2 === points[0]) {
                return 2;
            }
        } else if (p1 === points[2]) {
            if (p2 === points[0]) {
                return 1;
            } else if (p2 === points[1]) {
                return 0;
            }
        }
        return -1;
    };

    /**
     * Mark an edge of this triangle as constrained.<br>
     * This method takes either 1 parameter (an edge index or an Edge instance) or
     * 2 parameters (two Point instances defining the edge of the triangle).
     */
    Triangle.prototype.markConstrainedEdgeByIndex = function(index) {
        this.constrained_edge[index] = true;
    };
    Triangle.prototype.markConstrainedEdgeByEdge = function(edge) {
        this.markConstrainedEdgeByPoints(edge.p, edge.q);
    };
    Triangle.prototype.markConstrainedEdgeByPoints = function(p, q) {
        var points = this.points_;
        // Here we are comparing point references, not values        
        if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {
            this.constrained_edge[2] = true;
        } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {
            this.constrained_edge[1] = true;
        } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {
            this.constrained_edge[0] = true;
        }
    };

// ------------------------------------------------------------------------utils
    var PI_3div4 = 3 * Math.PI / 4;
    var PI_2 = Math.PI / 2;
    var EPSILON = 1e-12;

    /* 
     * Inital triangle factor, seed triangle will extend 30% of
     * PointSet width to both left and right.
     */
    var kAlpha = 0.3;

    var Orientation = {
        "CW": 1,
        "CCW": -1,
        "COLLINEAR": 0
    };

    /**
     * Forumla to calculate signed area<br>
     * Positive if CCW<br>
     * Negative if CW<br>
     * 0 if collinear<br>
     * <pre>
     * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
     *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
     * </pre>
     */
    function orient2d(pa, pb, pc) {
        var detleft = (pa.x - pc.x) * (pb.y - pc.y);
        var detright = (pa.y - pc.y) * (pb.x - pc.x);
        var val = detleft - detright;
        if (val > -(EPSILON) && val < (EPSILON)) {
            return Orientation.COLLINEAR;
        } else if (val > 0) {
            return Orientation.CCW;
        } else {
            return Orientation.CW;
        }
    }

    function inScanArea(pa, pb, pc, pd) {
        var pdx = pd.x;
        var pdy = pd.y;
        var adx = pa.x - pdx;
        var ady = pa.y - pdy;
        var bdx = pb.x - pdx;
        var bdy = pb.y - pdy;

        var adxbdy = adx * bdy;
        var bdxady = bdx * ady;
        var oabd = adxbdy - bdxady;

        if (oabd <= (EPSILON)) {
            return false;
        }

        var cdx = pc.x - pdx;
        var cdy = pc.y - pdy;

        var cdxady = cdx * ady;
        var adxcdy = adx * cdy;
        var ocad = cdxady - adxcdy;

        if (ocad <= (EPSILON)) {
            return false;
        }

        return true;
    }

// ---------------------------------------------------------------AdvancingFront
    /**
     * Advancing front node
     * @param {Point} p any "Point like" object with {x,y} (duck typing)
     * @param {Triangle} t triangle (optionnal)
     */
    var Node = function(p, t) {
        this.point = p;
        this.triangle = t || null;

        this.next = null; // Node
        this.prev = null; // Node

        this.value = p.x;
    };

    var AdvancingFront = function(head, tail) {
        this.head_ = head; // Node
        this.tail_ = tail; // Node
        this.search_node_ = head; // Node
    };

    AdvancingFront.prototype.head = function() {
        return this.head_;
    };

    AdvancingFront.prototype.setHead = function(node) {
        this.head_ = node;
    };

    AdvancingFront.prototype.tail = function() {
        return this.tail_;
    };

    AdvancingFront.prototype.setTail = function(node) {
        this.tail_ = node;
    };

    AdvancingFront.prototype.search = function() {
        return this.search_node_;
    };

    AdvancingFront.prototype.setSearch = function(node) {
        this.search_node_ = node;
    };

    AdvancingFront.prototype.findSearchNode = function(/*x*/) {
        // TODO: implement BST index
        return this.search_node_;
    };

    AdvancingFront.prototype.locateNode = function(x) {
        var node = this.search_node_;

        /* jshint boss:true */
        if (x < node.value) {
            while (node = node.prev) {
                if (x >= node.value) {
                    this.search_node_ = node;
                    return node;
                }
            }
        } else {
            while (node = node.next) {
                if (x < node.value) {
                    this.search_node_ = node.prev;
                    return node.prev;
                }
            }
        }
        return null;
    };

    AdvancingFront.prototype.locatePoint = function(point) {
        var px = point.x;
        var node = this.findSearchNode(px);
        var nx = node.point.x;

        if (px === nx) {
            // Here we are comparing point references, not values
            if (point !== node.point) {
                // We might have two nodes with same x value for a short time
                if (point === node.prev.point) {
                    node = node.prev;
                } else if (point === node.next.point) {
                    node = node.next;
                } else {
                    throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');
                }
            }
        } else if (px < nx) {
            /* jshint boss:true */
            while (node = node.prev) {
                if (point === node.point) {
                    break;
                }
            }
        } else {
            while (node = node.next) {
                if (point === node.point) {
                    break;
                }
            }
        }

        if (node) {
            this.search_node_ = node;
        }
        return node;
    };

// ------------------------------------------------------------------------Basin
    var Basin = function() {
        this.left_node = null; // Node
        this.bottom_node = null; // Node
        this.right_node = null; // Node
        this.width = 0.0; // number
        this.left_highest = false;
    };

    Basin.prototype.clear = function() {
        this.left_node = null;
        this.bottom_node = null;
        this.right_node = null;
        this.width = 0.0;
        this.left_highest = false;
    };

// --------------------------------------------------------------------EdgeEvent
    var EdgeEvent = function() {
        this.constrained_edge = null; // Edge
        this.right = false;
    };

// ----------------------------------------------------SweepContext (public API)
    /**
     * Constructor for the triangulation context.
     * It accepts a simple polyline, which defines the constrained edges.
     * Possible options are:
     *    cloneArrays:  if true, do a shallow copy of the Array parameters 
     *                  (contour, holes). Points inside arrays are never copied.
     *                  Default is false : keep a reference to the array arguments,
     *                  who will be modified in place.
     * @param {Array} contour  array of "Point like" objects with {x,y} (duck typing)
     * @param {Object} options  constructor options
     */
    var SweepContext = function(contour, options) {
        options = options || {};
        this.triangles_ = [];
        this.map_ = [];
        this.points_ = (options.cloneArrays ? contour.slice(0) : contour);
        this.edge_list = [];

        // Bounding box of all points. Computed at the start of the triangulation, 
        // it is stored in case it is needed by the caller.
        this.pmin_ = this.pmax_ = null;

        // Advancing front
        this.front_ = null; // AdvancingFront
        // head point used with advancing front
        this.head_ = null; // Point
        // tail point used with advancing front
        this.tail_ = null; // Point

        this.af_head_ = null; // Node
        this.af_middle_ = null; // Node
        this.af_tail_ = null; // Node

        this.basin = new Basin();
        this.edge_event = new EdgeEvent();

        this.initEdges(this.points_);
    };


    /**
     * Add a hole to the constraints
     * @param {Array} polyline  array of "Point like" objects with {x,y} (duck typing)
     */
    SweepContext.prototype.addHole = function(polyline) {
        this.initEdges(polyline);
        var i, len = polyline.length;
        for (i = 0; i < len; i++) {
            this.points_.push(polyline[i]);
        }
        return this; // for chaining
    };
    // Backward compatibility
    SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


    /**
     * Add a Steiner point to the constraints
     * @param {Point} point     any "Point like" object with {x,y} (duck typing)
     */
    SweepContext.prototype.addPoint = function(point) {
        this.points_.push(point);
        return this; // for chaining
    };
    // Backward compatibility
    SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


    /**
     * Add several Steiner points to the constraints
     * @param {array<Point>} points     array of "Point like" object with {x,y} 
     */
    // Method added in the JavaScript version (was not present in the c++ version)
    SweepContext.prototype.addPoints = function(points) {
        this.points_ = this.points_.concat(points);
        return this; // for chaining
    };


    /**
     * Triangulate the polygon with holes and Steiner points.
     */
    // Shortcut method for Sweep.triangulate(SweepContext).
    // Method added in the JavaScript version (was not present in the c++ version)
    SweepContext.prototype.triangulate = function() {
        Sweep.triangulate(this);
        return this; // for chaining
    };


    /**
     * Get the bounding box of the provided constraints (contour, holes and 
     * Steinter points). Warning : these values are not available if the triangulation 
     * has not been done yet.
     * @returns {Object} object with 'min' and 'max' Point
     */
    // Method added in the JavaScript version (was not present in the c++ version)
    SweepContext.prototype.getBoundingBox = function() {
        return {min: this.pmin_, max: this.pmax_};
    };

    /**
     * Get result of triangulation
     * @returns {array<Triangle>}   array of triangles
     */
    SweepContext.prototype.getTriangles = function() {
        return this.triangles_;
    };
    // Backward compatibility
    SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;


// ---------------------------------------------------SweepContext (private API)

    SweepContext.prototype.front = function() {
        return this.front_;
    };

    SweepContext.prototype.pointCount = function() {
        return this.points_.length;
    };

    SweepContext.prototype.head = function() {
        return this.head_;
    };

    SweepContext.prototype.setHead = function(p1) {
        this.head_ = p1;
    };

    SweepContext.prototype.tail = function() {
        return this.tail_;
    };

    SweepContext.prototype.setTail = function(p1) {
        this.tail_ = p1;
    };

    SweepContext.prototype.getMap = function() {
        return this.map_;
    };

    SweepContext.prototype.initTriangulation = function() {
        var xmax = this.points_[0].x;
        var xmin = this.points_[0].x;
        var ymax = this.points_[0].y;
        var ymin = this.points_[0].y;

        // Calculate bounds
        var i, len = this.points_.length;
        for (i = 1; i < len; i++) {
            var p = this.points_[i];
            /* jshint expr:true */
            (p.x > xmax) && (xmax = p.x);
            (p.x < xmin) && (xmin = p.x);
            (p.y > ymax) && (ymax = p.y);
            (p.y < ymin) && (ymin = p.y);
        }
        this.pmin_ = new Point(xmin, ymin);
        this.pmax_ = new Point(xmax, ymax);

        var dx = kAlpha * (xmax - xmin);
        var dy = kAlpha * (ymax - ymin);
        this.head_ = new Point(xmax + dx, ymin - dy);
        this.tail_ = new Point(xmin - dx, ymin - dy);

        // Sort points along y-axis
        this.points_.sort(Point.compare);
    };

    SweepContext.prototype.initEdges = function(polyline) {
        var i, len = polyline.length;
        for (i = 0; i < len; ++i) {
            this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
        }
    };

    SweepContext.prototype.getPoint = function(index) {
        return this.points_[index];
    };

    SweepContext.prototype.addToMap = function(triangle) {
        this.map_.push(triangle);
    };

    SweepContext.prototype.locateNode = function(point) {
        return this.front_.locateNode(point.x);
    };

    SweepContext.prototype.createAdvancingFront = function() {
        var head;
        var middle;
        var tail;
        // Initial triangle
        var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

        this.map_.push(triangle);

        head = new Node(triangle.getPoint(1), triangle);
        middle = new Node(triangle.getPoint(0), triangle);
        tail = new Node(triangle.getPoint(2));

        this.front_ = new AdvancingFront(head, tail);

        head.next = middle;
        middle.next = tail;
        middle.prev = head;
        tail.prev = middle;
    };

    SweepContext.prototype.removeNode = function(node) {
        // do nothing
        /* jshint unused:false */
    };

    SweepContext.prototype.mapTriangleToNodes = function(t) {
        for (var i = 0; i < 3; ++i) {
            if (! t.getNeighbor(i)) {
                var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
                if (n) {
                    n.triangle = t;
                }
            }
        }
    };

    SweepContext.prototype.removeFromMap = function(triangle) {
        var i, map = this.map_, len = map.length;
        for (i = 0; i < len; i++) {
            if (map[i] === triangle) {
                map.splice(i, 1);
                break;
            }
        }
    };

    /**
     * Do a depth first traversal to collect triangles
     * @param {Triangle} triangle start
     */
    SweepContext.prototype.meshClean = function(triangle) {
        // New implementation avoids recursive calls and use a loop instead.
        // Cf. issues # 57, 65 and 69.
        var triangles = [triangle], t, i;
        /* jshint boss:true */
        while (t = triangles.pop()) {
            if (!t.isInterior()) {
                t.setInterior(true);
                this.triangles_.push(t);
                for (i = 0; i < 3; i++) {
                    if (!t.constrained_edge[i]) {
                        triangles.push(t.getNeighbor(i));
                    }
                }
            }
        }
    };

// ------------------------------------------------------------------------Sweep

    /**
     * The 'Sweep' object is present in order to keep this JavaScript version 
     * as close as possible to the reference C++ version, even though almost
     * all Sweep methods could be declared as members of the SweepContext object.
     */
    var Sweep = {};


    /**
     * Triangulate the polygon with holes and Steiner points.
     * @param   tcx SweepContext object.
     */
    Sweep.triangulate = function(tcx) {
        tcx.initTriangulation();
        tcx.createAdvancingFront();
        // Sweep points; build mesh
        Sweep.sweepPoints(tcx);
        // Clean up
        Sweep.finalizationPolygon(tcx);
    };

    Sweep.sweepPoints = function(tcx) {
        var i, len = tcx.pointCount();
        for (i = 1; i < len; ++i) {
            var point = tcx.getPoint(i);
            var node = Sweep.pointEvent(tcx, point);
            var edges = point._p2t_edge_list;
            for (var j = 0; edges && j < edges.length; ++j) {
                Sweep.edgeEventByEdge(tcx, edges[j], node);
            }
        }
    };

    Sweep.finalizationPolygon = function(tcx) {
        // Get an Internal triangle to start with
        var t = tcx.front().head().next.triangle;
        var p = tcx.front().head().next.point;
        while (!t.getConstrainedEdgeCW(p)) {
            t = t.neighborCCW(p);
        }

        // Collect interior triangles constrained by edges
        tcx.meshClean(t);
    };

    /**
     * Find closes node to the left of the new point and
     * create a new triangle. If needed new holes and basins
     * will be filled to.
     */
    Sweep.pointEvent = function(tcx, point) {
        var node = tcx.locateNode(point);
        var new_node = Sweep.newFrontTriangle(tcx, point, node);

        // Only need to check +epsilon since point never have smaller
        // x value than node due to how we fetch nodes from the front
        if (point.x <= node.point.x + (EPSILON)) {
            Sweep.fill(tcx, node);
        }

        //tcx.AddNode(new_node);

        Sweep.fillAdvancingFront(tcx, new_node);
        return new_node;
    };

    Sweep.edgeEventByEdge = function(tcx, edge, node) {
        tcx.edge_event.constrained_edge = edge;
        tcx.edge_event.right = (edge.p.x > edge.q.x);

        if (Sweep.isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
            return;
        }

        // For now we will do all needed filling
        // TODO: integrate with flip process might give some better performance
        //       but for now this avoid the issue with cases that needs both flips and fills
        Sweep.fillEdgeEvent(tcx, edge, node);
        Sweep.edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
    };

    Sweep.edgeEventByPoints = function(tcx, ep, eq, triangle, point) {
        if (Sweep.isEdgeSideOfTriangle(triangle, ep, eq)) {
            return;
        }

        var p1 = triangle.pointCCW(point);
        var o1 = orient2d(eq, p1, ep);
        if (o1 === Orientation.COLLINEAR) {
            // TODO integrate here changes from C++ version
            throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);
        }

        var p2 = triangle.pointCW(point);
        var o2 = orient2d(eq, p2, ep);
        if (o2 === Orientation.COLLINEAR) {
            // TODO integrate here changes from C++ version
            throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);
        }

        if (o1 === o2) {
            // Need to decide if we are rotating CW or CCW to get to a triangle
            // that will cross edge
            if (o1 === Orientation.CW) {
                triangle = triangle.neighborCCW(point);
            } else {
                triangle = triangle.neighborCW(point);
            }
            Sweep.edgeEventByPoints(tcx, ep, eq, triangle, point);
        } else {
            // This triangle crosses constraint so lets flippin start!
            Sweep.flipEdgeEvent(tcx, ep, eq, triangle, point);
        }
    };

    Sweep.isEdgeSideOfTriangle = function(triangle, ep, eq) {
        var index = triangle.edgeIndex(ep, eq);
        if (index !== -1) {
            triangle.markConstrainedEdgeByIndex(index);
            var t = triangle.getNeighbor(index);
            if (t) {
                t.markConstrainedEdgeByPoints(ep, eq);
            }
            return true;
        }
        return false;
    };

    Sweep.newFrontTriangle = function(tcx, point, node) {
        var triangle = new Triangle(point, node.point, node.next.point);

        triangle.markNeighbor(node.triangle);
        tcx.addToMap(triangle);

        var new_node = new Node(point);
        new_node.next = node.next;
        new_node.prev = node;
        node.next.prev = new_node;
        node.next = new_node;

        if (!Sweep.legalize(tcx, triangle)) {
            tcx.mapTriangleToNodes(triangle);
        }

        return new_node;
    };

    /**
     * Adds a triangle to the advancing front to fill a hole.
     * @param tcx
     * @param node - middle node, that is the bottom of the hole
     */
    Sweep.fill = function(tcx, node) {
        var triangle = new Triangle(node.prev.point, node.point, node.next.point);

        // TODO: should copy the constrained_edge value from neighbor triangles
        //       for now constrained_edge values are copied during the legalize
        triangle.markNeighbor(node.prev.triangle);
        triangle.markNeighbor(node.triangle);

        tcx.addToMap(triangle);

        // Update the advancing front
        node.prev.next = node.next;
        node.next.prev = node.prev;


        // If it was legalized the triangle has already been mapped
        if (!Sweep.legalize(tcx, triangle)) {
            tcx.mapTriangleToNodes(triangle);
        }

        //tcx.removeNode(node);
    };

    /**
     * Fills holes in the Advancing Front
     */
    Sweep.fillAdvancingFront = function(tcx, n) {
        // Fill right holes
        var node = n.next;
        var angle;
        while (node.next) {
            angle = Sweep.holeAngle(node);
            if (angle > PI_2 || angle < -(PI_2)) {
                break;
            }
            Sweep.fill(tcx, node);
            node = node.next;
        }

        // Fill left holes
        node = n.prev;
        while (node.prev) {
            angle = Sweep.holeAngle(node);
            if (angle > PI_2 || angle < -(PI_2)) {
                break;
            }
            Sweep.fill(tcx, node);
            node = node.prev;
        }

        // Fill right basins
        if (n.next && n.next.next) {
            angle = Sweep.basinAngle(n);
            if (angle < PI_3div4) {
                Sweep.fillBasin(tcx, n);
            }
        }
    };

    Sweep.basinAngle = function(node) {
        var ax = node.point.x - node.next.next.point.x;
        var ay = node.point.y - node.next.next.point.y;
        return Math.atan2(ay, ax);
    };

    /**
     *
     * @param node - middle node
     * @return the angle between 3 front nodes
     */
    Sweep.holeAngle = function(node) {
        /* Complex plane
         * ab = cosA +i*sinA
         * ab = (ax + ay*i)(bx + by*i) = (ax*bx + ay*by) + i(ax*by-ay*bx)
         * atan2(y,x) computes the principal value of the argument function
         * applied to the complex number x+iy
         * Where x = ax*bx + ay*by
         *       y = ax*by - ay*bx
         */
        var ax = node.next.point.x - node.point.x;
        var ay = node.next.point.y - node.point.y;
        var bx = node.prev.point.x - node.point.x;
        var by = node.prev.point.y - node.point.y;
        return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
    };

    /**
     * Returns true if triangle was legalized
     */
    Sweep.legalize = function(tcx, t) {
        // To legalize a triangle we start by finding if any of the three edges
        // violate the Delaunay condition
        for (var i = 0; i < 3; ++i) {
            if (t.delaunay_edge[i]) {
                continue;
            }
            var ot = t.getNeighbor(i);
            if (ot) {
                var p = t.getPoint(i);
                var op = ot.oppositePoint(t, p);
                var oi = ot.index(op);

                // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
                // then we should not try to legalize
                if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
                    t.constrained_edge[i] = ot.constrained_edge[oi];
                    continue;
                }

                var inside = Sweep.inCircle(p, t.pointCCW(p), t.pointCW(p), op);
                if (inside) {
                    // Lets mark this shared edge as Delaunay
                    t.delaunay_edge[i] = true;
                    ot.delaunay_edge[oi] = true;

                    // Lets rotate shared edge one vertex CW to legalize it
                    Sweep.rotateTrianglePair(t, p, ot, op);

                    // We now got one valid Delaunay Edge shared by two triangles
                    // This gives us 4 new edges to check for Delaunay

                    // Make sure that triangle to node mapping is done only one time for a specific triangle
                    var not_legalized = !Sweep.legalize(tcx, t);
                    if (not_legalized) {
                        tcx.mapTriangleToNodes(t);
                    }

                    not_legalized = !Sweep.legalize(tcx, ot);
                    if (not_legalized) {
                        tcx.mapTriangleToNodes(ot);
                    }
                    // Reset the Delaunay edges, since they only are valid Delaunay edges
                    // until we add a new triangle or point.
                    // XXX: need to think about this. Can these edges be tried after we
                    //      return to previous recursive level?
                    t.delaunay_edge[i] = false;
                    ot.delaunay_edge[oi] = false;

                    // If triangle have been legalized no need to check the other edges since
                    // the recursive legalization will handles those so we can end here.
                    return true;
                }
            }
        }
        return false;
    };

    /**
     * <b>Requirement</b>:<br>
     * 1. a,b and c form a triangle.<br>
     * 2. a and d is know to be on opposite side of bc<br>
     * <pre>
     *                a
     *                +
     *               / \
     *              /   \
     *            b/     \c
     *            +-------+
     *           /    d    \
     *          /           \
     * </pre>
     * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
     *  a,b and c<br>
     *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
     *  This preknowledge gives us a way to optimize the incircle test
     * @param pa - triangle point, opposite d
     * @param pb - triangle point
     * @param pc - triangle point
     * @param pd - point opposite a
     * @return true if d is inside circle, false if on circle edge
     */
    Sweep.inCircle = function(pa, pb, pc, pd) {
        var adx = pa.x - pd.x;
        var ady = pa.y - pd.y;
        var bdx = pb.x - pd.x;
        var bdy = pb.y - pd.y;

        var adxbdy = adx * bdy;
        var bdxady = bdx * ady;
        var oabd = adxbdy - bdxady;
        if (oabd <= 0) {
            return false;
        }

        var cdx = pc.x - pd.x;
        var cdy = pc.y - pd.y;

        var cdxady = cdx * ady;
        var adxcdy = adx * cdy;
        var ocad = cdxady - adxcdy;
        if (ocad <= 0) {
            return false;
        }

        var bdxcdy = bdx * cdy;
        var cdxbdy = cdx * bdy;

        var alift = adx * adx + ady * ady;
        var blift = bdx * bdx + bdy * bdy;
        var clift = cdx * cdx + cdy * cdy;

        var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
        return det > 0;
    };

    /**
     * Rotates a triangle pair one vertex CW
     *<pre>
     *       n2                    n2
     *  P +-----+             P +-----+
     *    | t  /|               |\  t |
     *    |   / |               | \   |
     *  n1|  /  |n3           n1|  \  |n3
     *    | /   |    after CW   |   \ |
     *    |/ oT |               | oT \|
     *    +-----+ oP            +-----+
     *       n4                    n4
     * </pre>
     */
    Sweep.rotateTrianglePair = function(t, p, ot, op) {
        var n1, n2, n3, n4;
        n1 = t.neighborCCW(p);
        n2 = t.neighborCW(p);
        n3 = ot.neighborCCW(op);
        n4 = ot.neighborCW(op);

        var ce1, ce2, ce3, ce4;
        ce1 = t.getConstrainedEdgeCCW(p);
        ce2 = t.getConstrainedEdgeCW(p);
        ce3 = ot.getConstrainedEdgeCCW(op);
        ce4 = ot.getConstrainedEdgeCW(op);

        var de1, de2, de3, de4;
        de1 = t.getDelaunayEdgeCCW(p);
        de2 = t.getDelaunayEdgeCW(p);
        de3 = ot.getDelaunayEdgeCCW(op);
        de4 = ot.getDelaunayEdgeCW(op);

        t.legalize(p, op);
        ot.legalize(op, p);

        // Remap delaunay_edge
        ot.setDelaunayEdgeCCW(p, de1);
        t.setDelaunayEdgeCW(p, de2);
        t.setDelaunayEdgeCCW(op, de3);
        ot.setDelaunayEdgeCW(op, de4);

        // Remap constrained_edge
        ot.setConstrainedEdgeCCW(p, ce1);
        t.setConstrainedEdgeCW(p, ce2);
        t.setConstrainedEdgeCCW(op, ce3);
        ot.setConstrainedEdgeCW(op, ce4);

        // Remap neighbors
        // XXX: might optimize the markNeighbor by keeping track of
        //      what side should be assigned to what neighbor after the
        //      rotation. Now mark neighbor does lots of testing to find
        //      the right side.
        t.clearNeigbors();
        ot.clearNeigbors();
        if (n1) {
            ot.markNeighbor(n1);
        }
        if (n2) {
            t.markNeighbor(n2);
        }
        if (n3) {
            t.markNeighbor(n3);
        }
        if (n4) {
            ot.markNeighbor(n4);
        }
        t.markNeighbor(ot);
    };

    /**
     * Fills a basin that has formed on the Advancing Front to the right
     * of given node.<br>
     * First we decide a left,bottom and right node that forms the
     * boundaries of the basin. Then we do a reqursive fill.
     *
     * @param tcx
     * @param node - starting node, this or next node will be left node
     */
    Sweep.fillBasin = function(tcx, node) {
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
            tcx.basin.left_node = node.next.next;
        } else {
            tcx.basin.left_node = node.next;
        }

        // Find the bottom and right node
        tcx.basin.bottom_node = tcx.basin.left_node;
        while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
            tcx.basin.bottom_node = tcx.basin.bottom_node.next;
        }
        if (tcx.basin.bottom_node === tcx.basin.left_node) {
            // No valid basin
            return;
        }

        tcx.basin.right_node = tcx.basin.bottom_node;
        while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
            tcx.basin.right_node = tcx.basin.right_node.next;
        }
        if (tcx.basin.right_node === tcx.basin.bottom_node) {
            // No valid basins
            return;
        }

        tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
        tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;

        Sweep.fillBasinReq(tcx, tcx.basin.bottom_node);
    };

    /**
     * Recursive algorithm to fill a Basin with triangles
     *
     * @param tcx
     * @param node - bottom_node
     */
    Sweep.fillBasinReq = function(tcx, node) {
        // if shallow stop filling
        if (Sweep.isShallow(tcx, node)) {
            return;
        }

        Sweep.fill(tcx, node);

        var o;
        if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
            return;
        } else if (node.prev === tcx.basin.left_node) {
            o = orient2d(node.point, node.next.point, node.next.next.point);
            if (o === Orientation.CW) {
                return;
            }
            node = node.next;
        } else if (node.next === tcx.basin.right_node) {
            o = orient2d(node.point, node.prev.point, node.prev.prev.point);
            if (o === Orientation.CCW) {
                return;
            }
            node = node.prev;
        } else {
            // Continue with the neighbor node with lowest Y value
            if (node.prev.point.y < node.next.point.y) {
                node = node.prev;
            } else {
                node = node.next;
            }
        }

        Sweep.fillBasinReq(tcx, node);
    };

    Sweep.isShallow = function(tcx, node) {
        var height;
        if (tcx.basin.left_highest) {
            height = tcx.basin.left_node.point.y - node.point.y;
        } else {
            height = tcx.basin.right_node.point.y - node.point.y;
        }

        // if shallow stop filling
        if (tcx.basin.width > height) {
            return true;
        }
        return false;
    };

    Sweep.fillEdgeEvent = function(tcx, edge, node) {
        if (tcx.edge_event.right) {
            Sweep.fillRightAboveEdgeEvent(tcx, edge, node);
        } else {
            Sweep.fillLeftAboveEdgeEvent(tcx, edge, node);
        }
    };

    Sweep.fillRightAboveEdgeEvent = function(tcx, edge, node) {
        while (node.next.point.x < edge.p.x) {
            // Check if next node is below the edge
            if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
                Sweep.fillRightBelowEdgeEvent(tcx, edge, node);
            } else {
                node = node.next;
            }
        }
    };

    Sweep.fillRightBelowEdgeEvent = function(tcx, edge, node) {
        if (node.point.x < edge.p.x) {
            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                // Concave
                Sweep.fillRightConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Convex
                Sweep.fillRightConvexEdgeEvent(tcx, edge, node);
                // Retry this one
                Sweep.fillRightBelowEdgeEvent(tcx, edge, node);
            }
        }
    };

    Sweep.fillRightConcaveEdgeEvent = function(tcx, edge, node) {
        Sweep.fill(tcx, node.next);
        if (node.next.point !== edge.p) {
            // Next above or below edge?
            if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
                // Below
                if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                    // Next is concave
                    Sweep.fillRightConcaveEdgeEvent(tcx, edge, node);
                } else {
                    // Next is convex
                    /* jshint noempty:false */
                }
            }
        }
    };

    Sweep.fillRightConvexEdgeEvent = function(tcx, edge, node) {
        // Next concave or convex?
        if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
            // Concave
            Sweep.fillRightConcaveEdgeEvent(tcx, edge, node.next);
        } else {
            // Convex
            // Next above or below edge?
            if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
                // Below
                Sweep.fillRightConvexEdgeEvent(tcx, edge, node.next);
            } else {
                // Above
                /* jshint noempty:false */
            }
        }
    };

    Sweep.fillLeftAboveEdgeEvent = function(tcx, edge, node) {
        while (node.prev.point.x > edge.p.x) {
            // Check if next node is below the edge
            if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
                Sweep.fillLeftBelowEdgeEvent(tcx, edge, node);
            } else {
                node = node.prev;
            }
        }
    };

    Sweep.fillLeftBelowEdgeEvent = function(tcx, edge, node) {
        if (node.point.x > edge.p.x) {
            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                // Concave
                Sweep.fillLeftConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Convex
                Sweep.fillLeftConvexEdgeEvent(tcx, edge, node);
                // Retry this one
                Sweep.fillLeftBelowEdgeEvent(tcx, edge, node);
            }
        }
    };

    Sweep.fillLeftConvexEdgeEvent = function(tcx, edge, node) {
        // Next concave or convex?
        if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
            // Concave
            Sweep.fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
        } else {
            // Convex
            // Next above or below edge?
            if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
                // Below
                Sweep.fillLeftConvexEdgeEvent(tcx, edge, node.prev);
            } else {
                // Above
                /* jshint noempty:false */
            }
        }
    };

    Sweep.fillLeftConcaveEdgeEvent = function(tcx, edge, node) {
        Sweep.fill(tcx, node.prev);
        if (node.prev.point !== edge.p) {
            // Next above or below edge?
            if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
                // Below
                if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                    // Next is concave
                    Sweep.fillLeftConcaveEdgeEvent(tcx, edge, node);
                } else {
                    // Next is convex
                    /* jshint noempty:false */
                }
            }
        }
    };

    Sweep.flipEdgeEvent = function(tcx, ep, eq, t, p) {
        var ot = t.neighborAcross(p);
        if (!ot) {
            // If we want to integrate the fillEdgeEvent do it here
            // With current implementation we should never get here
            throw new Error('poly2tri [BUG:FIXME] FLIP failed due to missing triangle!');
        }
        var op = ot.oppositePoint(t, p);

        if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
            // Lets rotate shared edge one vertex CW
            Sweep.rotateTrianglePair(t, p, ot, op);
            tcx.mapTriangleToNodes(t);
            tcx.mapTriangleToNodes(ot);

            // XXX: in the original C++ code for the next 2 lines, we are
            // comparing point values (and not pointers). In this JavaScript
            // code, we are comparing point references (pointers). This works
            // because we can't have 2 different points with the same values.
            // But to be really equivalent, we should use "Point.equals" here.
            if (p === eq && op === ep) {
                if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
                    t.markConstrainedEdgeByPoints(ep, eq);
                    ot.markConstrainedEdgeByPoints(ep, eq);
                    Sweep.legalize(tcx, t);
                    Sweep.legalize(tcx, ot);
                } else {
                    // XXX: I think one of the triangles should be legalized here?
                    /* jshint noempty:false */
                }
            } else {
                var o = orient2d(eq, op, ep);
                t = Sweep.nextFlipTriangle(tcx, o, t, ot, p, op);
                Sweep.flipEdgeEvent(tcx, ep, eq, t, p);
            }
        } else {
            var newP = Sweep.nextFlipPoint(ep, eq, ot, op);
            Sweep.flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
            Sweep.edgeEventByPoints(tcx, ep, eq, t, p);
        }
    };

    Sweep.nextFlipTriangle = function(tcx, o, t, ot, p, op) {
        var edge_index;
        if (o === Orientation.CCW) {
            // ot is not crossing edge after flip
            edge_index = ot.edgeIndex(p, op);
            ot.delaunay_edge[edge_index] = true;
            Sweep.legalize(tcx, ot);
            ot.clearDelunayEdges();
            return t;
        }

        // t is not crossing edge after flip
        edge_index = t.edgeIndex(p, op);

        t.delaunay_edge[edge_index] = true;
        Sweep.legalize(tcx, t);
        t.clearDelunayEdges();
        return ot;
    };

    Sweep.nextFlipPoint = function(ep, eq, ot, op) {
        var o2d = orient2d(eq, op, ep);
        if (o2d === Orientation.CW) {
            // Right
            return ot.pointCCW(op);
        } else if (o2d === Orientation.CCW) {
            // Left
            return ot.pointCW(op);
        } else {
            throw new PointError("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
        }
    };

    Sweep.flipScanEdgeEvent = function(tcx, ep, eq, flip_triangle, t, p) {
        var ot = t.neighborAcross(p);
        if (!ot) {
            // If we want to integrate the fillEdgeEvent do it here
            // With current implementation we should never get here
            throw new Error('poly2tri [BUG:FIXME] FLIP failed due to missing triangle');
        }
        var op = ot.oppositePoint(t, p);

        if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
            // flip with new edge op.eq
            Sweep.flipEdgeEvent(tcx, eq, op, ot, op);
            // TODO: Actually I just figured out that it should be possible to
            //       improve this by getting the next ot and op before the the above
            //       flip and continue the flipScanEdgeEvent here
            // set new ot and op here and loop back to inScanArea test
            // also need to set a new flip_triangle first
            // Turns out at first glance that this is somewhat complicated
            // so it will have to wait.
        } else {
            var newP = Sweep.nextFlipPoint(ep, eq, ot, op);
            Sweep.flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
        }
    };

// ---------------------------------------------------------Exports (public API)

    poly2tri.PointError     = PointError;
    poly2tri.Point          = Point;
    poly2tri.Triangle       = Triangle;
    poly2tri.SweepContext   = SweepContext;

    // Backward compatibility
    poly2tri.triangulate    = Sweep.triangulate;
    poly2tri.sweep = {Triangulate: Sweep.triangulate};

}(this));


// ----------------------------------------------------Namespace.js (deprecated)

(function() { // to scope jshint directives
    "use strict";
    /* jshint newcap:false */
    /* global Namespace, js, poly2tri */

    // Tests "Namespace.js" support, for backward compatilibilty
    if (typeof Namespace === 'function') {
        // Put in the "js.poly2tri" namespace
        Namespace('js.poly2tri');
        js.poly2tri = poly2tri;
        Namespace.provide('js.poly2tri');
    }
}());

/**
 * @description
 *
 * CG is the base class of the cangaja framework.
 * This file includes a requestAnimationFrame polyfill. It uses the simple javascript inheritance from John Resig.
 @example
 //Class example, how to start from scratch with simple inheritance
 CG.Class.extend("Entity",{
        init: function(){
            this.myprop = 'set from constructor'
        }
     });

 CG.Entity.extend("Point",{
        init: function(x, y){
            this._super()
            this.x = x
            this.y = y
        }
     });

 CG.Point.extend("Rectangle",{
        init: function(x, y, w, h){
            this._super(x, y)
            this.w = w
            this.h = h
        },
        move: function(){

        }
     });
 * @module CG
 * @main CG
 */
var CG = CG || {
    VERSION: 1,

    //canvas if needed, remember director mode slide!
    canvas: {},
    ctx: {},

    //constants
    Const_PI_180: Math.PI / 180,
    Const_180_PI: 180 / Math.PI,
    LEFT: 1,
    RIGHT: 2,
    UP: 3,
    DOWN: 4,

    //input related
    mousedown: false,
    mouse: {x: 0, y: 0},
    //touch start
    start: {x: 0, y: 0},
    //touch end
    end: {x: 0, y: 0}
};


// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik M??ller
// fixes from Paul Irish and Tino Zijdel

(function () {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () {
                    callback(currTime + timeToCall);
                },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
}());


/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 *
 * Inspired by base2 and Prototype
 */
(function () {
    var initializing = false,
        fnTest = /xyz/.test(function () {
            var xyz;
        }) ? /\b_super\b/ : /.*/;
    /* The base Class implementation (does nothing) */
    CG.Class = function () {
    };

    // See if a object is a specific class
    CG.Class.prototype.isA = function (className) {
        return this.className === className;
    };

    /* Create a new Class that inherits from this class */
    CG.Class.extend = function (className, prop, classMethods) {
        /* No name, don't add onto Q */
        if (!typeof className === "string") {
            classMethods = prop;
            prop = className;
            className = null;
        }
        var _super = this.prototype,
            ThisClass = this;

        /* Instantiate a base class (but only create the instance, */
        /* don't run the init constructor) */
        initializing = true;
        var prototype = new ThisClass();
        initializing = false;

        function _superFactory(name, fn) {
            return function () {
                var tmp = this._super;

                /* Add a new ._super() method that is the same method */
                /* but on the super-class */
                this._super = _super[name];

                /* The method only need to be bound temporarily, so we */
                /* remove it when we're done executing */
                var ret = fn.apply(this, arguments);
                this._super = tmp;

                return ret;
            };
        }

        /* Copy the properties over onto the new prototype */
        for (var name in prop) {
            /* Check if we're overwriting an existing function */
            prototype[name] = typeof prop[name] === "function" &&
                typeof _super[name] === "function" &&
                fnTest.test(prop[name]) ?
                _superFactory(name, prop[name]) :
                prop[name];
        }

        /* The dummy class constructor */
        function Class() {
            /* All construction is actually done in the init method */
            if (!initializing && this.init) {
                this.init.apply(this, arguments);
            }
        }

        /* Populate our constructed prototype object */
        Class.prototype = prototype;

        /* Enforce the constructor to be what we expect */
        Class.prototype.constructor = Class;
        /* And make this class extendable */
        Class.extend = CG.Class.extend;

        /* If there are class-level Methods, add them to the class */
        if (classMethods) {
            CG._extend(Class, classMethods);
        }

        if (className) {
            /* Save the class onto Q */
            CG[className] = Class;

            /* Let the class know its name */
            Class.prototype.className = className;
            Class.className = className;
        }

        return Class;
    };
}())/**
 * Created with JetBrains WebStorm.
 * User: Apple
 * Date: 23.07.13
 * Time: 22:43
 * To change this template use File | Settings | File Templates.
 */
var Clock = function (targetfps) {

    this.targetfps = targetfps || 60

    /** Member startTime will remain fixed at its integer
     millisecond value returned by Date.now(). Will always
     be equal to the time the clock was started */
    this.startTime = Date.now();

    /** Member ms is updated by tick() to a integer value reprsenting
     the number of milliseconds between the epoch (January 1, 1970)
     and the current date and time of the system. */
    this.ms = this.startTime;
    this.last = this.startTime;  /** millis at last call to tick() */
    this.time = 0;               /** ms in floating point seconds not millis */

    /** Member dt is updated by tick() to an integer value representing
     the number of milliseconds since the last call to tick(). */
    this.dt = 0;
    this.delta = 0; /** dt in floating point seconds not millis */

    /** Member fps is updated by tick() to a floating point value representing
     frames per second, updated and averaged approximately once per second */
    this.fps = 0.0;

    /** Member frameCount is updated to an integer value representing the
     total number of calls to tick() since the clock was created. */
    this.frameCount = 0;

    /** The frameCounter member is a flag you can turn off if you don't need to
     calculate the frameCount or do the average FPS calculation every second */
    this.frameCounter = true;

    /** Private globals needed to calculcate/average fps over eachs second */
    var timeToUpdate = 0;
    var framesToUpdate = 0;

    /************************************************************************************
     The tick() method updates ALL the Clock members, which should only
     be read from and never written to manually. It is recommended that
     tick() is called from a callback loop using requestAnimationFrame

     Learn more: http://paulirish.com/2011/requestanimationframe-for-smart-animating/
     *************************************************************************************/
    this.tick = function () {
        /** This is a new frame with it's very own unique number */

        if (this.frameCounter) this.frameCount++;

        /** Set the private currentTime variable */
        this.ms = Date.now();

        /** Update time delta and immediately set last time to
         be as accurate as possible in our timings. */
        this.dt = this.ms - this.last;
        this.last = this.ms;

        /** Calculate floating-point delta and increment time member */
//        this.delta = 0.001 * this.dt;
//        this.time += this.delta;
        this.delta = this.dt / (1000 / this.targetfps);
        this.time += 0.001 * this.dt;

        /** Calculate private temp variables for fps calculation */
        if (this.frameCounter) {
            timeToUpdate += this.dt;
            framesToUpdate++;
            if (timeToUpdate > 1000) {
                this.fps = Math.round((framesToUpdate * 1000) / timeToUpdate);
                framesToUpdate = 0;
                timeToUpdate = 0;
            }
        }
    }
}/**
 * string functions
 **/

function loadString(path) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", path, false);
    xhr.send(null);
    if ((xhr.status == 200) || (xhr.status == 0)) return xhr.responseText;
    return "";
}

String.prototype.ltrim = function (clist) {
    if (clist) return this.replace(new RegExp('^[' + clist + ']+'), '')
    return this.replace(/^\s+/, '')
}
String.prototype.rtrim = function (clist) {
    if (clist) return this.replace(new RegExp('[' + clist + ']+$'), '')
    return this.replace(/\s+$/, '')
}
String.prototype.trim = function (clist) {
    if (clist) return this.ltrim(clist).rtrim(clist);
    return this.ltrim().rtrim();
}
String.prototype.startsWith = function (str) {
    return !this.indexOf(str);
}/**
 * @description
 *
 * A CanvasRenderer with WebGL and Canvas 2D fallback would be really nice ;o)
 * How to implement all the different classes....?
 *
 *
 * @class CG.CanvasRenderer
 * @extend CG.Class
 */


CG.Class.extend('CanvasRenderer', {
    /**
     * @method init
     * @constructor
     * @return {*}
     */
    init:function(canvas){

        //TODO the renderer recognizes the canvas features WebGL/Canvas

        //TODO the renderer creates the canvas element

        //TODO the renderer handles all drawings from all classes, urgh ;o)

        /*

         //sprite draw method

         draw:function () {
             this.updateDiff()

             Game.b_ctx.save()
             Game.b_ctx.globalAlpha = this.alpha
             Game.b_ctx.translate(this.position.x, this.position.y)
             if (this.atlasimage) {
                 Game.b_ctx.rotate((this.rotation - this.imagerotation) * CG.Const_PI_180)
                 Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - this.xhandle, 0 - this.yhandle, this.cutwidth * this.xscale, this.cutheight * this.yscale)
             } else {
                 Game.b_ctx.rotate(this.rotation * CG.Const_PI_180)
                 Game.b_ctx.drawImage(this.image, 0 - this.xhandle, 0 - this.yhandle, this.image.width * this.xscale, this.image.height * this.yscale)
             }
             Game.b_ctx.restore()
         },




        //animation draw method
         draw:function () {
             this.updateDiff()

             Game.b_ctx.save()
             Game.b_ctx.globalAlpha = this.alpha
             Game.b_ctx.translate(this.position.x, this.position.y)
             if (this.frames == 1) {
                 Game.b_ctx.drawImage(this.image, this.position.x, this.position.y, this.image.width * this.xscale, this.image.height * this.yscale)
             }
             else {
                 this.fx = this.currentframe * this.width

                 if ((this.fx / this.image.width) > 0) {
                 this.fx = this.fx % this.image.width
                 }
                 this.fy = Math.floor(this.width * this.currentframe / this.image.width) * this.height

                 Game.b_ctx.rotate(this.rotation * CG.Const_PI_180)
                 try {
                 Game.b_ctx.drawImage(this.image, this.fx, this.fy, this.width, this.height, 0 - this.xhandle, 0 - this.yhandle, this.width * this.xscale, this.height * this.yscale)
                 } catch (e) {

                 }
             }
             Game.b_ctx.restore()
         }



         //button draw method
         draw:function () {
             Game.b_ctx.save()
             Game.b_ctx.translate(this.position.x, this.position.y)
             if (this.atlasimage) {
                 var r = this.rotation
                 Game.b_ctx.rotate((r - this.imagerotation) * CG.Const_PI_180)
                 Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - (this.cutwidth / 2), 0 - (this.cutheight / 2), this.cutwidth * this.xscale, this.cutheight * this.yscale)
                 Game.b_ctx.rotate(this.imagerotation * CG.Const_PI_180)
             } else {
                 Game.b_ctx.rotate(r * CG.Const_PI_180)
                 Game.b_ctx.drawImage(this.image, 0 - (this.image.width * this.xscale / 2), 0 - (this.image.height * this.yscale / 2), this.image.width * this.xscale, this.image.height * this.yscale)
             }
             this.font.draw(this.text, 0 - (this.font.getTextWidth(this.text) / 2 >> 0), 0 - ((this.font.getFontSize() / 2) >> 0))
             Game.b_ctx.restore()
         }


        //particle draw method
         draw:function () {
             if (this.visible) {
                 Game.b_ctx.save()
                 Game.b_ctx.globalAlpha = this.alpha
                 Game.b_ctx.translate(this.position.x, this.position.y)
                 if (this.atlasimage) {
                     Game.b_ctx.rotate((this.rotation - this.imagerotation) * CG.Const_PI_180)
                     Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - (this.cutwidth / 2), 0 - (this.cutheight / 2), this.cutwidth * this.xscale, this.cutheight * this.yscale)
                     Game.b_ctx.rotate((this.rotation + this.imagerotation) * CG.Const_PI_180)
                 } else {
                     Game.b_ctx.rotate(this.rotation * CG.Const_PI_180)
                     Game.b_ctx.drawImage(this.image, 0 - (this.image.width * this.xscale / 2), 0 - (this.image.height * this.yscale / 2), this.image.width * this.xscale, this.image.height * this.yscale)
                 }
                 Game.b_ctx.restore()
             }
         }



         //map drawmap part orthogonal
         Game.b_ctx.save()
         Game.b_ctx.globalAlpha = this.layers[layer].opacity
         Game.b_ctx.translate(rx, ry)
         try {
            Game.b_ctx.drawImage(this.atlas, cx, cy, this.tilewidth, this.tileheight, this.sx, this.sy, this.tilewidth * this.xscale, this.tileheight * this.yscale)
         } catch (e) {
         }
         Game.b_ctx.restore()


         //map drawmap part isometric
         Game.b_ctx.save()
         Game.b_ctx.globalAlpha = this.layers[layer].opacity
         Game.b_ctx.translate(xpos, ypos)
         try {
            Game.b_ctx.drawImage(this.atlas, cx, cy, this.tilewidth, this.tileset.tileheight, 0, 0, this.tilewidth * this.xscale, this.tileset.tileheight * this.yscale)
         } catch (e) {

         }
         Game.b_ctx.restore()



        //font class part draw
         for (var i = 0, l = text.length; i < l; i++) {
             Game.b_ctx.drawImage(this.atlas, this.x[text.charCodeAt(i)], this.y[text.charCodeAt(i)], this.width[text.charCodeAt(i)], this.height[text.charCodeAt(i)], currx, curry + this.yoff[text.charCodeAt(i)], this.width[text.charCodeAt(i)], this.height[text.charCodeAt(i)])
             currx += this.xadv[text.charCodeAt(i)]
         }


         //bitmap class
         draw:function () {
             Game.b_ctx.drawImage(this.bitmap_canvas, this.x, this.y)
         },











         */
        return this
    }
})/**
 * @description
 *
 * CG.Delta not really used at the moment ;o)
 *
 * @class CG.Delta
 * @extends Class
 *
 */


CG.Class.extend('Delta', {
    /**
     * @method init
     * @constructor
     * @param fps {Number}
     */
    init: function (fps) {
        /**
         * @property targetfps
         * @type {Number}
         */
        this.targetfps = fps
        /**
         * @property currenttime
         * @type {Number}
         */
        this.currenttime = 0
        /**
         * @property lasttime
         * @type {Number}
         */
        this.lasttime = new Date().getTime()
        /**
         * @property elapsedtime
         * @type {Number}
         */
        this.elapsedtime = 0
        /**
         * @property frametime
         * @type {Number}
         */
        this.frametime = 0
        /**
         * @property delta
         * @type {Number}
         */
        this.delta = 0
        /**
         * @property fps
         * @type {Number}
         */
        this.fps = 0
    },

    update: function () {
        this.currenttime = new Date().getTime()
        var delta = (this.currenttime - this.lasttime) / 1000
        this.fps = 1 / delta
        this.lasttime = this.currenttime
    },
    getDelta: function () {
        return this.delta
    },
    getFPS: function () {
        return this.fps
    }
})


/**
 *  Â© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * CG.Entity the base class of Cangaja
 *
 * @class CG.Entity
 * @extends CG.Class
 */

CG.Class.extend('Entity', {
    /**
     * @constructor
     * @method init
     * @param name {string} the name of the Entity
     */
    init:function (name) {
        /**
         @property name {string}
         */
        this.name = name || ''
        /**
         @property visible {boolean}
         */
        this.visible = true
    },
    update:function () {
        throw {
            name:'Entity Error',
            message:'Subclass has no update method.'
        }
    },
    draw:function () {
        throw {
            name:'Entity Error',
            message:'Subclass has no draw method.'
        }
    },
    /**
     * @description initialize image for object. for now => sprite, particle, buffer, bitmap and button use it
     * @method setImage
     * @param {image} image image path, image or tpimage
     */
    setImage:function (image) {
        this.atlasimage = false
        if (image) {
            if (image instanceof CG.TPImage) {
                //TPImage from MediaAsset
                this.image = Game.asset.getImageByName(image.atlasname)
                this.imagerotation = image.rotation //|| 0
                this.xoffset = image.xoffset
                this.yoffset = image.yoffset
                this.width = image.width
                this.height = image.height
                this.atlasimage = true
                if (this.imagerotation !== 0) {
                    this.cutwidth = image.height
                    this.cutheight = image.width
                } else {
                    this.cutwidth = image.width
                    this.cutheight = image.height
                }
            } else if (typeof image == 'string' && image != '') {
                //path to image
                this.image = new Image()
                this.image.src = image
                this.width = this.image.width
                this.height = this.image.height
            } else {
                //image from MediaAsset
                this.image = image
                this.width = this.image.width
                this.height = this.image.height
            }
        }
    }
})


/**
 * @description
 *
 * CG.Point
 *
 * @class CG.Point
 * @extends CG.Entity
 */
CG.Entity.extend('Point', {
    /**
     * @constructor
     * @method init
     * @param x {Number} the x value of the point
     * @param y {Number} the y value of the point
     */
    init:function (x, y) {
        /**
         @property x {Number}
         */
        this.x = x || 0
        /**
         @property y {Number}
         */
        this.y = y || 0
    }
})


/**
 * @description
 *
 * CG.Vector
 *
 * @class CG.Vector
 * @extends CG.Point
 */
CG.Point.extend('Vector', {
    /**
     * @constructor
     * @method init
     * @param x {Number} the x position
     * @param y {Number} the y position
     * @param z {Number} the z position
     */
    init:function (x, y, z) {
        this._super(this, x, y)
        /**
         @property z {Number}
         */
        this.z = z || 0
    }
})



/**
 * @description
 *
 * CG.Rectangle for click and mouseover handling, collision detection and AABB function
 *
 * @class CG.Rectangle
 * @extends CG.Entity
 *
 */
CG.Entity.extend('Rectangle', {
    /**
     * @constructor
     * @method init
     * @param position {CG.Point} position point
     * @param width {Number} width the width of rectangle
     * @param height {Number} height the height of rectangle
     * @return {*}
     */
    init:function (position, width, height) {
        /**
         @property position {CG.Point}
         */
        this.position = position || new CG.Point(0, 0)
        /**
         @property width {Number}
         */
        this.width = width || 0
        /**
         @property height {Number}
         */
        this.height = height || 0
        /**
         @property clickable {boolean}
         */
        this.clickable = false
        /**
         @property dragable {boolean}
         */
        this.dragable = false
        /**
         @property rotation {Number}
         */
        this.rotation = 0
        /**
         @property xscale {Number}
         */
        this.xscale = 1
        /**
         @property yscale {Number}
         */
        this.yscale = 1
        /**
         @property clicked {boolean}
         */
        this.clicked = false
        /**
         @property hover {boolean}
         */
        this.hover = false

        /**
         @property boundingradius {Number}
         */
        this.boundingradius = 0     //radius for circular collision bounds
        /**
         @property mapcollision {boolean}
         */
        this.mapcollision = false

        return this
    },
    /**
     * @description returns the bounds of rotated rectangle
     * @method AABB
     * @return {object} returns the calculated bounds
     */
    AABB:function () {
        //http://willperone.net/Code/coderr.php
        a = this.rotation * CG.Const_PI_180
        s = Math.sin(a);
        c = Math.cos(a);
        if (s < 0) s = -s;
        if (c < 0) c = -c;
        return {
            bw:this.height * this.xscale * s + this.width * this.yscale * c,
            bh:this.height * this.xscale * c + this.width * this.yscale * s
        }
    },
    /**
     * @description checks click inside of the rectangle, supports rotation
     * @method ifClicked
     * @return {true/false}
     */
    ifClicked:function () {
        if (CG.mousedown && this.clickable) {
            var dx = CG.mouse.x - this.position.x,
                dy = CG.mouse.y - this.position.y
            var h1 = Math.sqrt(dx * dx + dy * dy)
            var currA = Math.atan2(dy, dx)
            var newA = currA - (this.rotation * CG.Const_PI_180);
            var x2 = Math.cos(newA) * h1
            var y2 = Math.sin(newA) * h1
            if (x2 > -0.5 * (this.width * this.xscale) &&
                x2 < 0.5 * (this.width * this.xscale) &&
                y2 > -0.5 * (this.height * this.yscale) &&
                y2 < 0.5 * (this.height * this.yscale)) {
                this.clicked = true
                CG.mousedown = false
            }
        }
        return false
    },
    /**
     * @description checks if the mouse/pointer is over the rectangle
     * @method ifMouseOver
     */
    ifMouseOver:function () {
        var dx = CG.mouse.x - this.position.x,
            dy = CG.mouse.y - this.position.y
        var h1 = Math.sqrt(dx * dx + dy * dy)
        var currA = Math.atan2(dy, dx)
        var newA = currA - (this.rotation * CG.Const_PI_180)
        var x2 = Math.cos(newA) * h1
        var y2 = Math.sin(newA) * h1
        if (x2 > -0.5 * (this.width * this.xscale) &&
            x2 < 0.5 * (this.width * this.xscale) &&
            y2 > -0.5 * (this.height * this.yscale) &&
            y2 < 0.5 * (this.height * this.yscale)) {
            this.hover = true
        } else {
            this.hover = false
        }
    },
    /**
     * @description checks if there is a collision of the given objects to this object http://devmag.org.za/2009/04/13/basic-collision-detection-in-2d-part-1/
     * @method checkCollision
     * @param objects {array} a array of objects to check for collision => Sprites, Animations, MapAreas
     * @param callback {callback} what to do after collision?
     */
    checkCollision:function (objects, callback) {
        objects.forEach(function (obj, index) {
                if (obj.className == 'MapArea') {
                    if ((this.position.y + this.AABB().bh / 2) >= obj.bound.y &&
                        this.position.y - this.AABB().bh / 2 <= (obj.bound.y + obj.bound.height) &&
                        (this.position.x + this.AABB().bw / 2) >= obj.bound.x &&
                        this.position.x - this.AABB().bw / 2 <= (obj.bound.x + obj.bound.width )) {
                        if (obj.type === 'outer') {

                            w = 0.5 * (this.width + obj.bound.width)
                            h = 0.5 * (this.height + obj.bound.height)
                            dx = this.position.x - (obj.bound.width / 2 + obj.bound.x)
                            dy = this.position.y - (obj.bound.height / 2 + obj.bound.y)

                            if (Math.abs(dx) <= w && Math.abs(dy) <= h) {
                                /* collision! */
                                wy = w * dy;
                                hx = h * dx;

                                if (wy > hx) {
                                    if (wy > -hx) {
                                        direction = 'bottom'
                                        overlap = ((this.position.y - this.AABB().bh / 2) - (obj.bound.y + obj.bound.height)) >> 0
                                    } else {
                                        direction = 'CG.LEFT'
                                        overlap = ((this.position.x + this.AABB().bw / 2) - obj.bound.x) >> 0
                                    }
                                } else {
                                    if (wy > -hx) {
                                        direction = 'right'
                                        overlap = ((this.position.x - this.AABB().bw / 2) - (obj.bound.x + obj.bound.width)) >> 0
                                    } else {
                                        direction = 'top'
                                        overlap = ((this.position.y + this.AABB().bh / 2) - obj.bound.y) >> 0
                                    }
                                }
                            }

                            collision = {
                                overlap:overlap,
                                direction:direction
                            }
                            //callback arguments: this => the sprite, obj => the maparea if needed, collision => {collison direction, offset}
                            callback(this, obj, collision)
                        }
                    }
                }
                else if (this.boundingradius > 0 && obj.boundingradius > 0) {
                    //check boundingradius for circuar collision
                    distx = this.position.x - obj.position.x
                    disty = this.position.y - obj.position.y
                    dist = Math.sqrt((distx * distx) + (disty * disty))
                    if (dist <= (this.boundingradius / 2 * this.xscale + obj.boundingradius / 2 * obj.yscale)) {
                        collision = false //dummy
                        callback(this, obj, collision)
                    }
                }
                else {
                    //if boundingradius is 0, fallback to bounding collision
                    if ((this.position.y + this.AABB().bh / 2) >= obj.position.y - obj.AABB().bh / 2 &&
                        this.position.y - this.AABB().bh / 2 <= (obj.position.y + obj.AABB().bh / 2) &&
                        (this.position.x + this.AABB().bw / 2) >= obj.position.x - obj.AABB().bw / 2 &&
                        this.position.x - this.AABB().bw / 2 <= (obj.position.x + obj.AABB().bw / 2)) {

                        w = 0.5 * (this.width + obj.width)
                        h = 0.5 * (this.height + obj.height)
                        dx = this.position.x - obj.position.x
                        dy = this.position.y - obj.position.y

                        if (Math.abs(dx) <= w && Math.abs(dy) <= h) {
                            /* collision! */
                            wy = w * dy;
                            hx = h * dx;

                            if (wy > hx) {
                                if (wy > -hx) {
                                    direction = 'bottom'
                                    overlap = ((this.position.y - this.AABB().bh / 2) - (obj.position.y - obj.AABB().bh / 2)) >> 0
                                } else {
                                    direction = 'CG.LEFT'
                                    overlap = ((this.position.x + this.AABB().bw / 2) - (obj.position.x + obj.AABB().bw / 2)) >> 0
                                }
                            } else {
                                if (wy > -hx) {
                                    direction = 'right'
                                    overlap = ((this.position.x - this.AABB().bw / 2) - (obj.position.x - obj.AABB().bw / 2)) >> 0
                                } else {
                                    direction = 'top'
                                    overlap = ((this.position.y + this.AABB().bh / 2) - (obj.position.y + obj.AABB().bh / 2)) >> 0
                                }
                            }
                        }

                        collision = {
                            overlap:overlap,
                            direction:direction
                        }

                        callback(this, obj, collision)
                    }
                }
            },
            this
        )
        return this
    }

})


/**
 * @description
 *
 * CG.Bound is used at different places in the Cangaja FW.
 *
 * @class CG.Bound
 * @extends CG.Entity
 *
 */
CG.Entity.extend('Bound', {
    /**
     * @constructor
     * @method init
     * @param x {number} x the x position
     * @param y {number} y the y position
     * @param width {number} width the width of bound
     * @param height {number} height the height of bound
     * @return {*}
     */
    init:function (x, y, width, height) {
        this._super()
        /**
         * @property x
         * @type {Number}
         */
        this.x = x
        /**
         * @property y
         * @type {Number}
         */
        this.y = y
        /**
         * @property width
         * @type {Number}
         */
        this.width = width
        /**
         * @property height
         * @type {Number}
         */
        this.height = height
        return this
    },

    /**
     * @method setName
     * @param {string} name of the bounding box
     * @return {*}
     */
    setName:function (name) {
        this.name = name
        return this
    }
})


/**
 * @description
 *
 * CG.Buffer for separate canvas rendering/buffering
 *
 * @class CG.Buffer
 * @extends CG.Entity
 *
 */
CG.Entity.extend('Buffer', {
    /**
     * @constructor
     * @method init
     * @param width {Number} width of the buffer
     * @param height {Number} height of the buffer
     * @param buffername {string} buffername
     * @return {*}
     */
    init:function (width, height, buffername) {
        this._super(buffername)
        /**
         * @property b_canvas
         * @type {HTMLElement}
         */
        this.b_canvas = document.createElement('canvas')
//    if(typeof(ejecta) !== 'undefined'){
//        this.b_canvas.width = w
//        this.b_canvas.height = h
//    }else{

        /**
         * @property b_canvas.width
         * @type {*}
         */
        this.b_canvas.width = width
        /**
         * @property b_canvas.height
         * @type {*}
         */
        this.b_canvas.height = height
//    }

        /**
         * @property b_ctx
         * @type {CanvasRenderingContext2D}
         */
        this.b_ctx = this.b_canvas.getContext('2d')
        return this
    }
})


/**
 * @description
 *
 * CG.Sprite
 *
 * @class CG.Sprite
 * @extends CG.Rectangle
 */
CG.Rectangle.extend('Sprite', {
    /**
     * @method init
     * @constructor
     * @param image {image}  imgpath, image object or tpimage object to use
     * @param position {CG.Point}  position object
     * @return {*}
     */
    init:function (image, position) {
        this._super(position, 0, 0)

        /**
         @property atlasimage {boolean}
         */
        this.atlasimage = false
        this.setImage(image)

        /**
         @property bound {CG.Bound}
         */
        this.bound = Game.bound     //global bounds of game
        /**
         @property diffpoint {CG.Point}
         */
        this.diffpoint = new CG.Point(this.bound.x, this.bound.y)  //store diffpoint if bound is moving

        /**
         @property xspeed {Number}
         */
        this.xspeed = 0 //xspeed of the sprite
        /**
         @property xscale {Number}
         */
        this.xscale = 1
        /**
         @property xhandle {Number}
         */
        this.xhandle = 0
        /**
         @property yspeed {Number}
         */
        this.yspeed = 0
        /**
         @property yscale {Number}
         */
        this.yscale = 1
        /**
         @property yhandle {Number}
         */
        this.yhandle = 0
        /**
         @property boundsMode {false/string}
         */
        this.boundsMode = false // false, bounce or slide
        /**
         @property rotation {integer/float}
         */
        this.rotation = 0
        /**
         @property rotationspeed {integer/float}
         */
        this.rotationspeed = 0
        /**
         @property alpha {float}
         */
        this.alpha = 1
        /**
         @property clicked {boolean}
         */
        this.clicked = false

        /**
         @property followobject {boolean/object}
         */
        this.followobject = false   //object to follow
        /**
         @property followspeed {boolean/integer}
         */
        this.followspeed = false    //followspeed for follower in pixel, has prio over followsteps
        /**
         @property followsteps {boolean/integer}
         */
        this.followsteps = false    //followsteps between follower and target

        /**
         @property attachedobject {boolean}
         */
        this.attachedobject = false //attached object
        /**
         @property offsetx {Number}
         */
        this.offsetx = 0            //offset x for attached object
        /**
         @property offsety {Number}
         */
        this.offsety = 0            //offset y for attached object
        return this
    },
    update:function () {
        this.ifClicked()
        this.ifMouseOver()
        this.ifAttached()

        if (this.followobject) {
            this.follow()
        }

        this.position.x += this.xspeed
        this.position.y += this.yspeed
        this.rotation += this.rotationspeed
        this.xhandle = (this.width * this.xscale / 2)
        this.yhandle = (this.height * this.yscale / 2)

        if (this.boundsMode) {
            this.checkBound()
        }
    },
    draw:function () {
        this.updateDiff()

        Game.b_ctx.save()
        Game.b_ctx.globalAlpha = this.alpha
        Game.b_ctx.translate(this.position.x, this.position.y)
        if (this.atlasimage) {
            Game.b_ctx.rotate((this.rotation - this.imagerotation) * CG.Const_PI_180)
            Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - this.xhandle, 0 - this.yhandle, this.cutwidth * this.xscale, this.cutheight * this.yscale)
        } else {
            Game.b_ctx.rotate(this.rotation * CG.Const_PI_180)
            Game.b_ctx.drawImage(this.image, 0 - this.xhandle, 0 - this.yhandle, this.image.width * this.xscale, this.image.height * this.yscale)
        }
        Game.b_ctx.restore()
    },

    /**
     * @description Checks the bound if a boundMode (bounce or slide) is set
     * @method checkBound
     */
    checkBound:function () {
        switch (this.boundsMode) {
            case 'bounce':
                if (this.position.x > ( this.bound.width - this.xhandle + this.bound.x )) {
                    this.position.x = this.bound.width - this.xhandle + this.bound.x
                    this.xspeed = this.xspeed * -1
                }
                else if (this.position.x < this.bound.x + this.xhandle) {
                    this.position.x = this.bound.x + this.xhandle
                    this.xspeed = this.xspeed * -1
                }
                if (this.position.y > ( this.bound.height - this.yhandle + this.bound.y )) {
                    this.position.y = this.bound.height - this.yhandle + this.bound.y
                    this.yspeed = this.yspeed * -1
                }
                else if (this.position.y < this.bound.y + this.yhandle) {
                    this.position.y = this.bound.y + this.yhandle
                    this.yspeed = this.yspeed * -1
                }
                break
            case 'slide':
                if (this.position.x > ( this.bound.width + this.xhandle + this.bound.x )) {
                    this.position.x = ( this.bound.x - this.xhandle )
                }
                else if (this.position.x < this.bound.x - this.xhandle) {
                    this.position.x = this.bound.x + this.bound.width + this.xhandle
                }
                if (this.position.y > (this.bound.height + this.yhandle + this.bound.y)) {
                    this.position.y = (this.bound.y - this.yhandle)
                }
                else if (this.position.y < this.bound.y - this.yhandle) {
                    this.position.y = this.bound.height + this.yhandle + this.bound.y
                }
                break
            default:
                break
        }
    },

    /**
     * @description calculate offset if bound is moving
     * @method updateDiff
     */
    updateDiff:function () {
        if (this.diffpoint.x !== this.bound.x) {
            this.position.x += this.bound.x - this.diffpoint.x
        }
        if (this.diffpoint.y !== this.bound.y) {
            this.position.y += this.bound.y - this.diffpoint.y
        }
        this.diffpoint.x = this.bound.x
        this.diffpoint.y = this.bound.y
    },
    /**
     * @description is there an attached element, this sprite will follow it depending on followspeed or followsteps it follows different
     * @method follow
     */
    follow:function () {
        if (this.followspeed) {
            //constant follow speed between objects
            angl = Math.atan2(this.followobject.position.x - this.position.x, this.followobject.position.y - this.position.y) * CG.Const_180_PI
            xs = this.followspeed * Math.sin(angl * CG.Const_PI_180)
            ys = this.followspeed * Math.cos(angl * CG.Const_PI_180)

            this.xspeed = xs
            this.yspeed = ys
            this.rotation = angl * -1

        } else if (this.followsteps) {
            //constant steps between objetcs
            angl = Math.atan2(this.followobject.position.x - this.position.x, this.followobject.position.y - this.position.y) * CG.Const_180_PI
            this.rotation = angl * -1
            if (this.followobject.position.x != this.position.x) {
                distx = this.followobject.position.x - this.position.x
                this.xspeed = distx / this.followsteps //>> 0
            } else {
                this.xspeed = 0
            }
            if (this.followobject.position.y != this.position.y) {
                disty = this.followobject.position.y - this.position.y
                this.yspeed = disty / this.followsteps //>> 0
            } else {
                this.yspeed = 0
            }
        }
    },

    /**
     * @description set the bound of the sprite
     * @method setBound
     * @param bound {CG.Bound} the bound
     */
    setBound:function (bound) {
        this.bound = bound
        return this
    },


    /**
     * @description if there is a attached object get its position
     * @method ifAttached
     */
    ifAttached:function () {
        if (this.attachedobject != false) {
            this.attachedobject.position._x = this.attachedobject.position.x = (this.position.x + this.offsetx)
            this.attachedobject.position._y = this.attachedobject.position.y = (this.position.y + this.offsety)
        }
    },

    /**
     * @description attach a reference of the given object to this object
     * @method attachObject
     */
    attachObject:function (obj) {
        this.attachedobject = obj
        return this
    },

    /**
     * @description removes the attached object reference
     * @method removeAttachedObject
     */
    removeAttachedObject:function () {
        this.attachedobject = null
        return this
    },

    /**
     * @description set the x offset of the attached object to this object
     * @method setAttachedOffsetX
     */
    setAttachedOffsetX:function (offsetx) {
        this.offsetx = offsetx
        return this
    },

    /**
     * @description set the y offset of the attached object to this object
     * @method setAttachedOffsetY
     */
    setAttachedOffsetY:function (offsety) {
        this.offsety = offsety
        return this
    }
})



/**
 * @description
 *
 * CG.TPImage class. It is needed when using TexturePacker atlas files.
 *
 * @class CG.TPImage
 * @extends Class
 */
CG.Class.extend('TPImage', {
    /**
     * @method init
     * @constructor
     * @param image {image} imgpath, image object or tpimage object to use
     * @param xoffset {Number} xoffset of image in atlas file
     * @param yoffset {Number} yoffset of image in atlas file
     * @param width {Number} width of image in atlas file
     * @param height {Number} height of image in atlas file
     */
    init:function (image, xoffset, yoffset, width, height) {
        /**
         * @property source
         * @type {String}
         */
        this.source = ''
        /**
         * @property atlasimage
         * @type {String}
         */
        this.atlasimage = ''
        /**
         * @property atlasname
         * @type {String}
         */
        this.atlasname = ''
        /**
         * @property image
         * @type {*}
         */
        this.image = image || ''    //imagepath
        /**
         * @property name
         * @type {String}
         */
        this.name = image.split(/(\\|\/)/g).pop().split('.')[0] //image name only for name
        /**
         * @property xoffset
         * @type {Number}
         */
        this.xoffset = xoffset || 0
        /**
         * @property yoffset
         * @type {*}
         */
        this.yoffset = yoffset || 0
        /**
         * @property width
         * @type {Number}
         */
        this.width = width || 0
        /**
         * @property height
         * @type {Number}
         */
        this.height = height || 0
        /**
         * @property rotation
         * @type {Number}
         */
        this.rotation = 0
    }
})/**
 *  @description
 *
 *  CG.TexturePacker class supports loading xml and json files from . . . TexturePacker ;o)
 *  No trimming at the moment, keep texturepacker settings simple! TexturePacker parses the xml/json and generates new CG.TPImage objects in the MediaAsset manager.
 *  These TPImages are only handled within Sprite, Particle and Button class.
 *
 *  @class CG.TexturePacker
 *  @extends Class
 */
CG.Class.extend('TexturePacker', {
    /**
     * @constructor
     * @method init
     * @return {*}
     */
    init:function () {
        if (typeof(ejecta) == 'undefined') {
            this.xml = ''
            this.xmlDoc = ''
            this.parser = new DOMParser() || {}
        }
        /**
         * @property imagename
         * @type {String}
         */
        this.imagename = ''
        /**
         * @property width
         * @type {Number}
         */
        this.width = 0
        /**
         * @property height
         * @type {Number}
         */
        this.height = 0
        /**
         * @property tpimages
         * @type {Array}
         */
        this.tpimages = []
        return this
    },
    /**
     * @description load a xml file from texturepacker
     * @method loadXml
     * @param {string/object} xmlfile path or mediaasset object with data of texturepacker xml
     * @return {*}
     */
    loadXml:function (xmlfile) {
        //from asset
        if (typeof xmlfile == 'string') {
            this.xml = loadString(xmlfile)
        } else {
            this.xml = xmlfile.data
        }

        this.xmlDoc = this.parser.parseFromString(this.xml, 'text/xml')

        this.imagename = this.xmlDoc.getElementsByTagName('TextureAtlas')[0].getAttribute('imagePath')
        this.width = parseInt(this.xmlDoc.getElementsByTagName('TextureAtlas')[0].getAttribute('width'))
        this.height = parseInt(this.xmlDoc.getElementsByTagName('TextureAtlas')[0].getAttribute('height'))

        var sprites = this.xmlDoc.getElementsByTagName('sprite')
        for (var i = 0, l = sprites.length; i < l; i++) {
            tpimage = new CG.TPImage(
                sprites[i].getAttribute('n'),
                parseInt(sprites[i].getAttribute('x')),
                parseInt(sprites[i].getAttribute('y')),
                parseInt(sprites[i].getAttribute('w')),
                parseInt(sprites[i].getAttribute('h'))
            )
            if (sprites[i].getAttribute('r') == 'y') {
                tpimage.rotation = 90
            }
            tpimage.atlasimage = this.imagename
            tpimage.source = 'xml'
            tpimage.atlasname = this.imagename.split(/(\\|\/)/g).pop().split('.')[0] //image name only for name

            this.tpimages.push(tpimage)
        }
        return this
    },

    /**
     * @description load a json file from texturepacker
     * @method loadJson
     * @param {string/object} jsonfile path or mediaasset object with data of texturepacker json
     * @return {*}
     */
    loadJson:function (jsonfile) {
        //from asset
        if (typeof jsonfile == 'string') {
            this.json = JSON.parse(loadString(jsonfile))
        } else {
            this.json = jsonfile.data
        }
        //meta info from json file
        this.imagename = this.json.meta.image
        this.width = this.json.meta.size.w
        this.height = this.json.meta.size.h

        //loop thru all images
        for (var i = 0, l = this.json.frames.length; i < l; i++) {
            var image = this.json.frames[i]
            var tpimage = new CG.TPImage(
                image.filename,
                image.frame.x,
                image.frame.y,
                image.frame.w,
                image.frame.h
            )
            if (image.rotated === true) {
                tpimage.rotation = 90
                //            tpimage.width = this.json.frames[i].frame.w,
                //            tpimage.height = this.json.frames[i].frame.h
            }
            tpimage.atlasimage = this.imagename
            tpimage.source = 'json'
            tpimage.atlasname = this.imagename.split(/(\\|\/)/g).pop().split('.')[0] //image name only for name

            this.tpimages.push(tpimage)
        }
        return this
    },

    /**
     * @description get all texturepacker images (Use array.push.apply(array, anotherarray) to append to Game.asset)
     * @method getTPImages
     * @return {array} returns all tpimages of texturepacker file to use with Game.asset
     */
    getTPImages:function () {
        return this.tpimages
    }
})


/**
 * @description
 *
 * CG.Animation extends CG.Sprite and add support for animations ;o) It needs atlas files with fixed framesizes and with following animation frames.
 * For example you can use Timeline FX generated graphics.
 *
 * @class CG.Animation
 * @extends CG.Sprite
 */
CG.Sprite.extend('Animation', {
    /**
     * @constructor
     * @method init
     * @param image {string, image} image imagepath or image object
     * @param position {point} position object
     * @param startframe {number} startframe of atlas image
     * @param endframe {number} endframe endframe of atlas image
     * @param framewidth {number} framewidth width of frame to cut
     * @param frameheight {number} frameheight height of frame to cut
     * @return {*}
     */
    init:function (image, position, startframe, endframe, framewidth, frameheight) {
        this._super(image, position)

        //from asset?
        if (typeof image == 'string') {
            this.image = new Image()
            this.image.src = image
        } else {
            this.image = image
        }

        /**
         @property loop {boolean}
         */
        this.loop = true
        /**
         @property status {Number}
         */
        this.status = 0
        /**
         @property currentframe {Number}
         */
        this.currentframe = 0
        /**
         @property frames {Number}
         */
        this.frames = 0
        /**
         @property startframe {Number}
         */
        this.startframe = startframe - 1
        /**
         @property endframe {Number}
         */
        this.endframe = endframe - 1
        /**
         @property width {Number}
         */
        this.width = framewidth
        /**
         @property height {Number}
         */
        this.height = frameheight

        if (this.startframe === undefined && this.endframe === undefined) {
            this.frames = 1
            this.startframe = 0
            this.endframe = 0
        } else {
            this.currentframe = this.startframe - 1
            this.frames = this.endframe - this.startframe + 1
        }

        /**
         @property fx {Number}
         */
        this.fx = 0
        /**
         @property fy {Number}
         */
        this.fy = 0

        /**
         @property delay {Number}
         */
        this.delay = 0
        /**
         @property tempdelay {Number}
         */
        this.tempdelay = 0

        return this
    },
    update:function () {
        //animation specific stuff
        if (this.status == 0) {
            this.tempdelay += 1
            if (this.tempdelay >= this.delay) {
                this.tempdelay = 0
                if (this.frames > 1) {
                    this.currentframe += 1
                    if ((this.currentframe - this.startframe) >= this.frames) {
                        if (this.loop === false) {
                            this.status = 1 //time to say good by, elements would be deleted at the moment
                        } else {
                            this.currentframe = this.startframe
                        }
                    }
                }
            }
        }
        //update all other stuff in the parent class
        this._super()
    },
    draw:function () {
        this.updateDiff()

        Game.b_ctx.save()
        Game.b_ctx.globalAlpha = this.alpha
        Game.b_ctx.translate(this.position.x, this.position.y)
        if (this.frames == 1) {
            Game.b_ctx.drawImage(this.image, this.position.x, this.position.y, this.image.width * this.xscale, this.image.height * this.yscale)
        }
        else {
            this.fx = this.currentframe * this.width

            if ((this.fx / this.image.width) > 0) {
                this.fx = this.fx % this.image.width
            }
            this.fy = Math.floor(this.width * this.currentframe / this.image.width) * this.height

            Game.b_ctx.rotate(this.rotation * CG.Const_PI_180)
            try {
                Game.b_ctx.drawImage(this.image, this.fx, this.fy, this.width, this.height, 0 - this.xhandle, 0 - this.yhandle, this.width * this.xscale, this.height * this.yscale)
            } catch (e) {

            }
        }
        Game.b_ctx.restore()
    }
})

/**
 * @description
 *
 * CG.Bitmap is a simple bitmap class with basic features for bitmap manipulation at the moment.
 *
 * @class CG.Bitmap
 * @extends CG.Entity
 *
 */

//@TODO add margin squares function for contour finding => also for polygon path? (http://www.emanueleferonato.com/2013/03/01/using-marching-squares-algorithm-to-trace-the-contour-of-an-image/)
//@TODO add surface normal function (http://gamedev.tutsplus.com/tutorials/implementation/coding-destructible-pixel-terrain/, http://en.wikipedia.org/wiki/Surface_normal)

CG.Entity.extend('Bitmap', {
    /**
     * @method init
     * @constructor
     * @param width {Number} width the width for the buffer
     * @param height {Number} height the height for the buffer
     * @return {*}
     */
    init:function (width, height) {
        this._super(this)
        this.x = 0
        this.y = 0
        this.bitmap_canvas = document.createElement('canvas')
        this.bitmap_canvas.width = width
        this.bitmap_canvas.height = height
        this.bitmap_ctx = this.bitmap_canvas.getContext('2d')
        return this
    },
    /**
     * @description
     *
     * Loads an image and draws it to the buffer
     *
     * @method loadImage
     *
     * @param {string, image, tpimage} imgpath, image object or tpimage object to use
     */
    loadImage:function (image) {
        this.setImage(image)
        this.drawImageToBuffer()
        return this
    },


    update:function () {
    },

    draw:function () {
        Game.b_ctx.drawImage(this.bitmap_canvas, this.x, this.y)
    },


    /**
     * @method clearBuffer
     */
    clearBuffer:function () {
        this.bitmap_ctx.clearRect(0, 0, this.bitmap_canvas.width, this.bitmap_canvas.height)
        return this
    },

    /**
     * @method drawImageToBuffer
     */
    drawImageToBuffer:function () {
        this.bitmap_ctx.drawImage(this.image, 0, 0)
        return this
    },


    /**
     * @method clearRect
     *
     * @param {Number} x the x position for clearRect
     * @param {Number} y the y position for clearRect
     * @param {Number} width the width for clearRect
     * @param {Number} height the height for clearRect
     */
    clearRect:function (x, y, width, height) {
        this.bitmap_ctx.save()
        this.bitmap_ctx.globalCompositeOperation = 'destination-out'
        this.bitmap_ctx.clearRect(x, y, width, height)
        this.bitmap_ctx.restore()
    },

    /**
     * @method clearCircle
     *
     * @param {Number} x the x position for clearCircle
     * @param {Number} y the y position for clearCircle
     * @param {Number} radius the radius for clearCircle
     */
    clearCircle:function (x, y, radius) {
        this.bitmap_ctx.save()
        this.bitmap_ctx.globalCompositeOperation = 'destination-out'
        this.bitmap_ctx.beginPath()
        this.bitmap_ctx.arc(x, y, radius, 0, 2 * Math.PI, false)
        this.bitmap_ctx.closePath()
        this.bitmap_ctx.fill()
        this.bitmap_ctx.restore()
    },

    /**
     * @method getPixel
     *
     * @param {Number} x the x position for getPixel
     * @param {Number} y the y position for getPixel
     * @returns {imagedata} data from canvas
     */
    getPixel:function (x, y) {
        return this.bitmap_ctx.getImageData(x, y, 1, 1)
    },

    /**
     * @method getPixels
     *
     * @param {Number} x the x position for getPixels
     * @param {Number} y the y position for getPixels
     * @param {Number} width for getPixels
     * @param {Number} height for getPixels
     * @returns {imagedata} data from canvas
     */
    getPixels:function (x, y, width, height) {
        return this.bitmap_ctx.getImageData(x, y, width, height)
    }
})


/**
 * @description
 *
 * CG.Button represents a simple button class that can handle click, mouseover and callback functionality.
 *
 * @class CG.Button
 * @extends CG.Sprite
 *
 */
CG.Sprite.extend('Button', {
    /**
     * @method init
     * @constructor
     * @param image {image} image image path, image or tpimage
     * @param position {CG.Point} position point
     * @param text {string} the button text
     * @param font {CG.Font} a CG.Font object for text rendering
     * @param clickedCallback {callback} callback function for click handling
     * @return {*}
     */
    init:function (image, position, text, font, clickedCallback) {
        this._super(image, position)

        /**
         @property font {CG.Font}
         */
        this.font = font
        /**
         @property clickedCallback {callback}
         */
        this.clickedCallback = clickedCallback
        /**
         @property clicked {boolean}
         */
        this.clicked = false
        /**
         @property clickable {boolean}
         */
        this.clickable = true

        /**
         @property text {string}
         */
        this.text = text
        return this
    },
    update:function () {
        this.ifClicked()
        this.ifMouseOver()
        this.ifAttached()

        if (this.clicked) {
            if (this.clickedCallback) {
                this.clicked = false
                this.clickedCallback(this)
            }
        }
    },
    draw:function () {
        Game.b_ctx.save()
        Game.b_ctx.translate(this.position.x, this.position.y)
        if (this.atlasimage) {
            var r = this.rotation
            Game.b_ctx.rotate((r - this.imagerotation) * CG.Const_PI_180)
            Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - (this.cutwidth / 2), 0 - (this.cutheight / 2), this.cutwidth * this.xscale, this.cutheight * this.yscale)
            Game.b_ctx.rotate(this.imagerotation * CG.Const_PI_180)
        } else {
            Game.b_ctx.rotate(r * CG.Const_PI_180)
            Game.b_ctx.drawImage(this.image, 0 - (this.image.width * this.xscale / 2), 0 - (this.image.height * this.yscale / 2), this.image.width * this.xscale, this.image.height * this.yscale)
        }
        this.font.drawText(this.text, 0 - (this.font.getTextWidth(this.text) / 2 >> 0), 0 - ((this.font.getFontSize() / 2) >> 0))
        Game.b_ctx.restore()
    }
})


/**
 * @description
 *
 * CG.Menu
 *
 * @class CG.Menu
 * @extends CG.Entity
 *
 */
CG.Entity.extend('Menu', {
    /**
     * @method init
     * @constructor
     * @param x {Number} x the x position
     * @param y {Number} y the y position
     * @param margin {Number} margin the margin between the menu buttons
     * @return {*}
     */
    init:function (x, y, margin) {
        /**
         * @property x
         * @type {Number}
         */
        this.x = x
        /**
         * @property y
         * @type {Number}
         */
        this.y = y
        /**
         * @proerty margin
         * @type {Number}
         */
        this.margin = margin
        /**
         * @property step
         * @type {*}
         */
        this.step = this.y
        /**
         * @property buttons
         * @type {Array}
         */
        this.buttons = []
        return this
    },
    /**
     * @method addButton
     *
     * @param {button} button
     */
    addButton:function (button) {
        this.buttons.push(button)
    },

    update:function () {
        this.buttons.forEach(function (button) {
            button.update()
        }, this)
    },

    draw:function () {
        this.buttons.forEach(function (button) {
            button.position.x = this.x
            button.position.y = this.step
            button.draw()
            this.step += button.height
            this.step += this.margin
        }, this)
        this.step = this.y
    }
})


/**
 * @description
 *
 * CG.MediaAsset preloader.
 *
 * @class CG.MediaAsset
 * @extends Class
 *
 */

CG.Class.extend('MediaAsset', {
    /**
     * @method init
     * @constructor
     * @param image {string} image path to background image of preloader
     * @param ctx {canvas context} canvas context for drawing
     */
    init:function (image, ctx) {
        if (image != '') {
            this.image = new Image()
            this.image.src = image
        }

        this.ctx = ctx

        this.ready = false
        this.progress = 0

        this.images = []
        this.currimage = 0

        this.sounds = []
        this.currsound = 0

        this.xmls = []
        this.currxml = 0

        this.jsons = []
        this.currjson = 0

        this.fonts = []
        this.currfont = 0

        this.assetcount = 0
        this.assetcurrent = 0

        //progress
        this.width = 300
        this.height = 20
        this.radius = 10

        this.linewidth = 8
        this.bordercolor = 'white'
        this.progresscolor = 'red'
        this.shadowcolor = '#222'
        this.shadowblur = 6
        this.shadowoffsetx = 2
        this.shadowoffsety = 2

//return this
    },
    /**
     * @method addImage
     * @param path
     * @param name
     * @return {*}
     */
    addImage:function (path, name) {
        this.assetcount += 1
        this.images.push({
            name:name || '', //optional
            path:path,
            img:new Image()
        })
        return this
    },
    /**
     * @method addFont
     * @param path
     * @param name
     * @return {*}
     */
    addFont:function (path, name) {
        this.assetcount += 1
        this.fonts.push({
            name:name || '', //optional
            path:path,
            data:''
        })
        return this
    },
    /**
     * @method addXml
     * @param path
     * @param name
     * @return {*}
     */
    addXml:function (path, name) {
        this.assetcount += 1
        this.xmls.push({
            name:name || '', //optional
            path:path,
            data:''
        })
        return this
    },
    /**
     * @method addJson
     * @param path
     * @param name
     * @return {*}
     */
    addJson:function (path, name) {
        this.assetcount += 1
        this.jsons.push({
            name:name || '', //optional
            path:path,
            data:''
        })
        return this
    },
    /**
     * @method getImageByName
     * @param name
     * @return {*}
     */
    getImageByName:function (name) {
        for (var i = 0, l = this.images.length; i < l; i++) {
            if (this.images[i].name == name) {
                if (this.images[i] instanceof CG.TPImage) {
                    return this.images[i]
                } else {
                    return this.images[i].img
                }
            }
        }
        throw new CG.MediaAssetException('No image with this name in asset.')
    },
    /**
     * @method getImagesByName
     * @param name
     * @return {*}
     */
    getImagesByName:function (name) {
        names = []
        for (var i = 0, l = this.images.length; i < l; i++) {
            if (this.images[i].name == name) {
                if (this.images[i] instanceof CG.TPImage) {
                    names.push(this.images[i])
                } else {
                    names.push(this.images[i].img)
                }
            }
        }
        if (names.length === 0) {
            throw new CG.MediaAssetException('No image with this name in asset.')
        }
        return names
    },
    /**
     * @method getFontByName
     * @param name
     * @return {*}
     */
    getFontByName:function (name) {
        for (var i = 0, l = this.fonts.length; i < l; i++) {
            if (this.fonts[i].name == name) {
                return this.fonts[i]
            }
        }
        throw new CG.MediaAssetException('No font with this name in asset.')
    },
    /**
     * @method getXmlByName
     * @param name
     * @return {*}
     */
    getXmlByName:function (name) {
        for (var i = 0, l = this.xmls.length; i < l; i++) {
            if (this.xmls[i].name == name) {
                return this.xmls[i]
            }
        }
        throw new CG.MediaAssetException('No XML with this name in asset.')
    },
    /**
     * @method getJsonByName
     * @param name
     * @return {*}
     */
    getJsonByName:function (name) {
        for (var i = 0, l = this.jsons.length; i < l; i++) {
            if (this.jsons[i].name == name) {
                return this.jsons[i]
            }
        }
        throw new CG.MediaAssetException('No JSON with this name in asset.')
    },
    /**
     * @method startPreLoad
     */
    startPreLoad:function () {

        this.progress = 100 / this.assetcount * this.assetcurrent
        this.progressScreen()

        if (this.currimage < this.images.length) {
            //BUG last image is not preloading
            this.images[this.currimage].img.onload = function () {
                console.log('loaded image (' + Math.floor(100 / (this.images.length - 1) * this.currimage) + ' %): ' + this.images[this.currimage].name)
                this.currimage += 1
                this.assetcurrent += 1
                this.startPreLoad()
            }.bind(this)
            this.images[this.currimage].img.src = this.images[this.currimage].path
        } else if (this.currfont < this.fonts.length) {
            //        if(typeof(ejecta) !== 'undefined'){
            //            this.fonts[this.currfont].data = ejecta.loadText(this.fonts[this.currfont].path)
            //        } else {
            this.fonts[this.currfont].data = loadString(this.fonts[this.currfont].path)
            //        }
            this.currfont += 1
            this.assetcurrent += 1
            this.startPreLoad()
        } else if (this.currxml < this.xmls.length) {
            this.xmls[this.currxml].data = loadString(this.xmls[this.currxml].path)
            this.currxml += 1
            this.assetcurrent += 1
            this.startPreLoad()
        } else if (this.currjson < this.jsons.length) {
            //        if(typeof(ejecta) !== 'undefined'){
            //            this.jsons[this.currjson].data = ejecta.loadJSON(this.jsons[this.currjson].path)
            //        } else {
            this.jsons[this.currjson].data = JSON.parse(loadString(this.jsons[this.currjson].path))
            //        }
            this.currjson += 1
            this.assetcurrent += 1
            this.startPreLoad()
        } else if (this.currimage == this.images.length &&
            this.assetcount == this.assetcurrent) {
            this.ready = true
            Game.create()
        }
    },
    /**
     * @method progressScreen
     * @description render a progress screen to the canvas
     */
    progressScreen:function () {
        var x = (Game.bound.width - this.width) / 2
        var y = (Game.bound.height - this.height) / 2
        if (this.image) {
            this.ctx.drawImage(this.image, 0, 0, this.image.width, this.image.height)
        } else {
            this.ctx.clearRect(0, 0, Game.bound.width, Game.bound.height)
        }
        this.ctx.save()

        this.ctx.fillStyle = this.progresscolor;
        this.ctx.fillRect((Game.bound.width - this.width) / 2, (Game.bound.height - this.height) / 2, this.width / 100 * this.progress, this.height);

        this.ctx.strokeStyle = this.bordercolor
        this.ctx.shadowColor = this.shadowcolor
        this.ctx.shadowBlur = this.shadowblur
        this.ctx.shadowOffsetX = this.shadowoffsetx
        this.ctx.shadowOffsetY = this.shadowoffsety
        this.ctx.beginPath();
        this.ctx.moveTo(x + this.radius, y);
        this.ctx.lineTo(x + this.width - (1 * this.radius), y)
        this.ctx.arcTo(x + this.width, y, x + this.width, y + this.radius, this.radius)
        this.ctx.arcTo(x + this.width, this.radius * 2 + y, x + this.width - (1 * this.radius), this.radius * 2 + y, this.radius)
        this.ctx.lineTo(x + this.radius, 2 * this.radius + y)
        this.ctx.arcTo(x, 2 * this.radius + y, x, y, this.radius)
        this.ctx.arcTo(x, y, 2 * this.radius + x, y, this.radius)
        this.ctx.lineWidth = this.linewidth
        this.ctx.stroke()
        this.ctx.restore()
    }
})

function MediaAssetException(message) {
    this.message = message
}



/**
 * @description
 *
 * CG.Font supports loading and drawing font files (EZ GUI Text format) from Glyph Designer,
 * (Hiero works also but need some modifications of the exported files)
 @example
 //create font object
 small = new CG.Font().loadFont(Game.asset.getFontByName('small'))

 //draw text to canvas
 small.drawText('Foo bar!', xpos, ypos)
 *
 * @class CG.Font
 * @extends CG.Entity
 */
CG.Entity.extend('Font', {
    /**
     * @method init
     * @constructor
     * @return {*}
     */
    init: function () {
        /**
         @property atlas {Image}
         */
        this.atlas = new Image()
        /**
         @property initText {string}
         */
        this.fontFile = ''
        /**
         @property chars {Array}
         */
        this.chars = new Array(256)
        /**
         @property x {Array}
         */
        this.x = new Array(256)
        /**
         @property y {Array}
         */
        this.y = new Array(256)
        /**
         @property width {Array}
         */
        this.width = new Array(256)
        /**
         @property height {Array}
         */
        this.height = new Array(256)
        /**
         @property xoff {Array}
         */
        this.xoff = new Array(256)
        /**
         @property yoff {Array}
         */
        this.yoff = new Array(256)
        /**
         @property xadv {Array}
         */
        this.xadv = new Array(256)
        /**
         @property lineHeight {Number}
         */
        this.lineHeight = 0
        /**
         @property face {string}
         */
        this.face = ''
        /**
         @property size {Number}
         */
        this.size = 0
        /**
         @property bold {Number}
         */
        this.bold = 0
        /**
         @property italic {Number}
         */
        this.italic = 0

        /**
         @property base {Number}
         */
        this.base = 0
        /**
         @property scaleW {Number}
         */
        this.scaleW = 0
        /**
         @property scaleH {Number}
         */
        this.scaleH = 0
        return this
    },
    /**
     * @method update
     */
    update: function () {
        throw {
            name: 'Font Error',
            message: 'TODO, not defined yet.'
        }
    },
    /**
     * @method draw
     */
    draw: function () {
        throw {
            name: 'Font Error',
            message: 'TODO, not defined yet.'
        }
    },
    /**
     * @description draw the given text to the canvas
     * @method draw
     * @param text {string} the text to draw
     * @param xpos {Number} the x position
     * @param ypos {Number} the y position
     */
    drawText: function (text, xpos, ypos) {
        var currx = xpos
        var curry = ypos

        for (var i = 0, l = text.length; i < l; i++) {
            var charCode = text.charCodeAt(i)
            try {
                Game.b_ctx.drawImage(
                    this.atlas,
                    this.x[charCode],
                    this.y[charCode],
                    this.width[charCode],
                    this.height[charCode],
                    currx,
                    curry + this.yoff[charCode],
                    this.width[charCode],
                    this.height[charCode]
                )
            } catch (e) {
                //console.log("drawText error: " + e)
            }
            currx += this.xadv[charCode]
        }
    },

    /**
     * @description get the line height of the current font
     * @method getLineHeight
     * @return lineheight {Number}
     */
    getLineHeight: function () {
        return this.lineHeight
    },

    /**
     * @description get the font size of the current font
     * @method getFontSize
     * @return size {Number} font size
     */
    getFontSize: function () {
        return this.size
    },

    /**
     * @description get the width of the given text
     * @method getTextWidth
     * @param text {string} the string to calculate the width
     * @return textwidth {Number}
     */
    getTextWidth: function (text) {
        var textwidth = 0
        var c = 0
        for (var i = 0, l = text.length; i < l; i++) {
            textwidth += this.xadv[text.charCodeAt(i)]
        }
        return textwidth
    },

    /**
     * @description loadFont - load and parse the given fontfile
     * @method loadFont
     * @param {string/object} fontfile path or mediaasset object with data
     */
    loadFont: function (fontfile) {
        idnum = 0
        if (typeof fontfile == 'string') {
            this.fontFile = loadString(fontfile)
        } else {
            this.fontFile = fontfile.data
        }

        var lines = this.fontFile.split('\n')
        for (l in lines) {
            line = lines[l].trim()

            if (line.startsWith('info') || line == '') {
                var infodata = line.split(' ')
                for (i in infodata) {
                    var info = infodata[i]
                    if (info.startsWith('face=')) {
                        var face = info.split("=")
                        this.face = face[1].split('"').join('')
                    }
                    if (info.startsWith('size=')) {
                        var size = info.split("=")
                        this.size = parseInt(size[1])
                    }
                    if (info.startsWith('bold=')) {
                        var bold = info.split("=")
                        this.bold = parseInt(bold[1])
                    }
                    if (info.startsWith('italic=')) {
                        var italic = info.split("=")
                        this.italic = parseInt(italic[1])
                    }
                }
            }
            if (line.startsWith('padding')) {
                continue
            }
            if (line.startsWith('common')) {
                var commondata = line.split(' ')
                for (c in commondata) {
                    var common = commondata[c]
                    if (common.startsWith('lineHeight=')) {
                        var lnh = common.split("=")
                        this.lineHeight = parseInt(lnh[1])
                    }
                    if (common.startsWith('base=')) {
                        var base = common.split("=")
                        this.base = parseInt(base[1])
                    }
                    if (common.startsWith('scaleW=')) {
                        var scaleW = common.split("=")
                        this.scaleW = parseInt(scaleW[1])
                    }
                    if (common.startsWith('scaleH=')) {
                        var scaleH = common.split("=")
                        this.scaleH = parseInt(scaleH[1])
                    }
                }
            }
            if (line.startsWith('page')) {
                var pagedata = line.split(' ')
                for (p in pagedata) {
                    data = pagedata[p]
                    if (data.startsWith('file=')) {
                        var fn = data.split('=')
                        this.atlas.src = 'media/font/' + fn[1].split('"').join('')
                    }

                }
            }
            if (line.startsWith('chars')) {
                continue
            }
            if (line.startsWith('char')) {
                var linedata = line.split(' ')
                for (l in linedata) {
                    ld = linedata[l]
                    if (ld.startsWith('id=')) {
                        var idc = ld.split('=')
                        idnum = parseInt(idc[1])
                    }
                    if (ld.startsWith('x=')) {
                        var xc = ld.split('=')
                        this.x[idnum] = parseInt(xc[1])
                    }
                    if (ld.startsWith('y=')) {
                        var yc = ld.split('=')
                        this.y[idnum] = parseInt(yc[1])
                    }
                    if (ld.startsWith('width=')) {
                        var wc = ld.split('=')
                        this.width[idnum] = parseInt(wc[1])
                    }
                    if (ld.startsWith('height=')) {
                        var hc = ld.split('=')
                        this.height[idnum] = parseInt(hc[1])
                    }
                    if (ld.startsWith('xoffset=')) {
                        var xoc = ld.split('=')
                        this.xoff[idnum] = parseInt(xoc[1])
                    }
                    if (ld.startsWith('yoffset=')) {
                        var yoc = ld.split('=')
                        this.yoff[idnum] = parseInt(yoc[1])
                    }
                    if (ld.startsWith('xadvance=')) {
                        var advc = ld.split('=')
                        this.xadv[idnum] = parseInt(advc[1])
                    }
                }
            }
        }
        return this
    }
})


/**
 * @description
 *
 * Future plans:
 * CG.Text => support for different text drawing modes like textblock, text alignment, text ticker or scroller.
 *
 * @class CG.Text
 * @extends CG.Entity
 */
CG.Entity.extend('Text', {
    /**
     * @method init
     * @param font the font object (CG.Font) to use
     * @constructor
     * @return {*}
     */

    init: function (font) {

        /**
         @property font {CG.Font}
         */
        this.font = font

        /**
         * @property text {string}
         */
        this.text = ''

        /**
         * @property textcurrent {string}
         */
        this.textcurrent = ''

        /**
         * @property x {number} the x position
         */
        this.x = 0

        /**
         * @property y {number} the y position
         */
        this.y = 0

        /**
         * @property width {number} width of textbox
         */
        this.width = 0

        /**
         * @property height {number} height of textbox
         */
        this.height = 0

        /**
         * @property textAlign {string} alignment of text
         */
        this.textAlign = 'left' //left, right, centered

        return this
    },
    initAsTextblock: function (font) {

        return this
    },
    initAsScroller: function () {

    },
    initAsTicker: function () {

    },
    /**
     * @method setText
     * @param text
     * @returns {*}
     */
    setText: function (text) {
        this.text = text
        return this
    },
    /**
     * @method update
     */
    update: function () {

    },
    /**
     * @method draw
     */
    draw: function () {

    }
})/**
 * @description
 *
 * CG.Director the top instance for CG.Screens, CG.Layers, CG.Sprites and so on in the control hierarchy.
 * Its main purpose is to collect CG.Screens under its hood and support some basic screen fading features.
 @example
 //create top level CG.Director object
 var director = new CG.Director()

 //create a CG.Screen
 var mainscreen = new CG.Screen('mainscreen')

 //create a CG.Layer
 var mainlayer = new CG.Layer('mainlayer')

 //create a demo CG.Sprite
 var demosprite = new CG.Sprite(Game.asset.getImageByName('spritegfx'), new CG.Point(400, 240))

 //add/attach the demo sprite to the layer
 mainlayer.addElement(back)

 //add/attach mainscreen and mainlayer to the director
 director.addScreen(mainscreen.addLayer(mainlayer))

 * @class CG.Director
 * @extends Class
 */
CG.Class.extend('Director', {
    /**
     * @method init
     * @constructor
     * @return {*}
     */
    init: function () {
        /**
         * @property screens
         * @type {Array}
         */
        this.screens = []
        /**
         * @property activescreen
         * @type {Number}
         */
        this.activescreen = 0
        /**
         * @description nextscreen
         * @type {Number}
         */
        this.nextscreen = 0
        /**
         * @property duration
         * @type {Number}
         */
        this.duration = 20
        /**
         * @property stepx
         * @type {number}
         */
        this.stepx = 40
        /**
         * @property stepy
         * @type {number}
         */
        this.stepy = 30
        /**
         * @description alpha
         * @type {Number}
         */
        this.alpha = 0
        /**
         * @description mode
         * @type {String}
         */
        this.mode = 'fade'      //fade or scale
        /**
         * @description direction
         * @type {String}
         */
        this.direction = CG.RIGHT      //CG.LEFT, CG.RIGHT, CG.UP, CG.DOWN
        /**
         * @property color
         * @type {String}
         */
        this.color = 'rgb(0,0,0)'
        return this
    },
    update: function () {
        //handle screen fading
        switch (this.mode) {
            case 'scale':
                if (this.nextscreen != this.activescreen) {
                    this.screens[this.activescreen].xscale -= 0.4 / this.duration
                    this.screens[this.activescreen].yscale -= 0.4 / this.duration
                } else if (this.nextscreen == this.activescreen) {
                    this.screens[this.activescreen].xscale += 0.4 / this.duration
                    this.screens[this.activescreen].yscale += 0.4 / this.duration
                }

                if (this.screens[this.activescreen].xscale >= 1) {
                    this.screens[this.activescreen].xscale = this.screens[this.activescreen].yscale = 1
                    this.screens[this.nextscreen].xscale = this.screens[this.nextscreen].yscale = 1
                }

                if (this.screens[this.activescreen].xscale <= 0) {
                    this.screens[this.activescreen].xscale = this.screens[this.activescreen].yscale = 1
                    this.screens[this.nextscreen].xscale = this.screens[this.nextscreen].yscale = 0
                    this.activescreen = this.nextscreen
                }
                //this.screens[this.nextscreen].update()
                break

            case 'fade':
                // the fade is bound to the alpha value in the draw method
                if (this.nextscreen != this.activescreen && this.alpha < 1) {
                    this.alpha += 1 / this.duration
                } else if (this.nextscreen == this.activescreen && this.alpha != 0) {
                    this.alpha -= 1 / this.duration
                }
                if (this.alpha >= 1) {
                    this.activescreen = this.nextscreen
                    this.alpha = 1
                }
                if (this.alpha < 0) {
                    this.alpha = 0
                }
                break

            case 'slide':
                if (this.nextscreen != this.activescreen) {
                    switch (this.direction) {
                        case CG.UP:
                            this.screens[this.activescreen].position.y -= this.stepy
                            this.screens[this.nextscreen].position.y -= this.stepy
                            if (this.screens[this.nextscreen].position.y < 0) {
                                this.resetScreens()
                                this.activescreen = this.nextscreen
                            }
                            break
                        case CG.DOWN:
                            this.screens[this.activescreen].position.y += this.stepy
                            this.screens[this.nextscreen].position.y += this.stepy
                            if (this.screens[this.nextscreen].position.y > 0) {
                                this.resetScreens()
                                this.activescreen = this.nextscreen
                            }
                            break
                        case CG.LEFT:
                            this.screens[this.activescreen].position.x -= this.stepx
                            this.screens[this.nextscreen].position.x -= this.stepx
                            if (this.screens[this.nextscreen].position.x < 0) {
                                this.resetScreens()
                                this.activescreen = this.nextscreen
                            }
                            break
                        case CG.RIGHT:
                            this.screens[this.activescreen].position.x += this.stepx
                            this.screens[this.nextscreen].position.x += this.stepx
                            if (this.screens[this.nextscreen].position.x > 0) {
                                this.resetScreens()
                                this.activescreen = this.nextscreen
                            }
                            break
                    }
                    //this.screens[this.nextscreen].update()
                }
                break
        }
        this.screens[this.activescreen].update()
    },
    draw: function () {
        //draw active screen
        this.screens[this.activescreen].draw()

        //draw nextscreen for slide mode
        if (this.screens[this.nextscreen].position.x != 0 || this.screens[this.nextscreen].position.y != 0) {
            this.screens[this.nextscreen].draw()
        }

        //draw fading layer => why not use the screens itself with alpha without additional rect?
        if (this.alpha > 0) {
            Game.b_ctx.save()
            Game.b_ctx.globalAlpha = this.alpha
            Game.b_ctx.fillStyle = this.color
            Game.b_ctx.fillRect(0, 0, Game.bound.width, Game.bound.height)
            Game.b_ctx.restore()
        }
    },
    /**
     * @method nextScreen
     @example
     //tell the director class to fade to next screen with scale mode
     Game.director.nextScreen('gamescreen', 'scale', 10);

     //tell the director class to fade to next screen
     Game.director.nextScreen('settingsscreen', 'fade', 10);
     *
     * @param {string} screenname to define nextscreen for fading
     * @param {string} mode mode for transition
     * @param {Number} duration the duration for fading
     */
    nextScreen: function (screenname, mode, duration) {
        var nextscreen = this.getIndexOfScreen(screenname)

        if (nextscreen != this.activescreen) {
            this.resetScreens()
            this.mode = mode
            this.duration = duration
            this.stepx = Game.canvas.width / this.duration >> 0
            this.stepy = Game.canvas.height / this.duration >> 0
            this.nextscreen = nextscreen

            if (this.mode === 'scale') {
                this.alpha = 0
            } else if (this.mode === 'fade') {
                // hmm ;o) ?
            } else if (this.mode === 'slide') {
                switch (this.direction) {
                    case CG.UP:
                        this.screens[this.nextscreen].position.y += CG.canvas.height
                        break
                    case CG.DOWN:
                        this.screens[this.nextscreen].position.y -= CG.canvas.height
                        break
                    case CG.LEFT:
                        this.screens[this.nextscreen].position.x += CG.canvas.width
                        break
                    case CG.RIGHT:
                    default:
                        this.screens[this.nextscreen].position.x -= CG.canvas.width
                        break
                }
            }
        }
        return this
    },
    resetScreens: function () {
        this.screens[this.activescreen].position = new CG.Point(0, 0)
        this.screens[this.nextscreen].position = new CG.Point(0, 0)
        return this
    },
    /**
     * @method addScreen
     *
     * @param {CG.Screen} screen to add to the screen list
     */
    addScreen: function (screen) {
        this.screens.push(screen)
        return this
    },
    /**
     * @method getScreenByName
     *
     * @param {string} screenname to find screen by name
     * @return {false/CG.Screen} returns false or the screen object
     */
    getScreenByName: function (screenname) {
        for (var i = 0, l = this.screens.length; i < l; i++) {
            if (this.screens[i].name == screenname) {
                return this.screens[i]
            }
        }
        return false
    },

    /**
     * @method getIndexOfScreen
     *
     * @param {string} screenname to find index of screen in screen array
     * @return {false/Number} return false or index number of the screen
     */
    getIndexOfScreen: function (screenname) {
        for (var i = 0, l = this.screens.length; i < l; i++) {
            if (this.screens[i].name == screenname) {
                return i
            }
        }
        return false
    },

    /**
     * @method getActiveScreenName
     *
     * @return {string} the name of the active screen
     */
    getActiveScreenName: function () {
        return this.screens[this.activescreen].name
    },
    setDirection: function (direction) {
        this.direction = direction
        return this
    }
})/**
 * @description
 *
 * CG.Screen is a child of CG.Director and a container to collect/group CG.Layers and/or CG.B2DWorld
 *
 * @class CG.Screen
 * @extends CG.Entity
 *
 * @param {string} screenname the name of the screen
 */
CG.Entity.extend('Screen', {
    /**
     * @constructor
     * @method init
     * @param screenname
     * @return {*}
     */
    init: function (screenname) {
        this._super(screenname)
        /**
         @property position {CG.Point}
         */
        this.position = new CG.Point(0, 0)
        /**
         * @property xscale
         * @type {Number}
         */
        this.xscale = 1
        /**
         * @property yscale
         * @type {Number}
         */
        this.yscale = 1
        /**
         * @property layers
         * @type {Array}
         */
        this.layers = []
        return this
    },
    create: function () {

    },
    update: function () {
        for (var i = 0, l = this.layers.length; i < l; i++) {
            this.layers[i].update()
        }
    },
    draw: function () {
        Game.b_ctx.save()
        if (this.xscale !== 1 || this.yscale !== 1) {
            Game.b_ctx.translate((Game.width - (Game.width * this.xscale)) / 2, (Game.height - (Game.height * this.yscale)) / 2)
            Game.b_ctx.scale(this.xscale, this.yscale)
        } else {
            Game.b_ctx.translate(this.position.x, this.position.y)
        }
        for (var i = 0, l = this.layers.length; i < l; i++) {
            this.layers[i].draw()
        }


        Game.b_ctx.restore()

    },

    /**
     * @description add a CG.Layer object to the layer array
     * @method addLayer
     * @param {layer} layer to add
     */
    addLayer: function (layer) {
        this.layers.push(layer)
        return this
    },

    /**
     * @description find CG.Layer by name
     * @method getLayerByName
     * @param {string} layername find layer by name
     * @return {false/layer}
     */
    getLayerByName: function (layername) {
        for (var i = 0, l = this.layers.length; i < l; i++) {
            if (this.layers[i].name == layername) {
                return this.layers[i]
            }
        }
        return false
    }
})


/**
 * @description
 *
 * CG.Layer is a child of CG.Screen and a container to collect/group sprites, buttons, menus, emitters and animations
 *
 * @class CG.Layer
 * @extends CG.Entity
 */
CG.Entity.extend('Layer', {
    /**
     * @constructor
     * @method init
     * @param layername {string} the name of the layer
     * @return {*}
     */
    init:function (layername) {
        this._super(layername)

        var self = this
        this.elements = []
        this.elementsToDelete = []
        return this
    },
    update:function () {
        if (this.visible == true) {
//            this.elements.forEach(function (element, index) {
//                element.update()
//                if (element.status == 1) {
//                    this.elementsToDelete.push(index)
//                }
//            }, this)

            for(var i = 0, l = this.elements.length; i < l; i++){
                this.elements[i].update()
                if(this.elements[i].status == 1){
                    this.elementsToDelete.push(this.elements[i])
                }
            }

            if (this.elementsToDelete.length > 0) {
                this._deleteElements()
            }
        }
    },
    draw:function () {
        if (this.visible == true) {

            //TODO ? place for CanvasRenderer ?

//            this.elements.forEach(function (element) {
//                element.draw()
//            }, this)


            for(var i = 0, l = this.elements.length; i < l; i++){
                this.elements[i].draw()
            }


        }
    },
    _deleteElements:function () {
        this.elementsToDelete.reverse()
        this.elementsToDelete.forEach(this._deleteElement, this)
        this.elementsToDelete = []
    },
    _deleteElement:function (elementToDelete) {
        this.elements.splice(elementToDelete, 1)
    },

    /**
     * @description Add new element to the layer. This could be a CG.Sprite, CG.Animation, CG.Button and so on. Every thing that has a update and draw method ;o)
     * @method addElement
     * @param {obj} element to add to elements array
     */
    addElement:function (element) {
        this.elements.push(element)
        return this
    },

    /**
     * @description Find element by name (the first one)
     * @method getElementByName
     * @param {string} elementname name of element to find in element array
     * @return {false/object} returns false or the searched object
     */
    getElementByName:function (elementname) {
        for (var i = 0, l = this.elements.length; i < l; i++) {
            if (this.elements[i].name == elementname) {
                return this.elements[i]
            }
        }
        return false
    },

    /**
     * @description Find elements by name (if they have the same name ;o)
     * @method getElementsByName
     * @param {string} elementname name of element to find in element array
     * @return {array} returns a array of objects
     */
    getElementsByName:function (elementname) {
        elements = []
        for (var i = 0, l = this.elements.length; i < l; i++) {
            if (this.elements[i].name == elementname) {
                elements.push(this.elements[i])
            }
        }
        return elements
    }
})



/**
 * @description
 *
 * CG.MapTileLayer
 *
 * @class CG.MapTileLayer
 * @extends Class
 */
CG.Class.extend('MapTileLayer', {
    /**
     * @constructor
     * @method init
     * @return {*}
     */
    init:function () {
        /**
         * @property width
         * @type {Number}
         */
        this.width = 0
        /**
         * @property height
         * @type {Number}
         */
        this.height = 0
        /**
         * @property visible
         * @type {Boolean}
         */
        this.visible = true
        /**
         * @property opacity
         * @type {Number}
         */
        this.opacity = 1
        /**
         * @property tiles
         * @type {Array}
         */
        this.tiles = []
        return this
    }
})


/**
 * @description
 *
 * CG.MapTileProperties
 *
 * @class CG.MapTileProperties
 * @extends Class
 */
CG.Class.extend('MapTileProperties', {
    /**
     * @method init
     * @constructor
     * @return {*}
     */
    init:function () {
        /**
         * @property animated
         * @type {Boolean}
         */
        this.animated = false
        /**
         * @property animDelay
         * @type {Number}
         */
        this.animDelay = 0
        /**
         * @property animDirection
         * @type {Number}
         */
        this.animDirection = 0 // >0 = forward, <0 = backward, 0 = paused
        /**
         * @property animNext
         * @type {Number}
         */
        this.animNext = 0
        /**
         * @property delayTimer
         * @type {Number}
         */
        this.delayTimer = 0
        return this
    }
})


/**
 * @description
 *
 * CG.MapPoint. Support now for name, gid and x/y-position values. No tilemap properties at the moment.
 *
 * @class CG.MapPoint
 * @extends CG.Class
 *
 */
CG.Class.extend('MapPoint', {
    /**
     * @method init
     * @constructor
     * @param position {point} position point
     * @param mapoffset {point} mapoffset reference to the current map position
     * @param name {string} name of the tile
     * @param gid {Number} gid number of tilemap editor
     * @return {*}
     */
    init:function (position, mapoffset, name, gid) {
        /**
         * @property initposition
         * @type {CG.Point}
         */
        this.initposition = position || new CG.Point(0, 0)
        /**
         * @property mapoffset
         * @type {CG.Point}
         */
        this.mapoffset = mapoffset || new CG.Point(0, 0)
        /**
         * @description gid
         * @type {Number}
         */
        this.gid = gid
        /**
         * @property name
         * @type {*}
         */
        this.name = name
        /**
         * @property position
         * @type {CG.Point}
         */
        this.position = new CG.Point(position.x, position.y) //for reference use
        return this
    },

    update:function () {
        this.position.x = this.initposition.x - this.mapoffset.x
        this.position.y = this.initposition.y - this.mapoffset.y
    }
})


/**
 * @description
 *
 * CG.MapArea. Support now for name and the bound values.
 *
 * @class CG.MapArea
 * @extends CG.Class
 */
CG.Class.extend('MapArea', {
    /**
     * @constructor
     * @method init
     * @param bound {CG.Bound} bound of area
     * @param mapoffset {CG.Point} mapoffset reference to the current map position
     * @param name {string} name of the group
     * @param type {false/string} type (a property) of area for collision detection or what ever ;o)
     * @return {*}
     */
    init:function (bound, mapoffset, name, type) {
        /**
         * @property initbound
         * @type {CG.Bound}
         */
        this.initbound = bound || new CG.Bound(0, 0, 0, 0)
        /**
         * @property mapoffset
         * @type {CG.Point}
         */
        this.mapoffset = mapoffset || new CG.Point(0, 0)
        /**
         * @property name
         * @type {String}
         */
        this.name = name
        /**
         * @property type
         * @type {String}
         */
        this.type = type || false       //false, inner or outer

        /**
         * @property bound
         * @type {CG.Bound}
         */
        this.bound = new CG.Bound(bound.x, bound.y, bound.width, bound.height)
        return this
    },

    update:function () {
        this.bound.x = this.initbound.x - this.mapoffset.x
        this.bound.y = this.initbound.y - this.mapoffset.y
    }
})


/**
 * @description
 *
 * CG.Map supports loading and rendering maps from the editor Tiled.
 * XML and JSON file types are supported.
 * XML => supported tiled encodings are csv and xml (see settings!). base64, base64(gzip) and base64(zlib) are not supported!
 *
 * Supported types of the object layer are:
 * - object/group (rectangle?)
 * - tile element, reference point is bottom/CG.LEFT
 *
 * These object layer types are used to generate Point and Bound objects and can be used to position sprites, what ever in the map.
 *
 * @class CG.Map
 * @extends CG.Entity
 *
 * TODO spacing and margin ?
 * TODO own buffer for drawing => split screen possible?
 * TODO update & draw method 50%
 *
 */
CG.Entity.extend('Map', {
    /**
     * @method init
     * @constructor
     * @param width {Number} width of the map
     * @param height {Number} height of the map
     * @param mapname {string} mapname
     * @return {*}
     */
    init:function (width, height, mapname) {
        this._super(mapname)

        /**
         * @property elements
         * @type {Array}
         */
        this.elements = [] //how handle elements in maps? experimental collision detection at the moment with only one
        //point and areas from tilemap editor
        //using as references for external objects in layers?
        //how to handle the relative position to the position of the map?

        /**
         * @property points
         * @type {Array}
         */
        this.points = [] // position points (tiles) of tilemap editor => position point and type?
        /**
         * @property areas
         * @type {Array}
         */
        this.areas = [] // group objects e.g. area for objects of tilemap editor => bound and type?
        /**
         * @property position
         * @type {CG.Point}
         */
        this.position = new CG.Point(0, 0) // needed as relative point for points and areas
        /**
         * @property changemap
         * @type {String}
         */
        this.changemap = ''
        /**
         * @description
         *
         * If set to true the map is being updated with method updateAnimation.
         * See also method description of updateAnimation!
         *
         * @property animated
         * @type {Boolean}
         */
        this.animated = false //performance eater if true ;o(
        /**
         * @property animDelayFactor
         * @type {Number}
         */
        this.animDelayFactor = 20
        /**
         * @property atlas
         * @type {Image}
         */
        this.atlas = new Image()
        /**
         * @property atlaswidth
         * @type {Number}
         */
        this.atlaswidth = 0
        /**
         * @property atlasheight
         * @type {Number}
         */
        this.atlasheight = 0
        /**
         * @property atlastranscol
         * @type {String}
         */
        this.atlastranscol = '' //
        //ejecta has no DOMParser!
        if (typeof(ejecta) == 'undefined') {
            /**
             * @property xml
             * @type {String}
             */
            this.xml = ''
            /**
             * @property parser
             * @type {DOMParser}
             */
            this.parser = new DOMParser()
            /**
             * @property xmlDoc
             * @type {String}
             */
            this.xmlDoc = ''
        }
        /**
         * @property json
         * @type {Object}
         */
        this.json = {}
        /**
         * @description
         *
         * The tiled layer are parsed into separate layers
         *
         * @property layers
         * @type {Array}
         */
        this.layers = [] //can contain maptilelayer or objectlayer
        /**
         * @description
         *
         * Defines the layer to draw:
         * all - for all layers
         * name - the name of layer to draw
         * index - array index of layer
         *
         * @property renderlayer
         * @type {String}
         */
        this.renderlayer = 'all' //render layer: all for all layers, name of layer or array index for example 0 ;o)
        /**
         * @property tileproperties
         * @type {Array}
         */
        this.tileproperties = [] //properties of the tiles
        /**
         * @property orientation
         * @type {String}
         */
        this.orientation = ''
        /**
         * @property width
         * @type {Number}
         */
        this.width = 0
        /**
         * @property height
         * @type {Number}
         */
        this.height = 0
        /**
         * @property tilewidth
         * @type {Number}
         */
        this.tilewidth = 0
        /**
         * @property tileheight
         * @type {Number}
         */
        this.tileheight = 0
        /**
         * @property tileset
         * @type {Object}
         */
        this.tileset = {
            tilewidth:0,
            tileheight:0,
            offsetx:0,
            offsety:0,
            spacing:0,
            margin:0
        }
        /**
         * @property xspeed
         * @type {Number}
         */
        this.xspeed = 0
        /**
         * @property yspeed
         * @type {Number}
         */
        this.yspeed = 0
        /**
         * @property xscale
         * @type {Number}
         */
        this.xscale = 1
        /**
         * @property yscale
         * @type {Number}
         */
        this.yscale = 1
        /**
         * @property alpha
         * @type {Number}
         */
        this.alpha = 1
        /**
         * @property wrapX
         * @deprecated
         * @type {Boolean}
         */
        this.wrapX = false //stuff from diddy?
        /**
         * @property wrapY
         * @deprecated
         * @type {Boolean}
         */
        this.wrapY = false //stuff from diddy?
        /**
         * @property layertocheck
         * @type {Number}
         */
        this.layertocheck = 0 //as default use layer 0 for collision detection
        return this
    },
    /**
     * @description
     *
     * Load and parse an xml tilemap file. It can handle the tiled XML and CSV format.
     * All other formats are not supported!
     *
     * @method loadMapXml
     * @param xmlfile {string/object} xmlfile path or mediaasset object with data of tiled map xml
     */
    loadMapXml:function (xmlfile) {
        this.changemap = ''
        this.animated = false
        this.layers = []

        //from asset
        if (typeof xmlfile == 'string') {
            this.xml = loadString(xmlfile)
        } else {
            this.xml = xmlfile.data
        }
        this.removeJsonData()

        this.xmlDoc = this.parser.parseFromString(this.xml, 'text/xml')

        //get map
        var tilemap = map.xmlDoc.getElementsByTagName('map')[0]
        this.orientation = tilemap.getAttribute('orientation')
        this.width = parseInt(tilemap.getAttribute('width'))
        this.height = parseInt(tilemap.getAttribute('height'))
        this.tilewidth = parseInt(tilemap.getAttribute('tilewidth'))
        this.tileheight = parseInt(tilemap.getAttribute('tileheight'))

        var childcount = tilemap.childElementCount

        //tilemap.firstElementChild.nextElementSibling.nextElementSibling
        var element = tilemap.firstElementChild
        for (i = 0; i < childcount; i++) {
            console.log('>' + element.nodeName)
            switch (element.nodeName) {
                case 'tileset':
                    //read tileset settings
                    //only one tileset for the moment
                    this.tileset.tilewidth = parseInt(element.getAttribute('tilewidth'))
                    this.tileset.tileheight = parseInt(element.getAttribute('tileheight'))
                    if (element.getAttribute('spacing')) {
                        this.tileset.spacing = parseInt(element.getAttribute('spacing'))
                    }
                    if (element.getAttribute('margin')) {
                        this.tileset.margin = parseInt(element.getAttribute('margin'))
                    }
                    if (element.getElementsByTagName('tileoffset')[0]) {
                        this.tileset.offsetx = parseInt(element.getElementsByTagName('tileoffset')[0].getAttribute('x'))
                        this.tileset.offsety = parseInt(element.getElementsByTagName('tileoffset')[0].getAttribute('y'))
                    }
                    var image = element.getElementsByTagName('image')[0]
                    this.atlas.src = 'media/map/' + image.getAttribute('source')

                    this.atlaswidth = parseInt(image.getAttribute('width'))
                    this.atlasheight = parseInt(image.getAttribute('height'))
                    this.atlastranscol = image.getAttribute('trans')

                    break
                case 'layer':
                    //get tilemap data of layer
                    var tl = new CG.MapTileLayer()
                    data = element.getElementsByTagName('data')[0]

                    if (data.getAttribute('encoding') == 'csv') {
                        tl.tiles = data.textContent.replace(/(\r\n|\n|\r)/gm, '').split(',')
                        console.log('map encoding csv [layer ' + i + ']')
                    } else if (data.getAttribute('encoding') == 'base64' && data.getAttribute('compression') == 'gzip') {
                        throw 'base64 gzip compressed map format not supported at the moment'
                    } else if (data.getAttribute('encoding') == 'base64' && data.getAttribute('compression') == 'zlib') {
                        throw 'base64 zlib compressed map format not supported at the moment'
                    } else if (data.getAttribute('encoding') == 'base64') {
                        throw 'base64 map format not supported at the moment'
                    } else {
                        console.log('map encoding xml [layer ' + i + ']')
                        var tiles = element.getElementsByTagName('tile')
                        for (x in tiles) {
                            if (x < tiles.length) {
                                tl.tiles[x] = parseInt(tiles[x].getAttribute('gid'))
                            }
                        }
                    }

                    tl.name = element.getAttribute('name')
                    tl.width = parseInt(element.getAttribute('width'))
                    tl.height = parseInt(element.getAttribute('height'))
                    if (element.getAttribute('opacity')) {
                        tl.opacity = parseFloat(element.getAttribute('opacity'))
                    }
                    if (element.getAttribute('visible') === '0') {
                        tl.visible = false
                    }
                    this.layers.push(tl)
                    break
                case 'objectgroup':
                    //get tilemap data of grouplayer
                    console.log('grouplayer found')
                    var objects = element.getElementsByTagName('object')
                    for (o in objects) {
                        if (o < objects.length) {
                            var obj = objects[o]
                            var name = obj.getAttribute('name')
                            if (obj.getAttribute('gid')) {
                                //tile as object/point
                                this.points.push(
                                    new CG.MapPoint(
                                        new CG.Point(
                                            parseInt(obj.getAttribute('x')), parseInt(obj.getAttribute('y'))), this.position, obj.getAttribute('name'), parseInt(obj.getAttribute('gid'))))
                                console.log('tile as oject found: ' + name)
                                console.log(obj)
                            } else if (obj.getAttribute('width')) {
                                type = false
                                properties = obj.getElementsByTagName('property')
                                console.log(properties.length)
                                for (var p = 0, l = properties.length; p < l; p++) {
                                    if (properties[p].getAttribute('name') == 'type') {
                                        type = properties[p].getAttribute('value')
                                    }
                                }

                                //object group
                                this.areas.push(
                                    new CG.MapArea(
                                        new CG.Bound(
                                            parseInt(obj.getAttribute('x')), parseInt(obj.getAttribute('y')), parseInt(obj.getAttribute('width')), parseInt(obj.getAttribute('height'))), this.position, obj.getAttribute('name'), type))
                                console.log('group object found: ' + name)
                                console.log(obj)
                            } else if (obj.getElementsByTagName('polygon').length > 0) {
                                console.log('polygon found: ' + name)
                            } else if (obj.getElementsByTagName('polyline').length > 0) {
                                console.log('polyline found: ' + name)
                            }
                        }
                    }
                    break

            }
            element = element.nextElementSibling
        }


        //get tile properties
        this.tileproperties = Array(parseInt((this.atlaswidth / this.tilewidth)) * parseInt((this.atlasheight / this.tileheight)))
        var tiles = map.xmlDoc.getElementsByTagName('tileset')[0].getElementsByTagName('tile')
        var time = new Date().getTime()
        for (i in tiles) {
            var tprop = new CG.MapTileProperties()
            var tile = tiles[i]

            if (i < this.tileproperties.length) {
                var id = tile.getAttribute('id')
                var properties = tile.getElementsByTagName('properties')[0].getElementsByTagName('property')
                for (p in properties) {
                    if (p < properties.length) {
                        var tp = properties[p]
                        var elem = tp.getAttribute('name')
                        var value = tp.getAttribute('value')
                        if (elem == 'name') {
                            tprop.name = value
                        } else if (elem == 'anim_delay') {
                            tprop.animDelay = parseInt(value)
                            tprop.delayTimer = time
                            this.animated = true
                        } else if (elem == 'anim_direction') {
                            tprop.animDirection = parseInt(value)
                        } else if (elem == 'anim_next') {
                            tprop.animNext = parseInt(value)
                            tprop.animated = true
                        }
                    }
                }
                this.tileproperties[id] = tprop
            }
        }
        return this
    },

    /**
     * @description
     *
     * Load and parse an tilemap json file. Use the tiled json export.
     * Hopefully the json format has the same functionality as the xml loader ;o)
     *
     * @method loadMapJson
     * @param jsonfile {string/object} jsonfile path or mediaasset object with data of tiled map xml
     */
    loadMapJson:function (jsonfile) {
        this.changemap = ''
        this.animated = false
        this.layers = []

        //from asset
        if (typeof jsonfile == 'string') {
            this.json = JSON.parse(loadString(jsonfile))
        } else {
            this.json = jsonfile.data
        }

        this.removeXmlData()

        //get map
        this.orientation = this.json.orientation
        this.width = this.json.width
        this.height = this.json.height
        this.tilewidth = this.json.tilewidth
        this.tileheight = this.json.tileheight

        //tilesets
        for (i = 0, l = this.json.layers.length; i < l; i++) {
            switch (this.json.layers[i].type) {
                case 'tilelayer':
                    //get tilemap data of layer
                    var tl = new CG.MapTileLayer()
                    tl.tiles = this.json.layers[i].data
                    tl.name = this.json.layers[i].name
                    tl.width = this.json.layers[i].width
                    tl.height = this.json.layers[i].height
                    tl.opacity = this.json.layers[i].opacity
                    tl.visible = this.json.layers[i].visible
                    this.layers.push(tl)
                    break
                case 'objectgroup':
                    //get tilemap data of grouplayer
                    console.log('grouplayer found')
                    var objects = this.json.layers[i].objects
                    for (o in objects) {
                        if (o < objects.length) {
                            var obj = objects[o]
                            var name = obj.name
                            if (obj.gid) {
                                //tile as object/point
                                this.points.push(
                                    new CG.MapPoint(
                                        new CG.Point(
                                            parseInt(obj.x), parseInt(obj.y)), this.position, obj.name, parseInt(obj.gid)))

                                console.log('tile as oject found: ' + name)
                                console.log(obj)
                            } else if (obj.width) {
                                //object group
                                this.areas.push(
                                    new CG.MapArea(
                                        new CG.Bound(
                                            parseInt(obj.x), parseInt(obj.y), parseInt(obj.width), parseInt(obj.height)), this.position, obj.name, obj.properties.type))

                                console.log('group object found: ' + name)
                                console.log(obj)
                            } else if (obj.polygon) {
                                console.log('polygon found: ' + name)
                            } else if (obj.polyline) {
                                console.log('polyline found: ' + name)
                            }
                        }
                    }
                    break

            }
        }


        //get tile properties
        this.atlas.src = 'media/map/' + this.json.tilesets[0].image

        this.atlaswidth = this.json.tilesets[0].imagewidth
        this.atlasheight = this.json.tilesets[0].imageheight
        this.atlastranscol = this.json.tilesets[0].transparentcolor

        this.tileproperties = Array(parseInt((this.atlaswidth / this.tilewidth)) * parseInt((this.atlasheight / this.tileheight)))
        var tiles = this.json.tilesets[0].tileproperties

        var time = new Date().getTime()

        for (id in tiles) {
            var tprop = new CG.MapTileProperties()
            var tile = tiles[id]
            tprop.name = tile.name
            tprop.animDelay = parseInt(tile.anim_delay)
            tprop.delayTimer = (tprop.animDelay > 0) ? time : 0
            tprop.animated = (tprop.animDelay > 0) ? true : false
            tprop.animNext = parseInt(tile.anim_next)
            if (tprop.animDelay > 0) {
                this.animated = true
            }
            tprop.animDirection = parseInt(tile.anim_direction)
            this.tileproperties[id] = tprop

        }
        return this
    },


    /**
     * @description
     *
     * This is the main method for map drawing. Orthogonal maps works very well. Isometric maps are not well implemented yet.
     *
     * @method drawMap
     *
     * @param sx {Number} sx top left coord for canvas drawing
     * @param sy {Number} sy top left coord for canvas drawing
     * @param bx {Number} bx top left x coord of bound in tilemap
     * @param by {Number} by top left y coord of bound in tilemap
     * @param bw {Number} bw width of bound in tilemap
     * @param bh {Number} bh height of bound in tilemap
     * @param callback {callback} callback for collision handling - callback(obj,maptileproperties)
     */
    drawMap:function (sx, sy, bx, by, bw, bh, callback) {
        this.position.x = bx
        this.position.y = by

        this.bx = bx || this.bx || 0
        this.by = by || this.by || 0
        this.bw = bw || Game.bound.width
        this.bh = bh || Game.bound.height
        this.sx = sx || this.sx || 0
        this.sy = sy || this.sy || 0
        this.callback = callback || false

        //update all points an areas
        this.updatePointsAndAreas()

        if (this.changemap != '') {
            this.loadMap(this.changemap)
        }
        if (this.visible) {
            this.updateAnimation()
            if (this.layers.length > 0) {
                for (var layer = 0, l = this.layers.length; layer < l; layer++) {
                    var tl = this.layers[layer]
                    //render control, render by name, layer number or 'all''
                    if (this.renderlayer == tl.name || this.renderlayer == layer || this.renderlayer == 'all') {
                        // MAP ORTHOGONAL
                        if (this.orientation == 'orthogonal' && tl.visible == true) {
                            modx = (this.bx * this.xscale) % this.tilewidth
                            mody = (this.by * this.yscale) % this.tileheight
                            y = this.by
                            my = Math.floor(parseFloat(this.by) / parseFloat(this.tileheight)) >> 0

                            var tmpy = (this.by + this.bh + this.tileheight)
                            while (y < tmpy) {
                                x = this.bx //- this.tilewidth
                                mx = Math.floor(parseFloat(this.bx) / parseFloat(this.tilewidth)) >> 0

                                var tmpx = (this.bx + this.bw + this.tilewidth)
                                while (x < tmpx) {
                                    if ((this.wrapX || (mx >= 0 && mx < this.width)) && (this.wrapY || (my >= 0 && my < this.height))) {
                                        mx2 = mx
                                        my2 = my

                                        while (mx2 < 0) {
                                            mx2 += this.width
                                        }

                                        while (mx2 >= this.width) {
                                            mx2 -= this.width
                                        }

                                        while (my2 < 0) {
                                            my2 += this.height
                                        }

                                        while (my2 >= this.height) {
                                            my2 -= this.height
                                        }

                                        gid = tl.tiles[mx2 + my2 * tl.width] - 1

                                        if (gid >= 0) {
                                            if (modx < 0) {
                                                modx += this.tilewidth
                                            }
                                            if (mody < 0) {
                                                mody += this.tileheight
                                            }
                                            rx = x - modx - this.bx
                                            ry = y - mody - this.by


                                            //time for collision detection?
                                            //limit to specific tilemap layer?
                                            //collision depending on bounds and direction (xspeed/yspeed)?
                                            //include some layer functionality here and render some sprites between map layers?
                                            if (this.elements.length > 0 && this.layertocheck == l) {
                                                for (var o = 0, l = this.elements.length; o < l; o++) {
                                                    if (this.checkMapCollision(this.elements[0], rx, ry)) {
                                                        this.callback(this.elements[o], this.tileproperties[gid])
                                                    }
                                                }
                                            }


                                            //margin/spacing?
                                            cx = (gid % (this.atlaswidth / this.tilewidth)) * this.tilewidth
                                            cy = Math.floor(this.tilewidth * gid / this.atlaswidth) * this.tileheight

                                            Game.b_ctx.save()
                                            Game.b_ctx.globalAlpha = this.layers[layer].opacity
                                            Game.b_ctx.translate(rx, ry)
                                            try {
                                                Game.b_ctx.drawImage(this.atlas, cx, cy, this.tilewidth, this.tileheight, this.sx, this.sy, this.tilewidth * this.xscale, this.tileheight * this.yscale)
                                            } catch (e) {
                                            }
                                            Game.b_ctx.restore()
                                        }
                                    }
                                    x = x + this.tilewidth
                                    mx += 1
                                }
                                y = y + this.tileheight
                                my += 1
                            }
                        }
                        // MAP ISOMETRIC
                        else if (this.orientation == 'isometric') {
                            var t = tl.width + tl.height
                            for (var y = 0; y < t; y++) {
                                var ry = y
                                var rx = 0
                                while (ry >= tl.height) {
                                    ry -= 1
                                    rx += 1
                                }


                                while (ry >= 0 && rx < tl.width) {
                                    var gid = tl.tiles[rx + ry * tl.width]
                                    var xpos = (rx - ry - 1) * this.tilewidth / 2 - bx
                                    var ypos = (rx + ry + 1) * this.tileheight / 2 - by
                                    if (xpos > -this.tileset.tilewidth && xpos < bw && ypos > -this.tileset.tileheight && ypos < bh) {
                                        if (gid > 0) {
                                            cx = ((gid - 1) % (this.atlaswidth / this.tilewidth)) * this.tilewidth
                                            cy = Math.floor(this.tilewidth * (gid - 1) / this.atlaswidth) * this.tileset.tileheight
                                            Game.b_ctx.save()
                                            Game.b_ctx.globalAlpha = this.layers[layer].opacity
                                            Game.b_ctx.translate(xpos, ypos)
                                            try {
                                                Game.b_ctx.drawImage(this.atlas, cx, cy, this.tilewidth, this.tileset.tileheight, 0, 0, this.tilewidth * this.xscale, this.tileset.tileheight * this.yscale)
                                            } catch (e) {

                                            }
                                            Game.b_ctx.restore()
                                        }
                                    }
                                    ry -= 1
                                    rx += 1
                                }
                            }
                        }
                    }
                    //                else {
                    //                    throw 'unknown orientation: ' + this.orientation
                    //                }
                }
            }
        }
    },

    /**
     * @description
     *
     * Update all areas and points elements.
     *
     * @method updatePointsAndAreas
     */
    updatePointsAndAreas:function () {
        this.points.forEach(function (point, index) {
            point.update()
        }, this)
        this.areas.forEach(function (area, index) {
            area.update()
        }, this)
    },


    /**
     * @description
     *
     * Get all point(s) with the given name in the points
     *
     * @method getPointsByName
     *
     * @param name {string} name of the points to return
     * @return {false/array} returns false or an array with point(s)
     */
    getPointsByName:function (name) {
        points = []
        for (var i = 0, l = this.points.length; i < l; i++) {
            if (this.points[i].name === name) {
                points.push(this.points[i])
            }
        }
        if (points.length > 0) {
            return points
        }
        return false
    },

    /**
     * @description
     *
     * Get all areas with the given name
     *
     * @method getAreasByName
     *
     * @param name {string} name of the area(s) to return
     * @return {false/array} returns false or an array with area(s)
     */
    getAreasByName:function (name) {
        areas = []
        for (var i = 0, l = this.areas.length; i < l; i++) {
            if (this.areas[i].name === name) {
                areas.push(this.areas[i])
            }
        }
        if (areas.length > 0) {
            return areas
        }
        return false
    },


    /**
     * @description
     *
     * Defines layer drawing, See property options
     *
     * @method setLayerToRender
     *
     * @param mixed {mixed} mixed define the map layer(s) to render 'all' (string) for all layers, array index (integer) for layer to render or 'name' (string) of layer to render'
     */
    setLayerToRender:function (mixed) {
        this.renderlayer = mixed
        return this
    },

    /**
     * @description
     *
     * The update method is not complete yet and only experimental.
     * At the final stage the methods updateAnimation and updatePointsAndAreas have to be called from here!
     * Then also a map class can be added to a layer as an element for auto update/draw from Game.director!
     *
     * @method update
     */
    update:function () {
        //TODO automatic movement of map or other stuff?
        this.bx += this.xspeed
        this.by += this.yspeed
        if (this.getBounds().width - Game.bound.width < this.bx) {
            this.xspeed = this.xspeed * -1
        }
        if (this.bx < 0) {
            this.xspeed = this.xspeed * -1
        }
        if (this.getBounds().height - Game.bound.height < this.by) {
            this.yspeed = this.yspeed * -1
        }
        if (this.by < 0) {
            this.yspeed = this.yspeed * -1
        }
        return this
    },

    /**
     * yust calls drawMap ;o)
     */
    draw:function () {
        this.drawMap(this.bx, this.by, this.bw, this.bh, this.sx, this.sy, this.callback)
        return this
    },

    /**
     * @description
     *
     * Get the bounds of the map
     *
     * @method getBounds
     */
    getBounds:function () {
        return {
            width:this.width * this.tilewidth,
            height:this.height * this.tileheight
        }
    },

    /**
     * @description
     *
     * Updates all tilemap properties of the map.
     *
     * Supported custom tiled map properties for now are (see also tilemap examples):
     * anim_delay       => time to used to display an switch to next tile
     * anim_direction   => direction for next tile 1 = jump forward, -1 = jump back
     * anim_next        => defines the offset
     *
     * With this tile properties it is possible to define tilemap animations.
     * These must be defined in the tilemap property window with key/value pairs
     *
     * @method updateAnimation
     */
    updateAnimation:function () {
        // update if map is visible
        if (this.visible && this.animated) {
            if (this.layers.length > 0) {
                for (var layer = 0, l = this.layers.length; layer < l; layer++) {
                    var newtime = new Date().getTime()
                    for (t = 0; t < this.layers[layer].tiles.length; t++) {
                        var tile = this.layers[layer].tiles[t]
                        if (tile > 0) {
                            try {
                                var tprop = this.tileproperties[tile - 1]
                                if (tprop.animated && tprop.animDirection != 0) {
                                    if (newtime > (tprop.delayTimer + (tprop.animDelay / this.animDelayFactor))) {
                                        switch (tprop.animDirection) {
                                            case 1:
                                                this.layers[layer].tiles[t] += tprop.animNext
                                                this.tileproperties[tile - 1 + tprop.animNext].delayTimer = newtime
                                                break
                                            case -1:
                                                this.layers[layer].tiles[t] -= tprop.animNext
                                                this.tileproperties[tile - 1 - tprop.animNext].delayTimer = newtime
                                                break
                                            default:
                                                break
                                        }
                                    }
                                }
                            } catch (e) {

                            }
                        }
                    }
                }
            }
        }
    },

    /**
     * @description
     *
     * Adds a object to the element array, used at the moment for collision detection to tilemap.
     *
     * @method addElement
     *
     * @param {obj} element to to add to elements array
     */
    addElement:function (element) {
        this.elements.push(element)
        return this
    },

    /**
     * @description
     * Checks if the attached element collides with an tile of the tilemap
     *
     * @method checkMapCollision
     *
     * @param {obj} element to check for
     * @param {Number} rx current rx of rendermap method
     * @param {Number} ry current ry of rendermap method
     *
     * @return {boolean} returns true or false
     */
    checkMapCollision:function (element, rx, ry) {
        //TODO return detailed collision object or offsets instead of true?
        if (element.boundingradius > 0) {
            //circular collision
            xr = element.boundingradius / 2 * element.xscale
            yr = element.boundingradius / 2 * element.yscale
            if (element.position.x + xr >= rx && element.position.x - xr <= rx + this.tilewidth && element.position.y + yr >= ry && element.position.y - yr <= ry + this.tileheight) {
                return true
            }
        } else {
            //bounding collision
            xw = element.width / 2 * element.xscale
            yh = element.height / 2 * element.yscale
            if (element.position.x + xw >= rx && element.position.x - xw <= rx + this.tilewidth && element.position.y + yh >= ry && element.position.y - yh <= ry + this.tileheight) {
                return true
            }
        }
        return false
    },

    /**
     * @description
     *
     * Checks if a external object(s) collides with the areas of the tiled map.
     * This can be elements from an layer or the map itself.
     *
     * @param {Array} objarray to check for a areas collision
     * @param {Callback} callback what should happen
     */
    checkElementsToAreasCollision:function (objarray, callback) {
        for (var o = 0, ol = objarray.length; o < ol; o++) {

            obj = objarray[o].checkCollision(this.areas, callback)
        }
        return this
    },

    /**
     * @description removes the json data of the map object
     * @method removeJsonData
     */
    removeJsonData:function () {
        this.json = {}
        return this
    },
    /**
     * @description removes the xml data of the map object
     * @method removeXmlData
     */
    removeXmlData:function () {
        this.xml = ''
        //this.parser = new DOMParser()
        this.xmlDoc = ''
        return this
    }
})


/**
 * @description
 *
 * CG.Sequence container to collect/group CG.Translation objects
 *
 * @class CG.Sequence
 * @extends Entity
 */
CG.Entity.extend('Sequence', {
    /**
     * @constructor
     * @method init
     * @param sequencename
     * @return {*}
     */
    init: function (sequencename) {
        this._super(sequencename)
        /**
         * @property current
         * @type {Number}
         */
        this.current = 0
        /**
         * @property loop
         * @type {Boolean}
         */
        this.loop = false
        /**
         * @property translations
         * @type {Array}
         */
        this.translations = []
        return this
    },
    /**
     * @description add a translation object to the sequence array
     * @method addTranslation
     * @param translationobj {translation} the translation object to add
     * @return {*}
     */
    addTranslation: function (translationobj) {
        this.translations.push(translationobj)
        return this
    },
    update: function (callback) {
        if (this.current < this.translations.length) {
            if (this.translations[this.current].finished === false) {
                this.translations[this.current].update()
            } else {
                this.current += 1
            }
        } else {
            if (this.loop) {
                this.reset()
            } else {
                //callback?
            }
        }
    },
    draw: function () {

    },
    reset: function () {
        for (var i = 0, l = this.translations.length; i < l; i++) {
            this.translations[i].reset()
        }
        this.current = 0
        return this
    }
})


/**
 * @description
 *
 * CG.Translate moving a object
 *
 * @class CG.Translate
 * @extends CG.Entity
 */
CG.Entity.extend('Translate', {
    /**
     * @init
     * @constructor
     * @return {*}
     */
    init:function () {
        this._super()
        /**
         * @property type
         * @type {String}
         */
        this.type = ''
        /**
         * @property tx
         * @type {Number}
         */
        this.tx = 0 //translated x value for the object
        /**
         * @property ty
         * @type {Number}
         */
        this.ty = 0 //translated y value for the object
        /**
         * @properzty x1
         * @type {Number}
         */
        this.x1 = 0
        /**
         * @property y1
         * @type {Number}
         */
        this.y1 = 0
        /**
         * @property x2
         * @type {Number}
         */
        this.x2 = 0
        /**
         * @property y2
         * @type {Number}
         */
        this.y2 = 0
        /**
         * @property bx
         * @type {Number}
         */
        this.bx = 0 //bÃ©zier x
        /**
         * @property by
         * @type {Number}
         */
        this.by = 0 //bÃ©zier y
        /**
         * @property theobj
         * @type {Object}
         */
        this.theobj = {}
        /**
         * @property r1
         * @type {Number}
         */
        this.r1 = 0
        /**
         * @property r2
         * @type {Number}
         */
        this.r2 = 0
        /**
         * @property startangle
         * @type {Number}
         */
        this.startangle = 0
        /**
         * @property angle
         * @type {Number}
         */
        this.angle = 0
        /**
         * @property speed
         * @type {Number}
         */
        this.speed = 0
        /**
         * @property steps
         * @type {Number}
         */
        this.steps = 0
        /**
         * @property step
         * @type {Number}
         */
        this.step = 0
        /**
         * @property positions
         * @type {Array}
         */
        this.positions = []
        /**
         * @property finished
         * @type {Boolean}
         */
        this.finished = false
        return this
    },
    /**
     * @method initTween
     *
     * @param obj {Object} object to move
     * @param steps {Number} steps of tween
     * @param startpoint {point} startpoint of tween
     * @param endpoint {point} endpoint of tween
     * @return {this}
     */
    initTween:function (obj, steps, startpoint, endpoint) {
        this.type = 'tween'
        this.theobj = obj
        this.steps = steps
        this.x1 = startpoint.x
        this.y1 = startpoint.y
        this.x2 = endpoint.x
        this.y2 = endpoint.y

        var xstep = (this.x2 - this.x1) / this.steps
        var ystep = (this.y2 - this.y1) / this.steps
        var tx = this.x1 >> 0   //replace parseInt
        var ty = this.y1 >> 0   //replace parseInt
        //precalc positions and push to array
        for (var i = 0; i <= this.steps; i++) {
            this.positions.push(new CG.Point(tx, ty))
            tx += xstep
            ty += ystep
        }
        return this
    },

    /**
     * @method initOval
     * @param obj {Object} obj object to move
     * @param centerpoint {point} centerpoint
     * @param radius1 {Number} radius1
     * @param radius2 {Number} radius2
     * @param startangle {Number} startangle
     * @param rotation {Number} rotation
     * @return {this}
     */
    initOval:function (obj, centerpoint, radius1, radius2, startangle, rotation) {
        this.type = 'oval'
        this.theobj = obj
        this.x1 = centerpoint.x
        this.y1 = centerpoint.y
        this.r1 = radius1
        this.r2 = radius2
        this.startangle = startangle
        this.speed = rotation

        return this
    },

    /**
     * @description initBezier
     * http://13thparallel.com/archive/bezier-curves/
     *
     * @method initBezier
     *
     * @param obj {Object} obj object to move
     * @param steps {Number} steps of bÃ©zier curve
     * @param startpoint {CG.Point} startpoint startpoint of bÃ©zier
     * @param endpoint {CG.Point} endpoint endpoint of bÃ©zier
     * @param control1 {CG.Point} control1 point for bÃ©zier calculation (optional)
     * @param control2 {CG.Point} control2 point for bÃ©zier calculation (optional)
     * @return {this}
     */
    initBezier:function (obj, steps, startpoint, endpoint, control1, control2) {
        this.type = 'bezier'
        this.theobj = obj  //first argument is always the object to handle
        this.steps = steps
        this.start = endpoint
        this.end = startpoint

        if (this.control2 == 'undefined' && this.control1 == 'undefined') {
            this.control2 = new CG.Point(this.start.x + 3 * (this.end.x - this.start.x) / 4, this.start.y + 3 * (this.end.y - this.start.y) / 4);
        } else {
            this.control2 = control2 || control1
        }
        this.control1 = control1 || new CG.Point(this.start.x + (this.end.x - this.start.x) / 4, this.start.y + (this.end.y - this.start.y) / 4)

        b1 = function (t) {
            return (t * t * t)
        }
        b2 = function (t) {
            return (3 * t * t * (1 - t))
        }
        b3 = function (t) {
            return (3 * t * (1 - t) * (1 - t))
        }
        b4 = function (t) {
            return ((1 - t) * (1 - t) * (1 - t))
        }

        for (var i = 0; i <= this.steps; i++) {
            percent = (1 / this.steps) * i;
            var pos = new CG.Point();
            pos.x = this.start.x * b1(percent) + this.control1.x * b2(percent) + this.control2.x * b3(percent) + this.end.x * b4(percent)
            pos.y = this.start.y * b1(percent) + this.control1.y * b2(percent) + this.control2.y * b3(percent) + this.end.y * b4(percent)
            this.positions.push(pos)
        }

        return this
    },
    draw:function () {
    },
    update:function () {
        var obj = this.theobj
        switch (this.type) {
            case 'bezier':
            case 'tween':
                if (this.step < this.steps) {
                    obj.position.x = obj.position._x = this.positions[this.step].x
                    obj.position.y = obj.position._y = this.positions[this.step].y
                    this.step += 1
                } else {
                    this.finished = true
                }
                break
            case 'oval':
                var rad = this.startangle * CG.Const_PI_180
                this.tx = this.x1 - (this.r1 * Math.cos(rad))
                this.ty = this.y1 - (this.r2 * Math.sin(rad))
                this.startangle += this.speed

                if (this.startangle > 360) {
                    this.startangle = 0 + (this.startangle - 360)
                }

                obj.position.x = obj.position._x = this.tx >> 0  //replace parseInt
                obj.position.y = obj.position._y = this.ty >> 0  //replace parseInt
                break
            default:
                break
        }
    },
    draw:function () {

    },
    reset:function () {
        this.step = 0
        this.finished = false
    }

})

/*
 function drawBezier() {
 var C1 = new coord(objDragger[0].x(), objDragger[0].y());
 var C2 = new coord(objDragger[1].x(), objDragger[1].y());
 var C3 = new coord(objDragger[2].x(), objDragger[2].y());
 var C4 = new coord(objDragger[3].x(), objDragger[3].y());

 for(var i=0; i<numPixels; i++) {
 percent = (1/numPixels) * i;
 var pos = getBezier(percent, C1, C2, C3, C4);
 objPixels[i].moveTo(pos.x, pos.y);
 }
 }


 //====================================================================================
 // getBezier() - calculates a given position along a Bezier curve specified by 2,3 or
 //               4 control points.
 //====================================================================================

 //Bezier functions:
 B1 = function(t) { return (t*t*t); }
 B2 = function(t) { return (3*t*t*(1-t)); }
 B3 = function(t) { return (3*t*(1-t)*(1-t)); }
 B4 = function(t) { return ((1-t)*(1-t)*(1-t)); }

 //coordinate constructor
 coord = function (x,y) { if(!x) var x=0; if(!y) var y=0; return {x: x, y: y}; }

 //Finds the coordinates of a point at a certain stage through a bezier curve
 function getBezier(percent,startPos,endPos,control1,control2) {
 //if there aren't any extra control points plot a straight line, if there is only 1
 //make 2nd point same as 1st

 if(!control2 && !control1) var control2 = new coord(startPos.x + 3*(endPos.x-startPos.x)/4, startPos.y + 3*(endPos.y-startPos.y)/4);
 if(!control2) var control2 = control1;
 if(!control1) var control1 = new coord(startPos.x + (endPos.x-startPos.x)/4, startPos.y + (endPos.y-startPos.y)/4);

 var pos = new coord();
 pos.x = startPos.x * B1(percent) + control1.x * B2(percent) + control2.x * B3(percent) + endPos.x * B4(percent);
 pos.y = startPos.y * B1(percent) + control1.y * B2(percent) + control2.y * B3(percent) + endPos.y * B4(percent);

 return pos;
 }
 */


/**
 * @description
 *
 * CG.Morph to manipulate objects in size and so on
 *
 * @class CG.Morph
 * @extends CG.Entity
 *
 */
CG.Entity.extend('Morph', {
    /**
     * @method init
     * @constructor
     * @param mode {string} mode type of the morph object
     * @param min {Number} min min value
     * @param max {Number} max max value
     * @param speed {Number} speed speed value
     */
    init:function (mode, min, max, speed) {
        this.mode = mode
        this.min = min
        this.max = max
        this.speed = speed
        this.angle = 0
        this.rad = this.max - this.min
        this.val = 0
    },
    update:function () {
        switch (this.mode) {
            case 'sinus':
                var rad = this.angle * CG.Const_PI_180
                this.val = this.rad * Math.sin(rad)
                if (this.val < 0) {
                    this.val = this.val * -1
                }
                this.angle += this.speed

                if (this.angle > 360) {
                    this.angle = 0 + (this.angle - 360)
                }
                break
        }
        return this
    },
    draw:function () {

    },
    /**
     * @method getVal
     *
     * @return {float}
     */
    getVal:function () {
        return this.val
    }
})



/**
 * @description
 *
 * CG.Particle
 *
 * @class CG.Particle
 * @extends CG.Sprite
 *
 */

CG.Sprite.extend('Particle', {
    /**
     * @constructor
     * @method init
     * @param image {mixed} image imgpath, image object or tpimage object to use for the particle
     */
    init:function (image) {
        this._super(image, new CG.Point(0, 0))
        /**
         * @property lifetime
         * @type {Number}
         */
        this.lifetime = 100
        /**
         * @property currtime
         * @type {Number}
         */
        this.currtime = this.lifetime
        /**
         * @property aging
         * @type {Number}
         */
        this.aging = 1
        /**
         * @property fadeout
         * @type {Boolean}
         */
        this.fadeout = false
        /**
         * @property alpha
         * @type {Number}
         */
        this.alpha = 1
        /**
         * @property gravity
         * @type {Number}
         */
        this.gravity = 0
    },
    update:function () {
        if (this.visible) {
            if (this.fadeout) {
                this.alpha = this.currtime / this.lifetime
                if (this.alpha <= 0) {
                    this.visible = false
                }
            }
            this.currtime -= this.aging
            if (this.currtime < 0) {
                this.visible = false
            }

            this.position.x += this.xspeed
            this.position.y += this.yspeed
            this.yspeed += this.gravity
            this.rotation += this.rotationspeed
        }
    },
    draw:function () {
        if (this.visible) {
            Game.b_ctx.save()
            Game.b_ctx.globalAlpha = this.alpha
            Game.b_ctx.translate(this.position.x, this.position.y)
            if (this.atlasimage) {
                Game.b_ctx.rotate((this.rotation - this.imagerotation) * CG.Const_PI_180)
                Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - (this.cutwidth / 2), 0 - (this.cutheight / 2), this.cutwidth * this.xscale, this.cutheight * this.yscale)
                Game.b_ctx.rotate((this.rotation + this.imagerotation) * CG.Const_PI_180)
            } else {
                Game.b_ctx.rotate(this.rotation * CG.Const_PI_180)
                Game.b_ctx.drawImage(this.image, 0 - (this.image.width * this.xscale / 2), 0 - (this.image.height * this.yscale / 2), this.image.width * this.xscale, this.image.height * this.yscale)
            }
            Game.b_ctx.restore()
        }
    }
})


/**
 * @description
 *
 * CG.Emitter that handles . . . particles.
 *
 * @class CG.Emitter
 * @extends CG.Entity
 *
 * @param {point} position of emitter
 */
CG.Entity.extend('Emitter', {
    /**
     * @method init
     * @constructor
     * @param position {CG.Point}
     * @return {*}
     */
    init:function (position) {
        this._super()
        /**
         * @property particle
         * @type {Array}
         */
        this.particles = []     //Particle pool delegated by emitter
        /**
         * @property maxparticles
         * @type {Number}
         */
        this.maxparticles = 50
        /**
         * @property creationtime
         * @type {Number}
         */
        this.creationtime = 100 //time when next particle would be generated/reanimated
        /**
         * @property currenttime
         * @type {Number}
         */
        this.currenttime = 0    //current counter
        /**
         * @property creationspeed
         * @type {Number}
         */
        this.creationspeed = 50 //increase for currenttime
        /**
         * @property gravity
         * @type {Number}
         */
        this.gravity = 0.05
        /**
         * @property image
         * @type {null}
         */
        this.image = null       //Image of the particle
        /**
         * @property type
         * @type {String}
         */
        this.type = ''          //point, corona, plate
        /**
         * @property position
         * @type {CG.Point}
         */
        this.position = position || new CG.Point(0, 0)
        this.position._x = this.position.x
        this.position._y = this.position.y
        /**
         * @property rotation
         * @type {Number}
         */
        this.rotation = 0       //rotation of plate emitter
        /**
         * @property width
         * @type {Number}
         */
        this.width = 200        //width of line and rectangle emitter
        /**
         * @property height
         * @type {Number}
         */
        this.height = 200       //width of rectangle emitter
        /**
         * @property radius
         * @type {Number}
         */
        this.radius = 0         //radius for corona emitter
        /**
         * @property pspeed
         * @type {Number}
         */
        this.pspeed = 10        //particle speed
        /**
         * @property protation
         * @type {Number}
         */
        this.protation = 0
        /**
         * @property pdirection
         * @type {Number}
         */
        this.pdirection = 0     //particle direction UP, DOWN, CG.LEFT, RIGHT
        /**
         * @property plifetime
         * @type {Number}
         */
        this.plifetime = 100    //particle lifetime
        /**
         * @property paging
         * @type {Number}
         */
        this.paging = 1         //particle aging
        /**
         * @property pfadeout
         * @type {Boolean}
         */
        this.pfadeout = false   //particle fadeout
        return this
    },
    /*
     * Objective-C style initialisation of all emitter types
     */

    /**
     * @description initAsPoint
     *
     * @param {mixed} image path, image or tpimage to use for the particle
     */

    initAsPoint:function (image) {
        this.image = image
        this.type = 'point'
        return this
    },


    /**
     * @method initAsExplosion
     *
     * @param {mixed} image path, image or tpimage to use for the particle
     * @param {Number} min value for particle speed
     * @param {Number} max value for particle speed
     */
    initAsExplosion:function (image, min, max) {
        this.image = image
        this.type = 'explosion'
        this.min = min
        this.max = max
        return this
    },

    /**
     * @method initAsCorona
     *
     * @param {mixed} image path, image or tpimage to use for the particle
     * @param {Number} radius of the corona emitter
     */
    initAsCorona:function (image, radius) {
        this.image = image
        this.type = 'corona'
        this.radius = radius || 0
        return this
    },

    /**
     * @method initAsLine
     *
     * @param {mixed} image path, image or tpimage to use for the particle
     * @param {Number} width of the plate emitter
     * @param {Number} direction (defined constants) of the plate emitter
     */
    initAsLine:function (image, width, direction) {
        this.image = image
        this.width = width || 200
        this.pdirection = direction || CG.UP
        this.type = 'line'
        return this
    },

    /**
     * @method initAsRectangle
     *
     * @param {mixed} image path, image or tpimage to use for the particle
     * @param {Number} width of the plate emitter
     * @param {Number} height (defined constants) of the plate emitter
     */
    initAsRectangle:function (image, width, height) {
        this.image = image
        this.width = width || 200
        this.height = height || 200
        this.type = 'rectangle'
        return this
    },
    /**
     * @method createParticle
     * @return {*}
     */
    createParticle:function () {
        particle = new CG.Particle(this.image)
        return particle
    },

    /**
     * @method initParticle
     *
     * @param {particle} particle particle object
     */
    initParticle:function (particle) {
        if (this.pfadeout) {
            particle.fadeout = true
        }
        particle.gravity = this.gravity     //set particle gravity to emitter gravity
        particle.alpha = 1                  //set alpha back to 1
        particle.visible = true             //make particle visible again
        particle.lifetime = this.plifetime  //reset lifetime
        particle.currtime = this.plifetime
        particle.rotationspeed = this.protation
        switch (this.type) {
            case 'corona':
                var rad = this.getRandom(0, 359) * CG.Const_PI_180

                particle.position.x = this.getX() - (this.radius * Math.cos(rad))
                particle.position.y = this.getY() - (this.radius * Math.sin(rad))

                angl = Math.atan2(particle.position.x - this.getX(), particle.position.y - this.getY()) * CG.Const_180_PI

                particle.xspeed = this.pspeed * Math.sin(angl * CG.Const_PI_180)
                particle.yspeed = this.pspeed * Math.cos(angl * CG.Const_PI_180)

                break
            case 'rectangle':
                //random value in rectangle
                rndx = this.getRandom(this.width / 2 * -1, this.width / 2)
                rndy = this.getRandom(this.height / 2 * -1, this.height / 2)

                particle.position.x = this.position._x - rndx
                particle.position.y = this.position._y - rndy
                particle.xspeed = 0
                particle.yspeed = 0

                break
            case 'line':
                //random value on plate line
                rnd = this.getRandom(this.width / 2 * -1, this.width / 2)

                //handle directions of line emitter
                switch (this.pdirection) {
                    default:
                    case CG.UP:
                        particle.xspeed = 0
                        particle.yspeed = this.pspeed * -1
                        particle.position.x = rnd + this.getX()
                        particle.position.y = this.position._y
                        break
                    case CG.DOWN:
                        particle.xspeed = 0
                        particle.yspeed = this.pspeed
                        particle.position.x = rnd + this.getX()
                        particle.position.y = this.position._y
                        break
                    case CG.LEFT:
                        particle.xspeed = this.pspeed * -1
                        particle.yspeed = 0
                        particle.position.x = this.position._x
                        particle.position.y = rnd + this.getY()
                        break
                    case CG.RIGHT:
                        particle.xspeed = this.pspeed
                        particle.yspeed = 0
                        particle.position.x = this.position._x
                        particle.position.y = rnd + this.getY()
                        break
                }
                break
            case 'explosion':
                particle.position.x = this.position._x
                particle.position.y = this.position._y

                particle.xspeed = this.getRandom(this.min, this.max)
                particle.yspeed = this.getRandom(this.min, this.max)
                break
            case 'point':
            default:
                particle.xspeed = 0
                particle.yspeed = 0
                particle.position.x = this.position._x
                particle.position.y = this.position._y
                break
        }
        return particle
    },

    update:function () {
        if (this.visible) {
            this.currenttime += this.creationspeed
            //particle lifetime
            if (this.currenttime >= this.creationtime) {
                this.currenttime = 0
                if (this.particles.length < this.maxparticles) {
                    this.particles.push(this.initParticle(this.createParticle()))
                }
                else {
                    particle = this.searchInvisibleParticle()   //search inactive particle in 'pool''
                    this.initParticle(particle)
                    this.particles.sort(function (obj1, obj2) {
                            return obj1.currtime - obj2.currtime
                        }
                    )
                }
            }


            for (var i = 0, l = this.particles.length; i < l; i++) {
                this.particles[i].update()
            }
            return this
        }
    },
    draw:function () {
        if (this.visible) {
            for (var i = 0, l = this.particles.length; i < l; i++) {
                this.particles[i].draw()
            }
            return this
        }
    },
    /**
     * @description Each emitter has its own particle pool to prevent object deletion/creation. This method searches an inactive/invisible particle
     * @method searchInvisibleParticle
     */
    searchInvisibleParticle:function () {
        for (var i = 0, l = this.particles.length; i < l; i++) {
            if (this.particles[i].visible == false) {
                return this.particles[i]
            }
        }
        return this
    },

    /**
     * @method setEmitterPosition
     *
     * @param {CG.Point} position of the emitter
     */
    setEmitterPosition:function (position) {
        this.position = position
        return this
    },

    /**
     * @method  setName
     *
     * @param {string} name of the object for search with layerobject.getElementByName(name)
     */
    setName:function (name) {
        this.name = name
        return this
    },

    /**
     * @method setCreationTime
     *
     * @param {Number} creationtime
     */
    setCreationTime:function (creationtime) {
        this.creationtime = creationtime
        return this
    },
    /**
     * @method setMaxParticles
     *
     * @param {Number} maxparticle
     */
    setMaxParticles:function (maxparticle) {
        this.maxparticles = maxparticle
        return this
    },
    /**
     * @method setGravity
     *
     * @param {float} gravity for all emitter controlled particles
     */
    setGravity:function (gravity) {
        this.gravity = gravity
        return this
    },

    /*
     * @method setParticleSpeed
     *
     * @param {Number} speed set the speed of the particles
     */
    setParticleSpeed:function (speed) {
        this.pspeed = speed
        return this
    },

    /**
     * @method setProtation
     *
     * @param {mixed} rotation set the rotation of the particles
     */
    setProtation:function (rotation) {
        this.protation = rotation
        return this
    },

    /**
     * @method setPLifetime
     *
     * @param {Number} plifetime set the lifetime of the particles
     */
    setPLifetime:function (plifetime) {
        this.plifetime = plifetime
        return this
    },

    /**
     * @method activateFadeout
     * @description Activate fadeout of the particles depending on lifetime
     */
    activateFadeout:function () {
        this.pfadeout = true
        return this
    },

    /**
     * @method deactivateFadeout
     * @description Deactivate fadeout of the particles depending on lifetime
     */
    deactivateFadeout:function () {
        this.pfadeout = false
        return this
    },

    /**
     * @method getRandom
     *
     * @param {mixed} min value for random number
     * @param {mixed} max value for random number
     */
    getRandom:function (min, max) {
        return Math.random() * (max - min + 1) + min >> 0
    },

    /**
     * @method getX
     */
    getX:function () {
        return this.position._x
    },

    /**
     * @method getY
     */
    getY:function () {
        return this.position._y
    }
})


var COMPILED = !0, goog = goog || {};
goog.global = this;
goog.DEBUG = !1;
goog.LOCALE = "en";
goog.TRUSTED_SITE = !0;
goog.provide = function(a) {
    if (!COMPILED) {
        if (goog.isProvided_(a))
            throw Error('Namespace "' + a + '" already declared.');
        delete goog.implicitNamespaces_[a];
        for (var b = a; (b = b.substring(0, b.lastIndexOf("."))) && !goog.getObjectByName(b); )
            goog.implicitNamespaces_[b] = !0
    }
    goog.exportPath_(a)
};
goog.setTestOnly = function(a) {
    if (COMPILED && !goog.DEBUG)
        throw a = a || "", Error("Importing test-only code into non-debug environment" + a ? ": " + a : ".");
};
COMPILED || (goog.isProvided_ = function(a) {
    return!goog.implicitNamespaces_[a] && !!goog.getObjectByName(a)
}, goog.implicitNamespaces_ = {});
goog.exportPath_ = function(a, b, c) {
    a = a.split(".");
    c = c || goog.global;
    a[0]in c || !c.execScript || c.execScript("var " + a[0]);
    for (var e; a.length && (e = a.shift()); )
        !a.length && goog.isDef(b) ? c[e] = b : c = c[e] ? c[e] : c[e] = {}
};
goog.getObjectByName = function(a, b) {
    for (var c = a.split("."), e = b || goog.global, d; d = c.shift(); )
        if (goog.isDefAndNotNull(e[d]))
            e = e[d];
        else
            return null;
    return e
};
goog.globalize = function(a, b) {
    var c = b || goog.global, e;
    for (e in a)
        c[e] = a[e]
};
goog.addDependency = function(a, b, c) {
    if (!COMPILED) {
        var e;
        a = a.replace(/\\/g, "/");
        for (var d = goog.dependencies_, f = 0; e = b[f]; f++)
            d.nameToPath[e] = a, a in d.pathToNames || (d.pathToNames[a] = {}), d.pathToNames[a][e] = !0;
        for (e = 0; b = c[e]; e++)
            a in d.requires || (d.requires[a] = {}), d.requires[a][b] = !0
    }
};
goog.ENABLE_DEBUG_LOADER = !0;
goog.require = function(a) {
    if (!COMPILED && !goog.isProvided_(a)) {
        if (goog.ENABLE_DEBUG_LOADER) {
            var b = goog.getPathFromDeps_(a);
            if (b) {
                goog.included_[b] = !0;
                goog.writeScripts_();
                return
            }
        }
        a = "goog.require could not find: " + a;
        goog.global.console && goog.global.console.error(a);
        throw Error(a);
    }
};
goog.basePath = "";
goog.nullFunction = function() {
};
goog.identityFunction = function(a, b) {
    return a
};
goog.abstractMethod = function() {
    throw Error("unimplemented abstract method");
};
goog.addSingletonGetter = function(a) {
    a.getInstance = function() {
        if (a.instance_)
            return a.instance_;
        goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);
        return a.instance_ = new a
    }
};
goog.instantiatedSingletons_ = [];
!COMPILED && goog.ENABLE_DEBUG_LOADER && (goog.included_ = {}, goog.dependencies_ = {pathToNames: {}, nameToPath: {}, requires: {}, visited: {}, written: {}}, goog.inHtmlDocument_ = function() {
    var a = goog.global.document;
    return"undefined" != typeof a && "write"in a
}, goog.findBasePath_ = function() {
    if (goog.global.CLOSURE_BASE_PATH)
        goog.basePath = goog.global.CLOSURE_BASE_PATH;
    else if (goog.inHtmlDocument_())
        for (var a = goog.global.document.getElementsByTagName("script"), b = a.length - 1; 0 <= b; --b) {
            var c = a[b].src, e = c.lastIndexOf("?"), e =
                    -1 == e ? c.length : e;
            if ("base.js" == c.substr(e - 7, 7)) {
                goog.basePath = c.substr(0, e - 7);
                break
            }
        }
}, goog.importScript_ = function(a) {
    var b = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
    !goog.dependencies_.written[a] && b(a) && (goog.dependencies_.written[a] = !0)
}, goog.writeScriptTag_ = function(a) {
    if (goog.inHtmlDocument_()) {
        var b = goog.global.document;
        if ("complete" == b.readyState) {
            if (/\bdeps.js$/.test(a))
                return!1;
            throw Error('Cannot write "' + a + '" after document load');
        }
        b.write('<script type="text/javascript" src="' +
                a + '">\x3c/script>');
        return!0
    }
    return!1
}, goog.writeScripts_ = function() {
    function a(d) {
        if (!(d in e.written)) {
            if (!(d in e.visited) && (e.visited[d] = !0, d in e.requires))
                for (var g in e.requires[d])
                    if (!goog.isProvided_(g))
                        if (g in e.nameToPath)
                            a(e.nameToPath[g]);
                        else
                            throw Error("Undefined nameToPath for " + g);
            d in c || (c[d] = !0, b.push(d))
        }
    }
    var b = [], c = {}, e = goog.dependencies_, d;
    for (d in goog.included_)
        e.written[d] || a(d);
    for (d = 0; d < b.length; d++)
        if (b[d])
            goog.importScript_(goog.basePath + b[d]);
        else
            throw Error("Undefined script input");
}, goog.getPathFromDeps_ = function(a) {
    return a in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[a] : null
}, goog.findBasePath_(), goog.global.CLOSURE_NO_DEPS || goog.importScript_(goog.basePath + "deps.js"));
goog.typeOf = function(a) {
    var b = typeof a;
    if ("object" == b)
        if (a) {
            if (a instanceof Array)
                return"array";
            if (a instanceof Object)
                return b;
            var c = Object.prototype.toString.call(a);
            if ("[object Window]" == c)
                return"object";
            if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice"))
                return"array";
            if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call"))
                return"function"
        } else
            return"null";
    else if ("function" == b && "undefined" == typeof a.call)
        return"object";
    return b
};
goog.isDef = function(a) {
    return void 0 !== a
};
goog.isNull = function(a) {
    return null === a
};
goog.isDefAndNotNull = function(a) {
    return null != a
};
goog.isArray = function(a) {
    return"array" == goog.typeOf(a)
};
goog.isArrayLike = function(a) {
    var b = goog.typeOf(a);
    return"array" == b || "object" == b && "number" == typeof a.length
};
goog.isDateLike = function(a) {
    return goog.isObject(a) && "function" == typeof a.getFullYear
};
goog.isString = function(a) {
    return"string" == typeof a
};
goog.isBoolean = function(a) {
    return"boolean" == typeof a
};
goog.isNumber = function(a) {
    return"number" == typeof a
};
goog.isFunction = function(a) {
    return"function" == goog.typeOf(a)
};
goog.isObject = function(a) {
    var b = typeof a;
    return"object" == b && null != a || "function" == b
};
goog.getUid = function(a) {
    return a[goog.UID_PROPERTY_] || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_)
};
goog.removeUid = function(a) {
    "removeAttribute"in a && a.removeAttribute(goog.UID_PROPERTY_);
    try {
        delete a[goog.UID_PROPERTY_]
    } catch (b) {
    }
};
goog.UID_PROPERTY_ = "closure_uid_" + (1E9 * Math.random() >>> 0);
goog.uidCounter_ = 0;
goog.getHashCode = goog.getUid;
goog.removeHashCode = goog.removeUid;
goog.cloneObject = function(a) {
    var b = goog.typeOf(a);
    if ("object" == b || "array" == b) {
        if (a.clone)
            return a.clone();
        var b = "array" == b ? [] : {}, c;
        for (c in a)
            b[c] = goog.cloneObject(a[c]);
        return b
    }
    return a
};
goog.bindNative_ = function(a, b, c) {
    return a.call.apply(a.bind, arguments)
};
goog.bindJs_ = function(a, b, c) {
    if (!a)
        throw Error();
    if (2 < arguments.length) {
        var e = Array.prototype.slice.call(arguments, 2);
        return function() {
            var c = Array.prototype.slice.call(arguments);
            Array.prototype.unshift.apply(c, e);
            return a.apply(b, c)
        }
    }
    return function() {
        return a.apply(b, arguments)
    }
};
goog.bind = function(a, b, c) {
    Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
    return goog.bind.apply(null, arguments)
};
goog.partial = function(a, b) {
    var c = Array.prototype.slice.call(arguments, 1);
    return function() {
        var b = Array.prototype.slice.call(arguments);
        b.unshift.apply(b, c);
        return a.apply(this, b)
    }
};
goog.mixin = function(a, b) {
    for (var c in b)
        a[c] = b[c]
};
goog.now = goog.TRUSTED_SITE && Date.now || function() {
    return+new Date
};
goog.globalEval = function(a) {
    if (goog.global.execScript)
        goog.global.execScript(a, "JavaScript");
    else if (goog.global.eval)
        if (null == goog.evalWorksForGlobals_ && (goog.global.eval("var _et_ = 1;"), "undefined" != typeof goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_)
            goog.global.eval(a);
        else {
            var b = goog.global.document, c = b.createElement("script");
            c.type = "text/javascript";
            c.defer = !1;
            c.appendChild(b.createTextNode(a));
            b.body.appendChild(c);
            b.body.removeChild(c)
        }
    else
        throw Error("goog.globalEval not available");
};
goog.evalWorksForGlobals_ = null;
goog.getCssName = function(a, b) {
    var c = function(a) {
        return goog.cssNameMapping_[a] || a
    }, e = function(a) {
        a = a.split("-");
        for (var b = [], e = 0; e < a.length; e++)
            b.push(c(a[e]));
        return b.join("-")
    }, e = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? c : e : function(a) {
        return a
    };
    return b ? a + "-" + e(b) : e(a)
};
goog.setCssNameMapping = function(a, b) {
    goog.cssNameMapping_ = a;
    goog.cssNameMappingStyle_ = b
};
!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
goog.getMsg = function(a, b) {
    var c = b || {}, e;
    for (e in c) {
        var d = ("" + c[e]).replace(/\$/g, "$$$$");
        a = a.replace(RegExp("\\{\\$" + e + "\\}", "gi"), d)
    }
    return a
};
goog.getMsgWithFallback = function(a, b) {
    return a
};
goog.exportSymbol = function(a, b, c) {
    goog.exportPath_(a, b, c)
};
goog.exportProperty = function(a, b, c) {
    a[b] = c
};
goog.inherits = function(a, b) {
    function c() {
    }
    c.prototype = b.prototype;
    a.superClass_ = b.prototype;
    a.prototype = new c;
    a.prototype.constructor = a
};
goog.base = function(a, b, c) {
    var e = arguments.callee.caller;
    if (e.superClass_)
        return e.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
    for (var d = Array.prototype.slice.call(arguments, 2), f = !1, g = a.constructor; g; g = g.superClass_ && g.superClass_.constructor)
        if (g.prototype[b] === e)
            f = !0;
        else if (f)
            return g.prototype[b].apply(a, d);
    if (a[b] === e)
        return a.constructor.prototype[b].apply(a, d);
    throw Error("goog.base called from a method of one name to a method of a different name");
};
goog.scope = function(a) {
    a.call(goog.global)
};
goog.debug = {};
goog.debug.Error = function(a) {
    Error.captureStackTrace ? Error.captureStackTrace(this, goog.debug.Error) : this.stack = Error().stack || "";
    a && (this.message = String(a))
};
goog.inherits(goog.debug.Error, Error);
goog.debug.Error.prototype.name = "CustomError";
goog.string = {};
goog.string.Unicode = {NBSP: "\u00a0"};
goog.string.startsWith = function(a, b) {
    return 0 == a.lastIndexOf(b, 0)
};
goog.string.endsWith = function(a, b) {
    var c = a.length - b.length;
    return 0 <= c && a.indexOf(b, c) == c
};
goog.string.caseInsensitiveStartsWith = function(a, b) {
    return 0 == goog.string.caseInsensitiveCompare(b, a.substr(0, b.length))
};
goog.string.caseInsensitiveEndsWith = function(a, b) {
    return 0 == goog.string.caseInsensitiveCompare(b, a.substr(a.length - b.length, b.length))
};
goog.string.subs = function(a, b) {
    for (var c = 1; c < arguments.length; c++) {
        var e = String(arguments[c]).replace(/\$/g, "$$$$");
        a = a.replace(/\%s/, e)
    }
    return a
};
goog.string.collapseWhitespace = function(a) {
    return a.replace(/[\s\xa0]+/g, " ").replace(/^\s+|\s+$/g, "")
};
goog.string.isEmpty = function(a) {
    return/^[\s\xa0]*$/.test(a)
};
goog.string.isEmptySafe = function(a) {
    return goog.string.isEmpty(goog.string.makeSafe(a))
};
goog.string.isBreakingWhitespace = function(a) {
    return!/[^\t\n\r ]/.test(a)
};
goog.string.isAlpha = function(a) {
    return!/[^a-zA-Z]/.test(a)
};
goog.string.isNumeric = function(a) {
    return!/[^0-9]/.test(a)
};
goog.string.isAlphaNumeric = function(a) {
    return!/[^a-zA-Z0-9]/.test(a)
};
goog.string.isSpace = function(a) {
    return" " == a
};
goog.string.isUnicodeChar = function(a) {
    return 1 == a.length && " " <= a && "~" >= a || "\u0080" <= a && "\ufffd" >= a
};
goog.string.stripNewlines = function(a) {
    return a.replace(/(\r\n|\r|\n)+/g, " ")
};
goog.string.canonicalizeNewlines = function(a) {
    return a.replace(/(\r\n|\r|\n)/g, "\n")
};
goog.string.normalizeWhitespace = function(a) {
    return a.replace(/\xa0|\s/g, " ")
};
goog.string.normalizeSpaces = function(a) {
    return a.replace(/\xa0|[ \t]+/g, " ")
};
goog.string.collapseBreakingSpaces = function(a) {
    return a.replace(/[\t\r\n ]+/g, " ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, "")
};
goog.string.trim = function(a) {
    return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g, "")
};
goog.string.trimLeft = function(a) {
    return a.replace(/^[\s\xa0]+/, "")
};
goog.string.trimRight = function(a) {
    return a.replace(/[\s\xa0]+$/, "")
};
goog.string.caseInsensitiveCompare = function(a, b) {
    var c = String(a).toLowerCase(), e = String(b).toLowerCase();
    return c < e ? -1 : c == e ? 0 : 1
};
goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;
goog.string.numerateCompare = function(a, b) {
    if (a == b)
        return 0;
    if (!a)
        return-1;
    if (!b)
        return 1;
    for (var c = a.toLowerCase().match(goog.string.numerateCompareRegExp_), e = b.toLowerCase().match(goog.string.numerateCompareRegExp_), d = Math.min(c.length, e.length), f = 0; f < d; f++) {
        var g = c[f], h = e[f];
        if (g != h)
            return c = parseInt(g, 10), !isNaN(c) && (e = parseInt(h, 10), !isNaN(e) && c - e) ? c - e : g < h ? -1 : 1
    }
    return c.length != e.length ? c.length - e.length : a < b ? -1 : 1
};
goog.string.urlEncode = function(a) {
    return encodeURIComponent(String(a))
};
goog.string.urlDecode = function(a) {
    return decodeURIComponent(a.replace(/\+/g, " "))
};
goog.string.newLineToBr = function(a, b) {
    return a.replace(/(\r\n|\r|\n)/g, b ? "<br />" : "<br>")
};
goog.string.htmlEscape = function(a, b) {
    if (b)
        return a.replace(goog.string.amperRe_, "&amp;").replace(goog.string.ltRe_, "&lt;").replace(goog.string.gtRe_, "&gt;").replace(goog.string.quotRe_, "&quot;");
    if (!goog.string.allRe_.test(a))
        return a;
    -1 != a.indexOf("&") && (a = a.replace(goog.string.amperRe_, "&amp;"));
    -1 != a.indexOf("<") && (a = a.replace(goog.string.ltRe_, "&lt;"));
    -1 != a.indexOf(">") && (a = a.replace(goog.string.gtRe_, "&gt;"));
    -1 != a.indexOf('"') && (a = a.replace(goog.string.quotRe_, "&quot;"));
    return a
};
goog.string.amperRe_ = /&/g;
goog.string.ltRe_ = /</g;
goog.string.gtRe_ = />/g;
goog.string.quotRe_ = /\"/g;
goog.string.allRe_ = /[&<>\"]/;
goog.string.unescapeEntities = function(a) {
    return goog.string.contains(a, "&") ? "document"in goog.global ? goog.string.unescapeEntitiesUsingDom_(a) : goog.string.unescapePureXmlEntities_(a) : a
};
goog.string.unescapeEntitiesUsingDom_ = function(a) {
    var b = {"&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"'}, c = document.createElement("div");
    return a.replace(goog.string.HTML_ENTITY_PATTERN_, function(a, d) {
        var f = b[a];
        if (f)
            return f;
        if ("#" == d.charAt(0)) {
            var g = Number("0" + d.substr(1));
            isNaN(g) || (f = String.fromCharCode(g))
        }
        f || (c.innerHTML = a + " ", f = c.firstChild.nodeValue.slice(0, -1));
        return b[a] = f
    })
};
goog.string.unescapePureXmlEntities_ = function(a) {
    return a.replace(/&([^;]+);/g, function(a, c) {
        switch (c) {
            case "amp":
                return"&";
            case "lt":
                return"<";
            case "gt":
                return">";
            case "quot":
                return'"';
            default:
                if ("#" == c.charAt(0)) {
                    var e = Number("0" + c.substr(1));
                    if (!isNaN(e))
                        return String.fromCharCode(e)
                }
                return a
            }
    })
};
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
goog.string.whitespaceEscape = function(a, b) {
    return goog.string.newLineToBr(a.replace(/  /g, " &#160;"), b)
};
goog.string.stripQuotes = function(a, b) {
    for (var c = b.length, e = 0; e < c; e++) {
        var d = 1 == c ? b : b.charAt(e);
        if (a.charAt(0) == d && a.charAt(a.length - 1) == d)
            return a.substring(1, a.length - 1)
    }
    return a
};
goog.string.truncate = function(a, b, c) {
    c && (a = goog.string.unescapeEntities(a));
    a.length > b && (a = a.substring(0, b - 3) + "...");
    c && (a = goog.string.htmlEscape(a));
    return a
};
goog.string.truncateMiddle = function(a, b, c, e) {
    c && (a = goog.string.unescapeEntities(a));
    if (e && a.length > b) {
        e > b && (e = b);
        var d = a.length - e;
        a = a.substring(0, b - e) + "..." + a.substring(d)
    } else
        a.length > b && (e = Math.floor(b / 2), d = a.length - e, a = a.substring(0, e + b % 2) + "..." + a.substring(d));
    c && (a = goog.string.htmlEscape(a));
    return a
};
goog.string.specialEscapeChars_ = {"\x00": "\\0", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "\t": "\\t", "\x0B": "\\x0B", '"': '\\"', "\\": "\\\\"};
goog.string.jsEscapeCache_ = {"'": "\\'"};
goog.string.quote = function(a) {
    a = String(a);
    if (a.quote)
        return a.quote();
    for (var b = ['"'], c = 0; c < a.length; c++) {
        var e = a.charAt(c), d = e.charCodeAt(0);
        b[c + 1] = goog.string.specialEscapeChars_[e] || (31 < d && 127 > d ? e : goog.string.escapeChar(e))
    }
    b.push('"');
    return b.join("")
};
goog.string.escapeString = function(a) {
    for (var b = [], c = 0; c < a.length; c++)
        b[c] = goog.string.escapeChar(a.charAt(c));
    return b.join("")
};
goog.string.escapeChar = function(a) {
    if (a in goog.string.jsEscapeCache_)
        return goog.string.jsEscapeCache_[a];
    if (a in goog.string.specialEscapeChars_)
        return goog.string.jsEscapeCache_[a] = goog.string.specialEscapeChars_[a];
    var b = a, c = a.charCodeAt(0);
    if (31 < c && 127 > c)
        b = a;
    else {
        if (256 > c) {
            if (b = "\\x", 16 > c || 256 < c)
                b += "0"
        } else
            b = "\\u", 4096 > c && (b += "0");
        b += c.toString(16).toUpperCase()
    }
    return goog.string.jsEscapeCache_[a] = b
};
goog.string.toMap = function(a) {
    for (var b = {}, c = 0; c < a.length; c++)
        b[a.charAt(c)] = !0;
    return b
};
goog.string.contains = function(a, b) {
    return-1 != a.indexOf(b)
};
goog.string.countOf = function(a, b) {
    return a && b ? a.split(b).length - 1 : 0
};
goog.string.removeAt = function(a, b, c) {
    var e = a;
    0 <= b && (b < a.length && 0 < c) && (e = a.substr(0, b) + a.substr(b + c, a.length - b - c));
    return e
};
goog.string.remove = function(a, b) {
    var c = RegExp(goog.string.regExpEscape(b), "");
    return a.replace(c, "")
};
goog.string.removeAll = function(a, b) {
    var c = RegExp(goog.string.regExpEscape(b), "g");
    return a.replace(c, "")
};
goog.string.regExpEscape = function(a) {
    return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08")
};
goog.string.repeat = function(a, b) {
    return Array(b + 1).join(a)
};
goog.string.padNumber = function(a, b, c) {
    a = goog.isDef(c) ? a.toFixed(c) : String(a);
    c = a.indexOf(".");
    -1 == c && (c = a.length);
    return goog.string.repeat("0", Math.max(0, b - c)) + a
};
goog.string.makeSafe = function(a) {
    return null == a ? "" : String(a)
};
goog.string.buildString = function(a) {
    return Array.prototype.join.call(arguments, "")
};
goog.string.getRandomString = function() {
    return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ goog.now()).toString(36)
};
goog.string.compareVersions = function(a, b) {
    for (var c = 0, e = goog.string.trim(String(a)).split("."), d = goog.string.trim(String(b)).split("."), f = Math.max(e.length, d.length), g = 0; 0 == c && g < f; g++) {
        var h = e[g] || "", l = d[g] || "", k = RegExp("(\\d*)(\\D*)", "g"), m = RegExp("(\\d*)(\\D*)", "g");
        do {
            var n = k.exec(h) || ["", "", ""], p = m.exec(l) || ["", "", ""];
            if (0 == n[0].length && 0 == p[0].length)
                break;
            var c = 0 == n[1].length ? 0 : parseInt(n[1], 10), q = 0 == p[1].length ? 0 : parseInt(p[1], 10), c = goog.string.compareElements_(c, q) || goog.string.compareElements_(0 ==
                    n[2].length, 0 == p[2].length) || goog.string.compareElements_(n[2], p[2])
        } while (0 == c)
    }
    return c
};
goog.string.compareElements_ = function(a, b) {
    return a < b ? -1 : a > b ? 1 : 0
};
goog.string.HASHCODE_MAX_ = 4294967296;
goog.string.hashCode = function(a) {
    for (var b = 0, c = 0; c < a.length; ++c)
        b = 31 * b + a.charCodeAt(c), b %= goog.string.HASHCODE_MAX_;
    return b
};
goog.string.uniqueStringCounter_ = 2147483648 * Math.random() | 0;
goog.string.createUniqueString = function() {
    return"goog_" + goog.string.uniqueStringCounter_++
};
goog.string.toNumber = function(a) {
    var b = Number(a);
    return 0 == b && goog.string.isEmpty(a) ? NaN : b
};
goog.string.toCamelCase = function(a) {
    return String(a).replace(/\-([a-z])/g, function(a, c) {
        return c.toUpperCase()
    })
};
goog.string.toSelectorCase = function(a) {
    return String(a).replace(/([A-Z])/g, "-$1").toLowerCase()
};
goog.string.toTitleCase = function(a, b) {
    var c = goog.isString(b) ? goog.string.regExpEscape(b) : "\\s";
    return a.replace(RegExp("(^" + (c ? "|[" + c + "]+" : "") + ")([a-z])", "g"), function(a, b, c) {
        return b + c.toUpperCase()
    })
};
goog.string.parseInt = function(a) {
    isFinite(a) && (a = String(a));
    return goog.isString(a) ? /^\s*-?0x/i.test(a) ? parseInt(a, 16) : parseInt(a, 10) : NaN
};
goog.asserts = {};
goog.asserts.ENABLE_ASSERTS = goog.DEBUG;
goog.asserts.AssertionError = function(a, b) {
    b.unshift(a);
    goog.debug.Error.call(this, goog.string.subs.apply(null, b));
    b.shift();
    this.messagePattern = a
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);
goog.asserts.AssertionError.prototype.name = "AssertionError";
goog.asserts.doAssertFailure_ = function(a, b, c, e) {
    var d = "Assertion failed";
    if (c)
        var d = d + (": " + c), f = e;
    else
        a && (d += ": " + a, f = b);
    throw new goog.asserts.AssertionError("" + d, f || []);
};
goog.asserts.assert = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !a && goog.asserts.doAssertFailure_("", null, b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.fail = function(a, b) {
    if (goog.asserts.ENABLE_ASSERTS)
        throw new goog.asserts.AssertionError("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
};
goog.asserts.assertNumber = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isNumber(a) && goog.asserts.doAssertFailure_("Expected number but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertString = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isString(a) && goog.asserts.doAssertFailure_("Expected string but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertFunction = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isFunction(a) && goog.asserts.doAssertFailure_("Expected function but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertObject = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isObject(a) && goog.asserts.doAssertFailure_("Expected object but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertArray = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isArray(a) && goog.asserts.doAssertFailure_("Expected array but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertBoolean = function(a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(a) && goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
    return a
};
goog.asserts.assertInstanceof = function(a, b, c, e) {
    !goog.asserts.ENABLE_ASSERTS || a instanceof b || goog.asserts.doAssertFailure_("instanceof check failed.", null, c, Array.prototype.slice.call(arguments, 3));
    return a
};
goog.string.format = function(a, b) {
    var c = Array.prototype.slice.call(arguments), e = c.shift();
    if ("undefined" == typeof e)
        throw Error("[goog.string.format] Template required");
    return e.replace(/%([0\-\ \+]*)(\d+)?(\.(\d+))?([%sfdiu])/g, function(a, b, e, h, l, k, m, n) {
        if ("%" == k)
            return"%";
        var p = c.shift();
        if ("undefined" == typeof p)
            throw Error("[goog.string.format] Not enough arguments");
        arguments[0] = p;
        return goog.string.format.demuxes_[k].apply(null, arguments)
    })
};
goog.string.format.demuxes_ = {};
goog.string.format.demuxes_.s = function(a, b, c, e, d, f, g, h) {
    return isNaN(c) || "" == c || a.length >= c ? a : a = -1 < b.indexOf("-", 0) ? a + goog.string.repeat(" ", c - a.length) : goog.string.repeat(" ", c - a.length) + a
};
goog.string.format.demuxes_.f = function(a, b, c, e, d, f, g, h) {
    e = a.toString();
    isNaN(d) || "" == d || (e = a.toFixed(d));
    f = 0 > a ? "-" : 0 <= b.indexOf("+") ? "+" : 0 <= b.indexOf(" ") ? " " : "";
    0 <= a && (e = f + e);
    if (isNaN(c) || e.length >= c)
        return e;
    e = isNaN(d) ? Math.abs(a).toString() : Math.abs(a).toFixed(d);
    a = c - e.length - f.length;
    0 <= b.indexOf("-", 0) ? e = f + e + goog.string.repeat(" ", a) : (b = 0 <= b.indexOf("0", 0) ? "0" : " ", e = f + goog.string.repeat(b, a) + e);
    return e
};
goog.string.format.demuxes_.d = function(a, b, c, e, d, f, g, h) {
    return goog.string.format.demuxes_.f(parseInt(a, 10), b, c, e, 0, f, g, h)
};
goog.string.format.demuxes_.i = goog.string.format.demuxes_.d;
goog.string.format.demuxes_.u = goog.string.format.demuxes_.d;
var box2d = {b2Settings: {}};
Object.defineProperty || (Object.defineProperty = function(a, b, c) {
    Object.__defineGetter__ && ("get"in c ? a.__defineGetter__(b, c.get) : "value"in c && a.__defineGetter__(b, c.value));
    Object.__defineSetter__ && ("set"in c ? a.__defineSetter__(b, c.set) : "value"in c && a.__defineSetter__(b, c.value))
});
box2d.DEBUG = !1;
goog.exportSymbol("box2d.DEBUG", box2d.DEBUG);
box2d.ENABLE_ASSERTS = box2d.DEBUG;
goog.exportSymbol("box2d.ENABLE_ASSERTS", box2d.ENABLE_ASSERTS);
box2d.b2Assert = function(a, b, c) {
    if (box2d.DEBUG && !a)
        debugger
};
goog.exportSymbol("box2d.b2Assert", box2d.b2Assert);
box2d.b2_maxFloat = 1E37;
goog.exportSymbol("box2d.b2_maxFloat", box2d.b2_maxFloat);
box2d.b2_epsilon = 1E-5;
goog.exportSymbol("box2d.b2_epsilon", box2d.b2_epsilon);
box2d.b2_epsilon_sq = box2d.b2_epsilon * box2d.b2_epsilon;
goog.exportSymbol("box2d.b2_epsilon_sq", box2d.b2_epsilon_sq);
box2d.b2_pi = Math.PI;
goog.exportSymbol("box2d.b2_pi", box2d.b2_pi);
box2d.b2_maxManifoldPoints = 2;
goog.exportSymbol("box2d.b2_maxManifoldPoints", box2d.b2_maxManifoldPoints);
box2d.b2_maxPolygonVertices = 8;
goog.exportSymbol("box2d.b2_maxPolygonVertices", box2d.b2_maxPolygonVertices);
box2d.b2_aabbExtension = 0.1;
goog.exportSymbol("box2d.b2_aabbExtension", box2d.b2_aabbExtension);
box2d.b2_aabbMultiplier = 2;
goog.exportSymbol("box2d.b2_aabbMultiplier", box2d.b2_aabbMultiplier);
box2d.b2_linearSlop = 0.008;
goog.exportSymbol("box2d.b2_linearSlop", box2d.b2_linearSlop);
box2d.b2_angularSlop = 2 / 180 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_angularSlop", box2d.b2_angularSlop);
box2d.b2_polygonRadius = 2 * box2d.b2_linearSlop;
goog.exportSymbol("box2d.b2_polygonRadius", box2d.b2_polygonRadius);
box2d.b2_maxSubSteps = 8;
goog.exportSymbol("box2d.b2_maxSubSteps", box2d.b2_maxSubSteps);
box2d.b2_maxTOIContacts = 32;
goog.exportSymbol("box2d.b2_maxTOIContacts", box2d.b2_maxTOIContacts);
box2d.b2_velocityThreshold = 1;
goog.exportSymbol("box2d.b2_velocityThreshold", box2d.b2_velocityThreshold);
box2d.b2_maxLinearCorrection = 0.2;
goog.exportSymbol("box2d.b2_maxLinearCorrection", box2d.b2_maxLinearCorrection);
box2d.b2_maxAngularCorrection = 8 / 180 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_maxAngularCorrection", box2d.b2_maxAngularCorrection);
box2d.b2_maxTranslation = 2;
goog.exportSymbol("box2d.b2_maxTranslation", box2d.b2_maxTranslation);
box2d.b2_maxTranslationSquared = box2d.b2_maxTranslation * box2d.b2_maxTranslation;
goog.exportSymbol("box2d.b2_maxTranslationSquared", box2d.b2_maxTranslationSquared);
box2d.b2_maxRotation = 0.5 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_maxRotation", box2d.b2_maxRotation);
box2d.b2_maxRotationSquared = box2d.b2_maxRotation * box2d.b2_maxRotation;
goog.exportSymbol("box2d.b2_maxRotationSquared", box2d.b2_maxRotationSquared);
box2d.b2_baumgarte = 0.2;
goog.exportSymbol("box2d.b2_baumgarte", box2d.b2_baumgarte);
box2d.b2_toiBaumgarte = 0.75;
goog.exportSymbol("box2d.b2_toiBaumgarte", box2d.b2_toiBaumgarte);
box2d.b2_timeToSleep = 0.5;
goog.exportSymbol("box2d.b2_timeToSleep", box2d.b2_timeToSleep);
box2d.b2_linearSleepTolerance = 0.01;
goog.exportSymbol("box2d.b2_linearSleepTolerance", box2d.b2_linearSleepTolerance);
box2d.b2_angularSleepTolerance = 2 / 180 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_angularSleepTolerance", box2d.b2_angularSleepTolerance);
box2d.b2Alloc = function(a) {
    return null
};
goog.exportSymbol("box2d.b2Alloc", box2d.b2Alloc);
box2d.b2Free = function(a) {
};
goog.exportSymbol("box2d.b2Free", box2d.b2Free);
box2d.b2Log = function(a, b) {
    var c = Array.prototype.slice.call(arguments), c = goog.string.format.apply(null, c.slice(0));
    goog.global.console.log(c)
};
goog.exportSymbol("box2d.b2Log", box2d.b2Log);
box2d.b2Version = function(a, b, c) {
    this.major = a || 0;
    this.minor = b || 0;
    this.revision = c || 0
};
goog.exportSymbol("box2d.b2Version", box2d.b2Version);
box2d.b2Version.prototype.major = 0;
goog.exportProperty(box2d.b2Version.prototype, "major", box2d.b2Version.prototype.major);
box2d.b2Version.prototype.minor = 0;
goog.exportProperty(box2d.b2Version.prototype, "minor", box2d.b2Version.prototype.minor);
box2d.b2Version.prototype.revision = 0;
goog.exportProperty(box2d.b2Version.prototype, "revision", box2d.b2Version.prototype.revision);
box2d.b2Version.prototype.toString = function() {
    return this.major + "." + this.minor + "." + this.revision
};
goog.exportProperty(box2d.b2Version.prototype, "toString", box2d.b2Version.prototype.toString);
box2d.b2_version = new box2d.b2Version(2, 3, 0);
goog.exportSymbol("box2d.b2_version", box2d.b2_version);
box2d.b2_changelist = 254;
goog.exportSymbol("box2d.b2_changelist", box2d.b2_changelist);
box2d.b2ParseInt = function(a) {
    return parseInt(a, 10)
};
goog.exportSymbol("box2d.b2ParseInt", box2d.b2ParseInt);
box2d.b2ParseUInt = function(a) {
    return box2d.b2Abs(parseInt(a, 10))
};
goog.exportSymbol("box2d.b2ParseUInt", box2d.b2ParseUInt);
box2d.b2MakeArray = function(a, b) {
    void 0 === a && (a = 0);
    var c = Array(a);
    if (void 0 !== b)
        for (var e = 0; e < a; ++e)
            c[e] = b(e);
    return c
};
goog.exportSymbol("box2d.b2MakeArray", box2d.b2MakeArray);
box2d.b2MakeNumberArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return 0
    })
};
goog.exportSymbol("box2d.b2MakeNumberArray", box2d.b2MakeNumberArray);
box2d.b2Math = {};
box2d.b2_pi_over_180 = box2d.b2_pi / 180;
goog.exportSymbol("box2d.b2_pi_over_180", box2d.b2_pi_over_180);
box2d.b2_180_over_pi = 180 / box2d.b2_pi;
goog.exportSymbol("box2d.b2_180_over_pi", box2d.b2_180_over_pi);
box2d.b2_two_pi = 2 * box2d.b2_pi;
goog.exportSymbol("box2d.b2_two_pi", box2d.b2_two_pi);
box2d.b2Abs = function(a) {
    return 0 > a ? -a : a
};
goog.exportSymbol("box2d.b2Abs", box2d.b2Abs);
box2d.b2Min = function(a, b) {
    return a < b ? a : b
};
goog.exportSymbol("box2d.b2Min", box2d.b2Min);
box2d.b2Max = function(a, b) {
    return a > b ? a : b
};
goog.exportSymbol("box2d.b2Max", box2d.b2Max);
box2d.b2Clamp = function(a, b, c) {
    return a < b ? b : a > c ? c : a
};
goog.exportSymbol("box2d.b2Clamp", box2d.b2Clamp);
box2d.b2Swap = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1);
    var c = a[0];
    a[0] = b[0];
    b[0] = c
};
goog.exportSymbol("box2d.b2Swap", box2d.b2Swap);
box2d.b2IsValid = function(a) {
    return isFinite(a)
};
goog.exportSymbol("box2d.b2IsValid", box2d.b2IsValid);
box2d.b2Sq = function(a) {
    return a * a
};
goog.exportSymbol("box2d.b2Sq", box2d.b2Sq);
box2d.b2InvSqrt = function(a) {
    return 1 / Math.sqrt(a)
};
goog.exportSymbol("box2d.b2InvSqrt", box2d.b2InvSqrt);
box2d.b2Sqrt = function(a) {
    return Math.sqrt(a)
};
goog.exportSymbol("box2d.b2Sqrt", box2d.b2Sqrt);
box2d.b2Pow = function(a, b) {
    return Math.pow(a, b)
};
goog.exportSymbol("box2d.b2Pow", box2d.b2Pow);
box2d.b2DegToRad = function(a) {
    return a * box2d.b2_pi_over_180
};
goog.exportSymbol("box2d.b2DegToRad", box2d.b2DegToRad);
box2d.b2RadToDeg = function(a) {
    return a * box2d.b2_180_over_pi
};
goog.exportSymbol("box2d.b2RadToDeg", box2d.b2RadToDeg);
box2d.b2Cos = function(a) {
    return Math.cos(a)
};
goog.exportSymbol("box2d.b2Cos", box2d.b2Cos);
box2d.b2Sin = function(a) {
    return Math.sin(a)
};
goog.exportSymbol("box2d.b2Sin", box2d.b2Sin);
box2d.b2Acos = function(a) {
    return Math.acos(a)
};
goog.exportSymbol("box2d.b2Acos", box2d.b2Acos);
box2d.b2Asin = function(a) {
    return Math.asin(a)
};
goog.exportSymbol("box2d.b2Asin", box2d.b2Asin);
box2d.b2Atan2 = function(a, b) {
    return Math.atan2(a, b)
};
goog.exportSymbol("box2d.b2Atan2", box2d.b2Atan2);
box2d.b2NextPowerOfTwo = function(a) {
    a |= a >> 1 & 2147483647;
    a |= a >> 2 & 1073741823;
    a |= a >> 4 & 268435455;
    a |= a >> 8 & 16777215;
    return(a | a >> 16 & 65535) + 1
};
goog.exportSymbol("box2d.b2NextPowerOfTwo", box2d.b2NextPowerOfTwo);
box2d.b2IsPowerOfTwo = function(a) {
    return 0 < a && 0 == (a & a - 1)
};
goog.exportSymbol("box2d.b2IsPowerOfTwo", box2d.b2IsPowerOfTwo);
box2d.b2Random = function() {
    return 2 * Math.random() - 1
};
goog.exportSymbol("box2d.b2Random", box2d.b2Random);
box2d.b2RandomRange = function(a, b) {
    return(b - a) * Math.random() + a
};
goog.exportSymbol("box2d.b2RandomRange", box2d.b2RandomRange);
box2d.b2Vec2 = function(a, b) {
    this.x = a || 0;
    this.y = b || 0
};
goog.exportSymbol("box2d.b2Vec2", box2d.b2Vec2);
box2d.b2Vec2.prototype.x = 0;
goog.exportProperty(box2d.b2Vec2.prototype, "x", box2d.b2Vec2.prototype.x);
box2d.b2Vec2.prototype.y = 0;
goog.exportProperty(box2d.b2Vec2.prototype, "y", box2d.b2Vec2.prototype.y);
box2d.b2Vec2_zero = new box2d.b2Vec2;
goog.exportSymbol("box2d.b2Vec2_zero", box2d.b2Vec2_zero);
box2d.b2Vec2.ZERO = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "ZERO", box2d.b2Vec2.ZERO);
box2d.b2Vec2.UNITX = new box2d.b2Vec2(1, 0);
goog.exportProperty(box2d.b2Vec2, "UNITX", box2d.b2Vec2.UNITX);
box2d.b2Vec2.UNITY = new box2d.b2Vec2(0, 1);
goog.exportProperty(box2d.b2Vec2, "UNITY", box2d.b2Vec2.UNITY);
box2d.b2Vec2.s_t0 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "s_t0", box2d.b2Vec2.s_t0);
box2d.b2Vec2.s_t1 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "s_t1", box2d.b2Vec2.s_t1);
box2d.b2Vec2.s_t2 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "s_t2", box2d.b2Vec2.s_t2);
box2d.b2Vec2.s_t3 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2Vec2, "s_t3", box2d.b2Vec2.s_t3);
box2d.b2Vec2.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2Vec2
    })
};
goog.exportProperty(box2d.b2Vec2, "MakeArray", box2d.b2Vec2.MakeArray);
box2d.b2Vec2.prototype.Clone = function() {
    return new box2d.b2Vec2(this.x, this.y)
};
goog.exportProperty(box2d.b2Vec2.prototype, "Clone", box2d.b2Vec2.prototype.Clone);
box2d.b2Vec2.prototype.SetZero = function() {
    this.y = this.x = 0;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SetZero", box2d.b2Vec2.prototype.SetZero);
box2d.b2Vec2.prototype.SetXY = function(a, b) {
    this.x = a;
    this.y = b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SetXY", box2d.b2Vec2.prototype.SetXY);
box2d.b2Vec2.prototype.Copy = function(a) {
    this.x = a.x;
    this.y = a.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "Copy", box2d.b2Vec2.prototype.Copy);
box2d.b2Vec2.prototype.SelfAdd = function(a) {
    this.x += a.x;
    this.y += a.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfAdd", box2d.b2Vec2.prototype.SelfAdd);
box2d.b2Vec2.prototype.SelfAddXY = function(a, b) {
    this.x += a;
    this.y += b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfAddXY", box2d.b2Vec2.prototype.SelfAddXY);
box2d.b2Vec2.prototype.SelfSub = function(a) {
    this.x -= a.x;
    this.y -= a.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfSub", box2d.b2Vec2.prototype.SelfSub);
box2d.b2Vec2.prototype.SelfSubXY = function(a, b) {
    this.x -= a;
    this.y -= b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfSubXY", box2d.b2Vec2.prototype.SelfSubXY);
box2d.b2Vec2.prototype.SelfMul = function(a) {
    this.x *= a;
    this.y *= a;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMul", box2d.b2Vec2.prototype.SelfMul);
box2d.b2Vec2.prototype.SelfMulAdd = function(a, b) {
    this.x += a * b.x;
    this.y += a * b.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMulAdd", box2d.b2Vec2.prototype.SelfMulAdd);
box2d.b2Vec2.prototype.SelfMulSub = function(a, b) {
    this.x -= a * b.x;
    this.y -= a * b.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMulSub", box2d.b2Vec2.prototype.SelfMulSub);
box2d.b2Vec2.prototype.Dot = function(a) {
    return this.x * a.x + this.y * a.y
};
goog.exportProperty(box2d.b2Vec2.prototype, "Dot", box2d.b2Vec2.prototype.Dot);
box2d.b2Vec2.prototype.Cross = function(a) {
    return this.x * a.y - this.y * a.x
};
goog.exportProperty(box2d.b2Vec2.prototype, "Cross", box2d.b2Vec2.prototype.Cross);
box2d.b2Vec2.prototype.GetLength = function() {
    var a = this.x, b = this.y;
    return Math.sqrt(a * a + b * b)
};
goog.exportProperty(box2d.b2Vec2.prototype, "GetLength", box2d.b2Vec2.prototype.GetLength);
box2d.b2Vec2.prototype.GetLengthSquared = function() {
    var a = this.x, b = this.y;
    return a * a + b * b
};
goog.exportProperty(box2d.b2Vec2.prototype, "GetLengthSquared", box2d.b2Vec2.prototype.GetLengthSquared);
box2d.b2Vec2.prototype.Normalize = function() {
    var a = this.GetLength();
    if (a >= box2d.b2_epsilon) {
        var b = 1 / a;
        this.x *= b;
        this.y *= b
    }
    return a
};
goog.exportProperty(box2d.b2Vec2.prototype, "Normalize", box2d.b2Vec2.prototype.Normalize);
box2d.b2Vec2.prototype.SelfNormalize = function() {
    var a = this.GetLength();
    a >= box2d.b2_epsilon && (a = 1 / a, this.x *= a, this.y *= a);
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfNormalize", box2d.b2Vec2.prototype.SelfNormalize);
box2d.b2Vec2.prototype.SelfRotate = function(a, b) {
    var c = this.x, e = this.y;
    this.x = a * c - b * e;
    this.y = b * c + a * e;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfRotate", box2d.b2Vec2.prototype.SelfRotate);
box2d.b2Vec2.prototype.SelfRotateRadians = function(a) {
    return this.SelfRotate(Math.cos(a), Math.sin(a))
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfRotateRadians", box2d.b2Vec2.prototype.SelfRotateRadians);
box2d.b2Vec2.prototype.SelfRotateDegrees = function(a) {
    return this.SelfRotateRadians(box2d.b2DegToRad(a))
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfRotateDegrees", box2d.b2Vec2.prototype.SelfRotateDegrees);
box2d.b2Vec2.prototype.IsValid = function() {
    return isFinite(this.x) && isFinite(this.y)
};
goog.exportProperty(box2d.b2Vec2.prototype, "IsValid", box2d.b2Vec2.prototype.IsValid);
box2d.b2Vec2.prototype.SelfCrossVS = function(a) {
    var b = this.x;
    this.x = a * this.y;
    this.y = -a * b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfCrossVS", box2d.b2Vec2.prototype.SelfCrossVS);
box2d.b2Vec2.prototype.SelfCrossSV = function(a) {
    var b = this.x;
    this.x = -a * this.y;
    this.y = a * b;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfCrossSV", box2d.b2Vec2.prototype.SelfCrossSV);
box2d.b2Vec2.prototype.SelfMinV = function(a) {
    this.x = box2d.b2Min(this.x, a.x);
    this.y = box2d.b2Min(this.y, a.y);
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMinV", box2d.b2Vec2.prototype.SelfMinV);
box2d.b2Vec2.prototype.SelfMaxV = function(a) {
    this.x = box2d.b2Max(this.x, a.x);
    this.y = box2d.b2Max(this.y, a.y);
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfMaxV", box2d.b2Vec2.prototype.SelfMaxV);
box2d.b2Vec2.prototype.SelfAbs = function() {
    this.x = box2d.b2Abs(this.x);
    this.y = box2d.b2Abs(this.y);
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfAbs", box2d.b2Vec2.prototype.SelfAbs);
box2d.b2Vec2.prototype.SelfNeg = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfNeg", box2d.b2Vec2.prototype.SelfNeg);
box2d.b2Vec2.prototype.SelfSkew = function() {
    var a = this.x;
    this.x = -this.y;
    this.y = a;
    return this
};
goog.exportProperty(box2d.b2Vec2.prototype, "SelfSkew", box2d.b2Vec2.prototype.SelfSkew);
box2d.b2AbsV = function(a, b) {
    b.x = box2d.b2Abs(a.x);
    b.y = box2d.b2Abs(a.y);
    return b
};
goog.exportSymbol("box2d.b2AbsV", box2d.b2AbsV);
box2d.b2MinV = function(a, b, c) {
    c.x = box2d.b2Min(a.x, b.x);
    c.y = box2d.b2Min(a.y, b.y);
    return c
};
goog.exportSymbol("box2d.b2MinV", box2d.b2MinV);
box2d.b2MaxV = function(a, b, c) {
    c.x = box2d.b2Max(a.x, b.x);
    c.y = box2d.b2Max(a.y, b.y);
    return c
};
goog.exportSymbol("box2d.b2MaxV", box2d.b2MaxV);
box2d.b2ClampV = function(a, b, c, e) {
    e.x = box2d.b2Clamp(a.x, b.x, c.x);
    e.y = box2d.b2Clamp(a.y, b.y, c.y);
    return e
};
goog.exportSymbol("box2d.b2ClampV", box2d.b2ClampV);
box2d.b2RotateV = function(a, b, c, e) {
    var d = a.x;
    a = a.y;
    e.x = b * d - c * a;
    e.y = c * d + b * a;
    return e
};
goog.exportSymbol("box2d.b2RotateV", box2d.b2RotateV);
box2d.b2RotateRadiansV = function(a, b, c) {
    return box2d.b2RotateV(a, Math.cos(b), Math.sin(b), c)
};
goog.exportSymbol("box2d.b2RotateRadiansV", box2d.b2RotateRadiansV);
box2d.b2RotateDegreesV = function(a, b, c) {
    return box2d.b2RotateRadiansV(a, box2d.b2DegToRad(b), c)
};
goog.exportSymbol("box2d.b2RotateDegreesV", box2d.b2RotateDegreesV);
box2d.b2DotVV = function(a, b) {
    return a.x * b.x + a.y * b.y
};
goog.exportSymbol("box2d.b2DotVV", box2d.b2DotVV);
box2d.b2CrossVV = function(a, b) {
    return a.x * b.y - a.y * b.x
};
goog.exportSymbol("box2d.b2CrossVV", box2d.b2CrossVV);
box2d.b2CrossVS = function(a, b, c) {
    var e = a.x;
    c.x = b * a.y;
    c.y = -b * e;
    return c
};
goog.exportSymbol("box2d.b2CrossVS", box2d.b2CrossVS);
box2d.b2CrossVOne = function(a, b) {
    var c = a.x;
    b.x = a.y;
    b.y = -c;
    return b
};
goog.exportSymbol("box2d.b2CrossVOne", box2d.b2CrossVOne);
box2d.b2CrossSV = function(a, b, c) {
    var e = b.x;
    c.x = -a * b.y;
    c.y = a * e;
    return c
};
goog.exportSymbol("box2d.b2CrossSV", box2d.b2CrossSV);
box2d.b2CrossOneV = function(a, b) {
    var c = a.x;
    b.x = -a.y;
    b.y = c;
    return b
};
goog.exportSymbol("box2d.b2CrossOneV", box2d.b2CrossOneV);
box2d.b2AddVV = function(a, b, c) {
    c.x = a.x + b.x;
    c.y = a.y + b.y;
    return c
};
goog.exportSymbol("box2d.b2AddVV", box2d.b2AddVV);
box2d.b2SubVV = function(a, b, c) {
    c.x = a.x - b.x;
    c.y = a.y - b.y;
    return c
};
goog.exportSymbol("box2d.b2SubVV", box2d.b2SubVV);
box2d.b2MulSV = function(a, b, c) {
    c.x = b.x * a;
    c.y = b.y * a;
    return c
};
goog.exportSymbol("box2d.b2MulSV", box2d.b2MulSV);
box2d.b2AddVMulSV = function(a, b, c, e) {
    e.x = a.x + b * c.x;
    e.y = a.y + b * c.y;
    return e
};
goog.exportSymbol("box2d.b2AddVMulSV", box2d.b2AddVMulSV);
box2d.b2SubVMulSV = function(a, b, c, e) {
    e.x = a.x - b * c.x;
    e.y = a.y - b * c.y;
    return e
};
goog.exportSymbol("box2d.b2SubVMulSV", box2d.b2SubVMulSV);
box2d.b2AddVCrossSV = function(a, b, c, e) {
    var d = c.x;
    e.x = a.x - b * c.y;
    e.y = a.y + b * d;
    return e
};
goog.exportSymbol("box2d.b2AddVCrossSV", box2d.b2AddVCrossSV);
box2d.b2MidVV = function(a, b, c) {
    c.x = 0.5 * (a.x + b.x);
    c.y = 0.5 * (a.y + b.y);
    return c
};
goog.exportSymbol("box2d.b2MidVV", box2d.b2MidVV);
box2d.b2ExtVV = function(a, b, c) {
    c.x = 0.5 * (b.x - a.x);
    c.y = 0.5 * (b.y - a.y);
    return c
};
goog.exportSymbol("box2d.b2ExtVV", box2d.b2ExtVV);
box2d.b2IsEqualToV = function(a, b) {
    return a.x == b.x && a.y == b.y
};
goog.exportSymbol("box2d.b2IsEqualToV", box2d.b2IsEqualToV);
box2d.b2DistanceVV = function(a, b) {
    var c = a.x - b.x, e = a.y - b.y;
    return Math.sqrt(c * c + e * e)
};
goog.exportSymbol("box2d.b2DistanceVV", box2d.b2DistanceVV);
box2d.b2DistanceSquaredVV = function(a, b) {
    var c = a.x - b.x, e = a.y - b.y;
    return c * c + e * e
};
goog.exportSymbol("box2d.b2DistanceSquaredVV", box2d.b2DistanceSquaredVV);
box2d.b2NegV = function(a, b) {
    b.x = -a.x;
    b.y = -a.y;
    return b
};
goog.exportSymbol("box2d.b2NegV", box2d.b2NegV);
box2d.b2Vec3 = function(a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0
};
goog.exportSymbol("box2d.b2Vec3", box2d.b2Vec3);
box2d.b2Vec3.prototype.x = 0;
goog.exportProperty(box2d.b2Vec3.prototype, "x", box2d.b2Vec3.prototype.x);
box2d.b2Vec3.prototype.y = 0;
goog.exportProperty(box2d.b2Vec3.prototype, "y", box2d.b2Vec3.prototype.y);
box2d.b2Vec3.prototype.z = 0;
goog.exportProperty(box2d.b2Vec3.prototype, "z", box2d.b2Vec3.prototype.z);
box2d.b2Vec3.ZERO = new box2d.b2Vec3;
goog.exportProperty(box2d.b2Vec3, "ZERO", box2d.b2Vec3.ZERO);
box2d.b2Vec3.s_t0 = new box2d.b2Vec3;
goog.exportProperty(box2d.b2Vec3, "s_t0", box2d.b2Vec3.s_t0);
box2d.b2Vec3.prototype.Clone = function() {
    return new box2d.b2Vec3(this.x, this.y, this.z)
};
goog.exportProperty(box2d.b2Vec3.prototype, "Clone", box2d.b2Vec3.prototype.Clone);
box2d.b2Vec3.prototype.SetZero = function() {
    this.z = this.y = this.x = 0;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SetZero", box2d.b2Vec3.prototype.SetZero);
box2d.b2Vec3.prototype.SetXYZ = function(a, b, c) {
    this.x = a;
    this.y = b;
    this.z = c;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SetXYZ", box2d.b2Vec3.prototype.SetXYZ);
box2d.b2Vec3.prototype.Copy = function(a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "Copy", box2d.b2Vec3.prototype.Copy);
box2d.b2Vec3.prototype.SelfNeg = function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfNeg", box2d.b2Vec3.prototype.SelfNeg);
box2d.b2Vec3.prototype.SelfAdd = function(a) {
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfAdd", box2d.b2Vec3.prototype.SelfAdd);
box2d.b2Vec3.prototype.SelfAddXYZ = function(a, b, c) {
    this.x += a;
    this.y += b;
    this.z += c;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfAddXYZ", box2d.b2Vec3.prototype.SelfAddXYZ);
box2d.b2Vec3.prototype.SelfSub = function(a) {
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfSub", box2d.b2Vec3.prototype.SelfSub);
box2d.b2Vec3.prototype.SelfSubXYZ = function(a, b, c) {
    this.x -= a;
    this.y -= b;
    this.z -= c;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfSubXYZ", box2d.b2Vec3.prototype.SelfSubXYZ);
box2d.b2Vec3.prototype.SelfMul = function(a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    return this
};
goog.exportProperty(box2d.b2Vec3.prototype, "SelfMul", box2d.b2Vec3.prototype.SelfMul);
box2d.b2DotV3V3 = function(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z
};
goog.exportSymbol("box2d.b2DotV3V3", box2d.b2DotV3V3);
box2d.b2CrossV3V3 = function(a, b, c) {
    var e = a.x, d = a.y;
    a = a.z;
    var f = b.x, g = b.y;
    b = b.z;
    c.x = d * b - a * g;
    c.y = a * f - e * b;
    c.z = e * g - d * f;
    return c
};
goog.exportSymbol("box2d.b2CrossV3V3", box2d.b2CrossV3V3);
box2d.b2Mat22 = function() {
    this.ex = new box2d.b2Vec2(1, 0);
    this.ey = new box2d.b2Vec2(0, 1)
};
goog.exportSymbol("box2d.b2Mat22", box2d.b2Mat22);
box2d.b2Mat22.prototype.ex = null;
goog.exportProperty(box2d.b2Mat22.prototype, "ex", box2d.b2Mat22.prototype.ex);
box2d.b2Mat22.prototype.ey = null;
goog.exportProperty(box2d.b2Mat22.prototype, "ey", box2d.b2Mat22.prototype.ey);
box2d.b2Mat22.IDENTITY = new box2d.b2Mat22;
goog.exportProperty(box2d.b2Mat22, "IDENTITY", box2d.b2Mat22.IDENTITY);
box2d.b2Mat22.prototype.Clone = function() {
    return(new box2d.b2Mat22).Copy(this)
};
goog.exportProperty(box2d.b2Mat22.prototype, "Clone", box2d.b2Mat22.prototype.Clone);
box2d.b2Mat22.FromVV = function(a, b) {
    return(new box2d.b2Mat22).SetVV(a, b)
};
goog.exportProperty(box2d.b2Mat22, "FromVV", box2d.b2Mat22.FromVV);
box2d.b2Mat22.FromSSSS = function(a, b, c, e) {
    return(new box2d.b2Mat22).SetSSSS(a, b, c, e)
};
goog.exportProperty(box2d.b2Mat22, "FromSSSS", box2d.b2Mat22.FromSSSS);
box2d.b2Mat22.FromAngleRadians = function(a) {
    return(new box2d.b2Mat22).SetAngleRadians(a)
};
goog.exportProperty(box2d.b2Mat22, "FromAngleRadians", box2d.b2Mat22.FromAngleRadians);
box2d.b2Mat22.prototype.SetSSSS = function(a, b, c, e) {
    this.ex.SetXY(a, c);
    this.ey.SetXY(b, e);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetSSSS", box2d.b2Mat22.prototype.SetSSSS);
box2d.b2Mat22.prototype.SetVV = function(a, b) {
    this.ex.Copy(a);
    this.ey.Copy(b);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetVV", box2d.b2Mat22.prototype.SetVV);
box2d.b2Mat22.prototype.SetAngle = function(a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.ex.SetXY(b, a);
    this.ey.SetXY(-a, b);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetAngle", box2d.b2Mat22.prototype.SetAngle);
box2d.b2Mat22.prototype.SetAngleRadians = box2d.b2Mat22.prototype.SetAngle;
box2d.b2Mat22.prototype.SetAngleDegrees = function(a) {
    return this.SetAngle(box2d.b2DegToRad(a))
};
box2d.b2Mat22.prototype.Copy = function(a) {
    this.ex.Copy(a.ex);
    this.ey.Copy(a.ey);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "Copy", box2d.b2Mat22.prototype.Copy);
box2d.b2Mat22.prototype.SetIdentity = function() {
    this.ex.SetXY(1, 0);
    this.ey.SetXY(0, 1);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetIdentity", box2d.b2Mat22.prototype.SetIdentity);
box2d.b2Mat22.prototype.SetZero = function() {
    this.ex.SetZero();
    this.ey.SetZero();
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SetZero", box2d.b2Mat22.prototype.SetZero);
box2d.b2Mat22.prototype.GetAngle = function() {
    return Math.atan2(this.ex.y, this.ex.x)
};
goog.exportProperty(box2d.b2Mat22.prototype, "GetAngle", box2d.b2Mat22.prototype.GetAngle);
box2d.b2Mat22.prototype.GetAngleRadians = box2d.b2Mat22.prototype.GetAngle;
box2d.b2Mat22.prototype.GetInverse = function(a) {
    var b = this.ex.x, c = this.ey.x, e = this.ex.y, d = this.ey.y, f = b * d - c * e;
    0 != f && (f = 1 / f);
    a.ex.x = f * d;
    a.ey.x = -f * c;
    a.ex.y = -f * e;
    a.ey.y = f * b;
    return a
};
goog.exportProperty(box2d.b2Mat22.prototype, "GetInverse", box2d.b2Mat22.prototype.GetInverse);
box2d.b2Mat22.prototype.Solve = function(a, b, c) {
    var e = this.ex.x, d = this.ey.x, f = this.ex.y, g = this.ey.y, h = e * g - d * f;
    0 != h && (h = 1 / h);
    c.x = h * (g * a - d * b);
    c.y = h * (e * b - f * a);
    return c
};
goog.exportProperty(box2d.b2Mat22.prototype, "Solve", box2d.b2Mat22.prototype.Solve);
box2d.b2Mat22.prototype.SelfAbs = function() {
    this.ex.SelfAbs();
    this.ey.SelfAbs();
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SelfAbs", box2d.b2Mat22.prototype.SelfAbs);
box2d.b2Mat22.prototype.SelfInv = function() {
    return this.GetInverse(this)
};
goog.exportProperty(box2d.b2Mat22.prototype, "SelfInv", box2d.b2Mat22.prototype.SelfInv);
box2d.b2Mat22.prototype.SelfAddM = function(a) {
    this.ex.SelfAdd(a.ex);
    this.ey.SelfAdd(a.ey);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SelfAddM", box2d.b2Mat22.prototype.SelfAddM);
box2d.b2Mat22.prototype.SelfSubM = function(a) {
    this.ex.SelfSub(a.ex);
    this.ey.SelfSub(a.ey);
    return this
};
goog.exportProperty(box2d.b2Mat22.prototype, "SelfSubM", box2d.b2Mat22.prototype.SelfSubM);
box2d.b2AbsM = function(a, b) {
    var c = a.ex, e = a.ey;
    b.ex.x = box2d.b2Abs(c.x);
    b.ex.y = box2d.b2Abs(c.y);
    b.ey.x = box2d.b2Abs(e.x);
    b.ey.y = box2d.b2Abs(e.y);
    return b
};
goog.exportSymbol("box2d.b2AbsM", box2d.b2AbsM);
box2d.b2MulMV = function(a, b, c) {
    var e = a.ex;
    a = a.ey;
    var d = b.x;
    b = b.y;
    c.x = e.x * d + a.x * b;
    c.y = e.y * d + a.y * b;
    return c
};
goog.exportSymbol("box2d.b2MulMV", box2d.b2MulMV);
box2d.b2MulTMV = function(a, b, c) {
    var e = a.ex;
    a = a.ey;
    var d = b.x;
    b = b.y;
    c.x = e.x * d + e.y * b;
    c.y = a.x * d + a.y * b;
    return c
};
goog.exportSymbol("box2d.b2MulTMV", box2d.b2MulTMV);
box2d.b2AddMM = function(a, b, c) {
    var e = a.ex;
    a = a.ey;
    var d = b.ex;
    b = b.ey;
    c.ex.x = e.x + d.x;
    c.ex.y = e.y + d.y;
    c.ey.x = a.x + b.x;
    c.ey.y = a.y + b.y;
    return c
};
goog.exportSymbol("box2d.b2AddMM", box2d.b2AddMM);
box2d.b2MulMM = function(a, b, c) {
    var e = a.ex.x, d = a.ex.y, f = a.ey.x;
    a = a.ey.y;
    var g = b.ex.x, h = b.ex.y, l = b.ey.x;
    b = b.ey.y;
    c.ex.x = e * g + f * h;
    c.ex.y = d * g + a * h;
    c.ey.x = e * l + f * b;
    c.ey.y = d * l + a * b;
    return c
};
goog.exportSymbol("box2d.b2MulMM", box2d.b2MulMM);
box2d.b2MulTMM = function(a, b, c) {
    var e = a.ex.x, d = a.ex.y, f = a.ey.x;
    a = a.ey.y;
    var g = b.ex.x, h = b.ex.y, l = b.ey.x;
    b = b.ey.y;
    c.ex.x = e * g + d * h;
    c.ex.y = f * g + a * h;
    c.ey.x = e * l + d * b;
    c.ey.y = f * l + a * b;
    return c
};
goog.exportSymbol("box2d.b2MulTMM", box2d.b2MulTMM);
box2d.b2Mat33 = function() {
    this.ex = new box2d.b2Vec3(1, 0, 0);
    this.ey = new box2d.b2Vec3(0, 1, 0);
    this.ez = new box2d.b2Vec3(0, 0, 1)
};
goog.exportSymbol("box2d.b2Mat33", box2d.b2Mat33);
box2d.b2Mat33.prototype.ex = null;
goog.exportProperty(box2d.b2Mat33.prototype, "ex", box2d.b2Mat33.prototype.ex);
box2d.b2Mat33.prototype.ey = null;
goog.exportProperty(box2d.b2Mat33.prototype, "ey", box2d.b2Mat33.prototype.ey);
box2d.b2Mat33.prototype.ez = null;
goog.exportProperty(box2d.b2Mat33.prototype, "ez", box2d.b2Mat33.prototype.ez);
box2d.b2Mat33.IDENTITY = new box2d.b2Mat33;
goog.exportProperty(box2d.b2Mat33, "IDENTITY", box2d.b2Mat33.IDENTITY);
box2d.b2Mat33.prototype.Clone = function() {
    return(new box2d.b2Mat33).Copy(this)
};
goog.exportProperty(box2d.b2Mat33.prototype, "Clone", box2d.b2Mat33.prototype.Clone);
box2d.b2Mat33.prototype.SetVVV = function(a, b, c) {
    this.ex.Copy(a);
    this.ey.Copy(b);
    this.ez.Copy(c);
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "SetVVV", box2d.b2Mat33.prototype.SetVVV);
box2d.b2Mat33.prototype.Copy = function(a) {
    this.ex.Copy(a.ex);
    this.ey.Copy(a.ey);
    this.ez.Copy(a.ez);
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "Copy", box2d.b2Mat33.prototype.Copy);
box2d.b2Mat33.prototype.SetIdentity = function() {
    this.ex.SetXYZ(1, 0, 0);
    this.ey.SetXYZ(0, 1, 0);
    this.ez.SetXYZ(0, 0, 1);
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "SetIdentity", box2d.b2Mat33.prototype.SetIdentity);
box2d.b2Mat33.prototype.SetZero = function() {
    this.ex.SetZero();
    this.ey.SetZero();
    this.ez.SetZero();
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "SetZero", box2d.b2Mat33.prototype.SetZero);
box2d.b2Mat33.prototype.SelfAddM = function(a) {
    this.ex.SelfAdd(a.ex);
    this.ey.SelfAdd(a.ey);
    this.ez.SelfAdd(a.ez);
    return this
};
goog.exportProperty(box2d.b2Mat33.prototype, "SelfAddM", box2d.b2Mat33.prototype.SelfAddM);
box2d.b2Mat33.prototype.Solve33 = function(a, b, c, e) {
    var d = this.ex.x, f = this.ex.y, g = this.ex.z, h = this.ey.x, l = this.ey.y, k = this.ey.z, m = this.ez.x, n = this.ez.y, p = this.ez.z, q = d * (l * p - k * n) + f * (k * m - h * p) + g * (h * n - l * m);
    0 != q && (q = 1 / q);
    e.x = q * (a * (l * p - k * n) + b * (k * m - h * p) + c * (h * n - l * m));
    e.y = q * (d * (b * p - c * n) + f * (c * m - a * p) + g * (a * n - b * m));
    e.z = q * (d * (l * c - k * b) + f * (k * a - h * c) + g * (h * b - l * a));
    return e
};
goog.exportProperty(box2d.b2Mat33.prototype, "Solve33", box2d.b2Mat33.prototype.Solve33);
box2d.b2Mat33.prototype.Solve22 = function(a, b, c) {
    var e = this.ex.x, d = this.ey.x, f = this.ex.y, g = this.ey.y, h = e * g - d * f;
    0 != h && (h = 1 / h);
    c.x = h * (g * a - d * b);
    c.y = h * (e * b - f * a);
    return c
};
goog.exportProperty(box2d.b2Mat33.prototype, "Solve22", box2d.b2Mat33.prototype.Solve22);
box2d.b2Mat33.prototype.GetInverse22 = function(a) {
    var b = this.ex.x, c = this.ey.x, e = this.ex.y, d = this.ey.y, f = b * d - c * e;
    0 != f && (f = 1 / f);
    a.ex.x = f * d;
    a.ey.x = -f * c;
    a.ex.z = 0;
    a.ex.y = -f * e;
    a.ey.y = f * b;
    a.ey.z = 0;
    a.ez.x = 0;
    a.ez.y = 0;
    a.ez.z = 0
};
goog.exportProperty(box2d.b2Mat33.prototype, "GetInverse22", box2d.b2Mat33.prototype.GetInverse22);
box2d.b2Mat33.prototype.GetSymInverse33 = function(a) {
    var b = box2d.b2DotV3V3(this.ex, box2d.b2CrossV3V3(this.ey, this.ez, box2d.b2Vec3.s_t0));
    0 != b && (b = 1 / b);
    var c = this.ex.x, e = this.ey.x, d = this.ez.x, f = this.ey.y, g = this.ez.y, h = this.ez.z;
    a.ex.x = b * (f * h - g * g);
    a.ex.y = b * (d * g - e * h);
    a.ex.z = b * (e * g - d * f);
    a.ey.x = a.ex.y;
    a.ey.y = b * (c * h - d * d);
    a.ey.z = b * (d * e - c * g);
    a.ez.x = a.ex.z;
    a.ez.y = a.ey.z;
    a.ez.z = b * (c * f - e * e)
};
goog.exportProperty(box2d.b2Mat33.prototype, "GetSymInverse33", box2d.b2Mat33.prototype.GetSymInverse33);
box2d.b2MulM33V3 = function(a, b, c) {
    var e = b.x, d = b.y;
    b = b.z;
    c.x = a.ex.x * e + a.ey.x * d + a.ez.x * b;
    c.y = a.ex.y * e + a.ey.y * d + a.ez.y * b;
    c.z = a.ex.z * e + a.ey.z * d + a.ez.z * b;
    return c
};
goog.exportSymbol("box2d.b2MulM33V3", box2d.b2MulM33V3);
box2d.b2MulM33XYZ = function(a, b, c, e, d) {
    d.x = a.ex.x * b + a.ey.x * c + a.ez.x * e;
    d.y = a.ex.y * b + a.ey.y * c + a.ez.y * e;
    d.z = a.ex.z * b + a.ey.z * c + a.ez.z * e;
    return d
};
goog.exportSymbol("box2d.b2MulM33XYZ", box2d.b2MulM33XYZ);
box2d.b2MulM33V2 = function(a, b, c) {
    var e = b.x;
    b = b.y;
    c.x = a.ex.x * e + a.ey.x * b;
    c.y = a.ex.y * e + a.ey.y * b;
    return c
};
goog.exportSymbol("box2d.b2MulM33V2", box2d.b2MulM33V2);
box2d.b2MulM33XY = function(a, b, c, e) {
    e.x = a.ex.x * b + a.ey.x * c;
    e.y = a.ex.y * b + a.ey.y * c;
    return e
};
goog.exportSymbol("box2d.b2MulM33XY", box2d.b2MulM33XY);
box2d.b2Rot = function(a) {
    a && (this.angle = a, this.s = Math.sin(a), this.c = Math.cos(a))
};
goog.exportSymbol("box2d.b2Rot", box2d.b2Rot);
box2d.b2Rot.prototype.angle = 0;
goog.exportProperty(box2d.b2Rot.prototype, "angle", box2d.b2Rot.prototype.angle);
box2d.b2Rot.prototype.s = 0;
goog.exportProperty(box2d.b2Rot.prototype, "s", box2d.b2Rot.prototype.s);
box2d.b2Rot.prototype.c = 1;
goog.exportProperty(box2d.b2Rot.prototype, "c", box2d.b2Rot.prototype.c);
box2d.b2Rot.IDENTITY = new box2d.b2Rot;
goog.exportProperty(box2d.b2Rot, "IDENTITY", box2d.b2Rot.IDENTITY);
box2d.b2Rot.prototype.Clone = function() {
    return(new box2d.b2Rot).Copy(this)
};
goog.exportProperty(box2d.b2Rot.prototype, "Clone", box2d.b2Rot.prototype.Clone);
box2d.b2Rot.prototype.Copy = function(a) {
    this.angle = a.angle;
    this.s = a.s;
    this.c = a.c;
    return this
};
goog.exportProperty(box2d.b2Rot.prototype, "Copy", box2d.b2Rot.prototype.Copy);
box2d.b2Rot.prototype.SetAngle = function(a) {
    this.angle != a && (this.angle = a, this.s = Math.sin(a), this.c = Math.cos(a));
    return this
};
goog.exportProperty(box2d.b2Rot.prototype, "SetAngle", box2d.b2Rot.prototype.SetAngle);
box2d.b2Rot.prototype.SetAngleRadians = box2d.b2Rot.prototype.SetAngle;
box2d.b2Rot.prototype.SetAngleDegrees = function(a) {
    return this.SetAngle(box2d.b2DegToRad(a))
};
box2d.b2Rot.prototype.SetIdentity = function() {
    this.s = this.angle = 0;
    this.c = 1;
    return this
};
goog.exportProperty(box2d.b2Rot.prototype, "SetIdentity", box2d.b2Rot.prototype.SetIdentity);
box2d.b2Rot.prototype.GetAngle = function() {
    return this.angle
};
goog.exportProperty(box2d.b2Rot.prototype, "GetAngle", box2d.b2Rot.prototype.GetAngle);
box2d.b2Rot.prototype.GetAngleRadians = box2d.b2Rot.prototype.GetAngle;
box2d.b2Rot.prototype.GetAngleDegrees = function() {
    return box2d.b2RadToDeg(this.GetAngle())
};
box2d.b2Rot.prototype.GetXAxis = function(a) {
    a.x = this.c;
    a.y = this.s;
    return a
};
goog.exportProperty(box2d.b2Rot.prototype, "GetXAxis", box2d.b2Rot.prototype.GetXAxis);
box2d.b2Rot.prototype.GetYAxis = function(a) {
    a.x = -this.s;
    a.y = this.c;
    return a
};
goog.exportProperty(box2d.b2Rot.prototype, "GetYAxis", box2d.b2Rot.prototype.GetYAxis);
box2d.b2MulRR = function(a, b, c) {
    var e = a.c;
    a = a.s;
    var d = b.c;
    b = b.s;
    c.s = a * d + e * b;
    c.c = e * d - a * b;
    return c
};
goog.exportSymbol("box2d.b2MulRR", box2d.b2MulRR);
box2d.b2MulTRR = function(a, b, c) {
    var e = a.c;
    a = a.s;
    var d = b.c;
    b = b.s;
    c.s = e * b - a * d;
    c.c = e * d + a * b;
    return c
};
goog.exportSymbol("box2d.b2MulTRR", box2d.b2MulTRR);
box2d.b2MulRV = function(a, b, c) {
    var e = a.c;
    a = a.s;
    var d = b.x;
    b = b.y;
    c.x = e * d - a * b;
    c.y = a * d + e * b;
    return c
};
goog.exportSymbol("box2d.b2MulRV", box2d.b2MulRV);
box2d.b2MulTRV = function(a, b, c) {
    var e = a.c;
    a = a.s;
    var d = b.x;
    b = b.y;
    c.x = e * d + a * b;
    c.y = -a * d + e * b;
    return c
};
goog.exportSymbol("box2d.b2MulTRV", box2d.b2MulTRV);
box2d.b2Transform = function() {
    this.p = new box2d.b2Vec2;
    this.q = new box2d.b2Rot
};
goog.exportSymbol("box2d.b2Transform", box2d.b2Transform);
box2d.b2Transform.prototype.p = null;
goog.exportProperty(box2d.b2Transform.prototype, "p", box2d.b2Transform.prototype.p);
box2d.b2Transform.prototype.q = null;
goog.exportProperty(box2d.b2Transform.prototype, "q", box2d.b2Transform.prototype.q);
box2d.b2Transform.IDENTITY = new box2d.b2Transform;
goog.exportProperty(box2d.b2Transform, "IDENTITY", box2d.b2Transform.IDENTITY);
box2d.b2Transform.prototype.Clone = function() {
    return(new box2d.b2Transform).Copy(this)
};
goog.exportProperty(box2d.b2Transform.prototype, "Clone", box2d.b2Transform.prototype.Clone);
box2d.b2Transform.prototype.Copy = function(a) {
    this.p.Copy(a.p);
    this.q.Copy(a.q);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "Copy", box2d.b2Transform.prototype.Copy);
box2d.b2Transform.prototype.SetIdentity = function() {
    this.p.SetZero();
    this.q.SetIdentity();
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetIdentity", box2d.b2Transform.prototype.SetIdentity);
box2d.b2Transform.prototype.SetPositionRotation = function(a, b) {
    this.p.Copy(a);
    this.q.Copy(b);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetPositionRotation", box2d.b2Transform.prototype.SetPositionRotation);
box2d.b2Transform.prototype.SetPositionAngleRadians = function(a, b) {
    this.p.Copy(a);
    this.q.SetAngleRadians(b);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetPositionAngleRadians", box2d.b2Transform.prototype.SetPositionAngleRadians);
box2d.b2Transform.prototype.SetPosition = function(a) {
    this.p.Copy(a);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetPosition", box2d.b2Transform.prototype.SetPosition);
box2d.b2Transform.prototype.SetPositionXY = function(a, b) {
    this.p.SetXY(a, b);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetPositionXY", box2d.b2Transform.prototype.SetPositionXY);
box2d.b2Transform.prototype.SetRotation = function(a) {
    this.q.Copy(a);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetRotation", box2d.b2Transform.prototype.SetRotation);
box2d.b2Transform.prototype.SetRotationAngleRadians = function(a) {
    this.q.SetAngleRadians(a);
    return this
};
goog.exportProperty(box2d.b2Transform.prototype, "SetRotationAngleRadians", box2d.b2Transform.prototype.SetRotationAngleRadians);
box2d.b2Transform.prototype.GetPosition = function() {
    return this.p
};
goog.exportProperty(box2d.b2Transform.prototype, "GetPosition", box2d.b2Transform.prototype.GetPosition);
box2d.b2Transform.prototype.GetRotation = function() {
    return this.q
};
goog.exportProperty(box2d.b2Transform.prototype, "GetRotation", box2d.b2Transform.prototype.GetRotation);
box2d.b2Transform.prototype.GetRotationAngle = function() {
    return this.q.GetAngle()
};
goog.exportProperty(box2d.b2Transform.prototype, "GetRotationAngle", box2d.b2Transform.prototype.GetRotationAngle);
box2d.b2Transform.prototype.GetRotationAngleRadians = box2d.b2Transform.prototype.GetRotationAngle;
box2d.b2Transform.prototype.GetAngle = function() {
    return this.q.GetAngle()
};
goog.exportProperty(box2d.b2Transform.prototype, "GetAngle", box2d.b2Transform.prototype.GetAngle);
box2d.b2Transform.prototype.GetAngleRadians = box2d.b2Transform.prototype.GetAngle;
box2d.b2MulXV = function(a, b, c) {
    var e = a.q.c, d = a.q.s, f = b.x;
    b = b.y;
    c.x = e * f - d * b + a.p.x;
    c.y = d * f + e * b + a.p.y;
    return c
};
goog.exportSymbol("box2d.b2MulXV", box2d.b2MulXV);
box2d.b2MulTXV = function(a, b, c) {
    var e = a.q.c, d = a.q.s, f = b.x - a.p.x;
    a = b.y - a.p.y;
    c.x = e * f + d * a;
    c.y = -d * f + e * a;
    return c
};
goog.exportSymbol("box2d.b2MulTXV", box2d.b2MulTXV);
box2d.b2MulXX = function(a, b, c) {
    box2d.b2MulRR(a.q, b.q, c.q);
    box2d.b2AddVV(box2d.b2MulRV(a.q, b.p, c.p), a.p, c.p);
    return c
};
goog.exportSymbol("box2d.b2MulXX", box2d.b2MulXX);
box2d.b2MulTXX = function(a, b, c) {
    box2d.b2MulTRR(a.q, b.q, c.q);
    box2d.b2MulTRV(a.q, box2d.b2SubVV(b.p, a.p, c.p), c.p);
    return c
};
goog.exportSymbol("box2d.b2MulTXX", box2d.b2MulTXX);
box2d.b2Sweep = function() {
    this.localCenter = new box2d.b2Vec2;
    this.c0 = new box2d.b2Vec2;
    this.c = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Sweep", box2d.b2Sweep);
box2d.b2Sweep.prototype.localCenter = null;
goog.exportProperty(box2d.b2Sweep.prototype, "localCenter", box2d.b2Sweep.prototype.localCenter);
box2d.b2Sweep.prototype.c0 = null;
goog.exportProperty(box2d.b2Sweep.prototype, "c0", box2d.b2Sweep.prototype.c0);
box2d.b2Sweep.prototype.c = null;
goog.exportProperty(box2d.b2Sweep.prototype, "c", box2d.b2Sweep.prototype.c);
box2d.b2Sweep.prototype.a0 = 0;
goog.exportProperty(box2d.b2Sweep.prototype, "a0", box2d.b2Sweep.prototype.a0);
box2d.b2Sweep.prototype.a = 0;
goog.exportProperty(box2d.b2Sweep.prototype, "a", box2d.b2Sweep.prototype.a);
box2d.b2Sweep.prototype.alpha0 = 0;
goog.exportProperty(box2d.b2Sweep.prototype, "alpha0", box2d.b2Sweep.prototype.alpha0);
box2d.b2Sweep.prototype.Clone = function() {
    return(new box2d.b2Sweep).Copy(this)
};
goog.exportProperty(box2d.b2Sweep.prototype, "Clone", box2d.b2Sweep.prototype.Clone);
box2d.b2Sweep.prototype.Copy = function(a) {
    this.localCenter.Copy(a.localCenter);
    this.c0.Copy(a.c0);
    this.c.Copy(a.c);
    this.a0 = a.a0;
    this.a = a.a;
    this.alpha0 = a.alpha0;
    return this
};
goog.exportProperty(box2d.b2Sweep.prototype, "Copy", box2d.b2Sweep.prototype.Copy);
box2d.b2Sweep.prototype.GetTransform = function(a, b) {
    var c = 1 - b;
    a.p.x = c * this.c0.x + b * this.c.x;
    a.p.y = c * this.c0.y + b * this.c.y;
    a.q.SetAngleRadians(c * this.a0 + b * this.a);
    a.p.SelfSub(box2d.b2MulRV(a.q, this.localCenter, box2d.b2Vec2.s_t0));
    return a
};
goog.exportProperty(box2d.b2Sweep.prototype, "GetTransform", box2d.b2Sweep.prototype.GetTransform);
box2d.b2Sweep.prototype.Advance = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(1 > this.alpha0);
    var b = (a - this.alpha0) / (1 - this.alpha0), c = 1 - b;
    this.c0.x = c * this.c0.x + b * this.c.x;
    this.c0.y = c * this.c0.y + b * this.c.y;
    this.a0 = c * this.a0 + b * this.a;
    this.alpha0 = a
};
goog.exportProperty(box2d.b2Sweep.prototype, "Advance", box2d.b2Sweep.prototype.Advance);
box2d.b2Sweep.prototype.Normalize = function() {
    var a = box2d.b2_two_pi * Math.floor(this.a0 / box2d.b2_two_pi);
    this.a0 -= a;
    this.a -= a
};
goog.exportProperty(box2d.b2Sweep.prototype, "Normalize", box2d.b2Sweep.prototype.Normalize);
box2d.b2ControllerEdge = function() {
};
goog.exportSymbol("box2d.b2ControllerEdge", box2d.b2ControllerEdge);
box2d.b2ControllerEdge.prototype.controller = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "controller", box2d.b2ControllerEdge.prototype.controller);
box2d.b2ControllerEdge.prototype.body = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "body", box2d.b2ControllerEdge.prototype.body);
box2d.b2ControllerEdge.prototype.prevBody = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "prevBody", box2d.b2ControllerEdge.prototype.prevBody);
box2d.b2ControllerEdge.prototype.nextBody = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "nextBody", box2d.b2ControllerEdge.prototype.nextBody);
box2d.b2ControllerEdge.prototype.prevController = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "prevController", box2d.b2ControllerEdge.prototype.prevController);
box2d.b2ControllerEdge.prototype.nextController = null;
goog.exportProperty(box2d.b2ControllerEdge.prototype, "nextController", box2d.b2ControllerEdge.prototype.nextController);
box2d.b2Controller = function() {
};
goog.exportSymbol("box2d.b2Controller", box2d.b2Controller);
box2d.b2Controller.prototype.m_world = null;
goog.exportProperty(box2d.b2Controller.prototype, "m_world", box2d.b2Controller.prototype.m_world);
box2d.b2Controller.prototype.m_bodyList = null;
goog.exportProperty(box2d.b2Controller.prototype, "m_bodyList", box2d.b2Controller.prototype.m_bodyList);
box2d.b2Controller.prototype.m_bodyCount = 0;
goog.exportProperty(box2d.b2Controller.prototype, "m_bodyCount", box2d.b2Controller.prototype.m_bodyCount);
box2d.b2Controller.prototype.m_prev = null;
goog.exportProperty(box2d.b2Controller.prototype, "m_prev", box2d.b2Controller.prototype.m_prev);
box2d.b2Controller.prototype.m_next = null;
goog.exportProperty(box2d.b2Controller.prototype, "m_next", box2d.b2Controller.prototype.m_next);
box2d.b2Controller.prototype.Step = function(a) {
};
goog.exportProperty(box2d.b2Controller.prototype, "Step", box2d.b2Controller.prototype.Step);
box2d.b2Controller.prototype.Draw = function(a) {
};
goog.exportProperty(box2d.b2Controller.prototype, "Draw", box2d.b2Controller.prototype.Draw);
box2d.b2Controller.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Controller.prototype, "GetNext", box2d.b2Controller.prototype.GetNext);
box2d.b2Controller.prototype.GetPrev = function() {
    return this.m_prev
};
goog.exportProperty(box2d.b2Controller.prototype, "GetPrev", box2d.b2Controller.prototype.GetPrev);
box2d.b2Controller.prototype.GetWorld = function() {
    return this.m_world
};
goog.exportProperty(box2d.b2Controller.prototype, "GetWorld", box2d.b2Controller.prototype.GetWorld);
box2d.b2Controller.prototype.GetBodyList = function() {
    return this.m_bodyList
};
goog.exportProperty(box2d.b2Controller.prototype, "GetBodyList", box2d.b2Controller.prototype.GetBodyList);
box2d.b2Controller.prototype.AddBody = function(a) {
    var b = new box2d.b2ControllerEdge;
    b.body = a;
    b.controller = this;
    b.nextBody = this.m_bodyList;
    b.prevBody = null;
    this.m_bodyList && (this.m_bodyList.prevBody = b);
    this.m_bodyList = b;
    ++this.m_bodyCount;
    b.nextController = a.m_controllerList;
    b.prevController = null;
    a.m_controllerList && (a.m_controllerList.prevController = b);
    a.m_controllerList = b;
    ++a.m_controllerCount
};
goog.exportProperty(box2d.b2Controller.prototype, "AddBody", box2d.b2Controller.prototype.AddBody);
box2d.b2Controller.prototype.RemoveBody = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_bodyCount);
    for (var b = this.m_bodyList; b && b.body != a; )
        b = b.nextBody;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null != b);
    b.prevBody && (b.prevBody.nextBody = b.nextBody);
    b.nextBody && (b.nextBody.prevBody = b.prevBody);
    this.m_bodyList == b && (this.m_bodyList = b.nextBody);
    --this.m_bodyCount;
    b.nextController && (b.nextController.prevController = b.prevController);
    b.prevController && (b.prevController.nextController = b.nextController);
    a.m_controllerList == b && (a.m_controllerList = b.nextController);
    --a.m_controllerCount
};
goog.exportProperty(box2d.b2Controller.prototype, "RemoveBody", box2d.b2Controller.prototype.RemoveBody);
box2d.b2Controller.prototype.Clear = function() {
    for (; this.m_bodyList; )
        this.RemoveBody(this.m_bodyList.body);
    this.m_bodyCount = 0
};
goog.exportProperty(box2d.b2Controller.prototype, "Clear", box2d.b2Controller.prototype.Clear);
box2d.b2ConstantAccelController = function() {
    box2d.b2Controller.call(this);
    this.A = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2ConstantAccelController, box2d.b2Controller);
goog.exportSymbol("box2d.b2ConstantAccelController", box2d.b2ConstantAccelController);
box2d.b2ConstantAccelController.prototype.A = null;
goog.exportProperty(box2d.b2ConstantAccelController.prototype, "A", box2d.b2ConstantAccelController.prototype.A);
box2d.b2ConstantAccelController.prototype.Step = function(a) {
    a = box2d.b2MulSV(a.dt, this.A, box2d.b2ConstantAccelController.prototype.Step.s_dtA);
    for (var b = this.m_bodyList; b; b = b.nextBody) {
        var c = b.body;
        c.IsAwake() && c.SetLinearVelocity(box2d.b2AddVV(c.GetLinearVelocity(), a, box2d.b2Vec2.s_t0))
    }
};
goog.exportProperty(box2d.b2ConstantAccelController.prototype, "Step", box2d.b2ConstantAccelController.prototype.Step);
box2d.b2ConstantAccelController.prototype.Step.s_dtA = new box2d.b2Vec2;
box2d.b2JointType = {e_unknownJoint: 0, e_revoluteJoint: 1, e_prismaticJoint: 2, e_distanceJoint: 3, e_pulleyJoint: 4, e_mouseJoint: 5, e_gearJoint: 6, e_wheelJoint: 7, e_weldJoint: 8, e_frictionJoint: 9, e_ropeJoint: 10, e_motorJoint: 11, e_areaJoint: 12};
goog.exportSymbol("box2d.b2JointType", box2d.b2JointType);
goog.exportProperty(box2d.b2JointType, "e_unknownJoint", box2d.b2JointType.e_unknownJoint);
goog.exportProperty(box2d.b2JointType, "e_revoluteJoint", box2d.b2JointType.e_revoluteJoint);
goog.exportProperty(box2d.b2JointType, "e_prismaticJoint", box2d.b2JointType.e_prismaticJoint);
goog.exportProperty(box2d.b2JointType, "e_distanceJoint", box2d.b2JointType.e_distanceJoint);
goog.exportProperty(box2d.b2JointType, "e_pulleyJoint", box2d.b2JointType.e_pulleyJoint);
goog.exportProperty(box2d.b2JointType, "e_mouseJoint", box2d.b2JointType.e_mouseJoint);
goog.exportProperty(box2d.b2JointType, "e_gearJoint", box2d.b2JointType.e_gearJoint);
goog.exportProperty(box2d.b2JointType, "e_wheelJoint", box2d.b2JointType.e_wheelJoint);
goog.exportProperty(box2d.b2JointType, "e_weldJoint", box2d.b2JointType.e_weldJoint);
goog.exportProperty(box2d.b2JointType, "e_frictionJoint", box2d.b2JointType.e_frictionJoint);
goog.exportProperty(box2d.b2JointType, "e_ropeJoint", box2d.b2JointType.e_ropeJoint);
goog.exportProperty(box2d.b2JointType, "e_motorJoint", box2d.b2JointType.e_motorJoint);
goog.exportProperty(box2d.b2JointType, "e_areaJoint", box2d.b2JointType.e_areaJoint);
box2d.b2LimitState = {e_inactiveLimit: 0, e_atLowerLimit: 1, e_atUpperLimit: 2, e_equalLimits: 3};
goog.exportSymbol("box2d.b2LimitState", box2d.b2LimitState);
goog.exportProperty(box2d.b2LimitState, "e_inactiveLimit", box2d.b2LimitState.e_inactiveLimit);
goog.exportProperty(box2d.b2LimitState, "e_atLowerLimit", box2d.b2LimitState.e_atLowerLimit);
goog.exportProperty(box2d.b2LimitState, "e_atUpperLimit", box2d.b2LimitState.e_atUpperLimit);
goog.exportProperty(box2d.b2LimitState, "e_equalLimits", box2d.b2LimitState.e_equalLimits);
box2d.b2Jacobian = function() {
    this.linear = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Jacobian", box2d.b2Jacobian);
box2d.b2Jacobian.prototype.linear = null;
goog.exportProperty(box2d.b2Jacobian.prototype, "linear", box2d.b2Jacobian.prototype.linear);
box2d.b2Jacobian.prototype.angularA = 0;
goog.exportProperty(box2d.b2Jacobian.prototype, "angularA", box2d.b2Jacobian.prototype.angularA);
box2d.b2Jacobian.prototype.angularB = 0;
goog.exportProperty(box2d.b2Jacobian.prototype, "angularB", box2d.b2Jacobian.prototype.angularB);
box2d.b2Jacobian.prototype.SetZero = function() {
    this.linear.SetZero();
    this.angularB = this.angularA = 0;
    return this
};
goog.exportProperty(box2d.b2Jacobian.prototype, "SetZero", box2d.b2Jacobian.prototype.SetZero);
box2d.b2Jacobian.prototype.Set = function(a, b, c) {
    this.linear.Copy(a);
    this.angularA = b;
    this.angularB = c;
    return this
};
goog.exportProperty(box2d.b2Jacobian.prototype, "Set", box2d.b2Jacobian.prototype.Set);
box2d.b2JointEdge = function() {
};
goog.exportSymbol("box2d.b2JointEdge", box2d.b2JointEdge);
box2d.b2JointEdge.prototype.other = null;
goog.exportProperty(box2d.b2JointEdge.prototype, "other", box2d.b2JointEdge.prototype.other);
box2d.b2JointEdge.prototype.joint = null;
goog.exportProperty(box2d.b2JointEdge.prototype, "joint", box2d.b2JointEdge.prototype.joint);
box2d.b2JointEdge.prototype.prev = null;
goog.exportProperty(box2d.b2JointEdge.prototype, "prev", box2d.b2JointEdge.prototype.prev);
box2d.b2JointEdge.prototype.next = null;
goog.exportProperty(box2d.b2JointEdge.prototype, "next", box2d.b2JointEdge.prototype.next);
box2d.b2JointDef = function(a) {
    this.type = a
};
goog.exportSymbol("box2d.b2JointDef", box2d.b2JointDef);
box2d.b2JointDef.prototype.type = box2d.b2JointType.e_unknownJoint;
goog.exportProperty(box2d.b2JointDef.prototype, "type", box2d.b2JointDef.prototype.type);
box2d.b2JointDef.prototype.userData = null;
goog.exportProperty(box2d.b2JointDef.prototype, "userData", box2d.b2JointDef.prototype.userData);
box2d.b2JointDef.prototype.bodyA = null;
goog.exportProperty(box2d.b2JointDef.prototype, "bodyA", box2d.b2JointDef.prototype.bodyA);
box2d.b2JointDef.prototype.bodyB = null;
goog.exportProperty(box2d.b2JointDef.prototype, "bodyB", box2d.b2JointDef.prototype.bodyB);
box2d.b2JointDef.prototype.collideConnected = !1;
goog.exportProperty(box2d.b2JointDef.prototype, "collideConnected", box2d.b2JointDef.prototype.collideConnected);
box2d.b2Joint = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.bodyA != a.bodyB);
    this.m_type = a.type;
    this.m_edgeA = new box2d.b2JointEdge;
    this.m_edgeB = new box2d.b2JointEdge;
    this.m_bodyA = a.bodyA;
    this.m_bodyB = a.bodyB;
    this.m_collideConnected = a.collideConnected;
    this.m_userData = a.userData
};
goog.exportSymbol("box2d.b2Joint", box2d.b2Joint);
box2d.b2Joint.prototype.m_type = box2d.b2JointType.e_unknownJoint;
goog.exportProperty(box2d.b2Joint.prototype, "m_type", box2d.b2Joint.prototype.m_type);
box2d.b2Joint.prototype.m_prev = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_prev", box2d.b2Joint.prototype.m_prev);
box2d.b2Joint.prototype.m_next = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_next", box2d.b2Joint.prototype.m_next);
box2d.b2Joint.prototype.m_edgeA = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_edgeA", box2d.b2Joint.prototype.m_edgeA);
box2d.b2Joint.prototype.m_edgeB = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_edgeB", box2d.b2Joint.prototype.m_edgeB);
box2d.b2Joint.prototype.m_bodyA = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_bodyA", box2d.b2Joint.prototype.m_bodyA);
box2d.b2Joint.prototype.m_bodyB = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_bodyB", box2d.b2Joint.prototype.m_bodyB);
box2d.b2Joint.prototype.m_index = 0;
goog.exportProperty(box2d.b2Joint.prototype, "m_index", box2d.b2Joint.prototype.m_index);
box2d.b2Joint.prototype.m_islandFlag = !1;
goog.exportProperty(box2d.b2Joint.prototype, "m_islandFlag", box2d.b2Joint.prototype.m_islandFlag);
box2d.b2Joint.prototype.m_collideConnected = !1;
goog.exportProperty(box2d.b2Joint.prototype, "m_collideConnected", box2d.b2Joint.prototype.m_collideConnected);
box2d.b2Joint.prototype.m_userData = null;
goog.exportProperty(box2d.b2Joint.prototype, "m_userData", box2d.b2Joint.prototype.m_userData);
box2d.b2Joint.prototype.GetAnchorA = function(a) {
    return a.SetZero()
};
goog.exportProperty(box2d.b2Joint.prototype, "GetAnchorA", box2d.b2Joint.prototype.GetAnchorA);
box2d.b2Joint.prototype.GetAnchorB = function(a) {
    return a.SetZero()
};
goog.exportProperty(box2d.b2Joint.prototype, "GetAnchorB", box2d.b2Joint.prototype.GetAnchorB);
box2d.b2Joint.prototype.GetReactionForce = function(a, b) {
    return b.SetZero()
};
goog.exportProperty(box2d.b2Joint.prototype, "GetReactionForce", box2d.b2Joint.prototype.GetReactionForce);
box2d.b2Joint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2Joint.prototype, "GetReactionTorque", box2d.b2Joint.prototype.GetReactionTorque);
box2d.b2Joint.prototype.InitVelocityConstraints = function(a) {
};
goog.exportProperty(box2d.b2Joint.prototype, "InitVelocityConstraints", box2d.b2Joint.prototype.InitVelocityConstraints);
box2d.b2Joint.prototype.SolveVelocityConstraints = function(a) {
};
goog.exportProperty(box2d.b2Joint.prototype, "SolveVelocityConstraints", box2d.b2Joint.prototype.SolveVelocityConstraints);
box2d.b2Joint.prototype.SolvePositionConstraints = function(a) {
    return!1
};
goog.exportProperty(box2d.b2Joint.prototype, "SolvePositionConstraints", box2d.b2Joint.prototype.SolvePositionConstraints);
box2d.b2Joint.prototype.GetType = function() {
    return this.m_type
};
goog.exportProperty(box2d.b2Joint.prototype, "GetType", box2d.b2Joint.prototype.GetType);
box2d.b2Joint.prototype.GetBodyA = function() {
    return this.m_bodyA
};
goog.exportProperty(box2d.b2Joint.prototype, "GetBodyA", box2d.b2Joint.prototype.GetBodyA);
box2d.b2Joint.prototype.GetBodyB = function() {
    return this.m_bodyB
};
goog.exportProperty(box2d.b2Joint.prototype, "GetBodyB", box2d.b2Joint.prototype.GetBodyB);
box2d.b2Joint.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Joint.prototype, "GetNext", box2d.b2Joint.prototype.GetNext);
box2d.b2Joint.prototype.GetUserData = function() {
    return this.m_userData
};
goog.exportProperty(box2d.b2Joint.prototype, "GetUserData", box2d.b2Joint.prototype.GetUserData);
box2d.b2Joint.prototype.SetUserData = function(a) {
    this.m_userData = a
};
goog.exportProperty(box2d.b2Joint.prototype, "SetUserData", box2d.b2Joint.prototype.SetUserData);
box2d.b2Joint.prototype.GetCollideConnected = function() {
    return this.m_collideConnected
};
goog.exportProperty(box2d.b2Joint.prototype, "GetCollideConnected", box2d.b2Joint.prototype.GetCollideConnected);
box2d.b2Joint.prototype.Dump = function() {
    box2d.DEBUG && box2d.b2Log("// Dump is not supported for this joint type.\n")
};
goog.exportProperty(box2d.b2Joint.prototype, "Dump", box2d.b2Joint.prototype.Dump);
box2d.b2Joint.prototype.IsActive = function() {
    return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
};
goog.exportProperty(box2d.b2Joint.prototype, "IsActive", box2d.b2Joint.prototype.IsActive);
box2d.b2Joint.prototype.ShiftOrigin = function(a) {
};
goog.exportProperty(box2d.b2Joint.prototype, "ShiftOrigin", box2d.b2Joint.prototype.ShiftOrigin);
box2d.b2RevoluteJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_revoluteJoint);
    this.localAnchorA = new box2d.b2Vec2(0, 0);
    this.localAnchorB = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2RevoluteJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2RevoluteJointDef", box2d.b2RevoluteJointDef);
box2d.b2RevoluteJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "localAnchorA", box2d.b2RevoluteJointDef.prototype.localAnchorA);
box2d.b2RevoluteJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "localAnchorB", box2d.b2RevoluteJointDef.prototype.localAnchorB);
box2d.b2RevoluteJointDef.prototype.referenceAngle = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "referenceAngle", box2d.b2RevoluteJointDef.prototype.referenceAngle);
box2d.b2RevoluteJointDef.prototype.enableLimit = !1;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "enableLimit", box2d.b2RevoluteJointDef.prototype.enableLimit);
box2d.b2RevoluteJointDef.prototype.lowerAngle = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "lowerAngle", box2d.b2RevoluteJointDef.prototype.lowerAngle);
box2d.b2RevoluteJointDef.prototype.upperAngle = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "upperAngle", box2d.b2RevoluteJointDef.prototype.upperAngle);
box2d.b2RevoluteJointDef.prototype.enableMotor = !1;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "enableMotor", box2d.b2RevoluteJointDef.prototype.enableMotor);
box2d.b2RevoluteJointDef.prototype.motorSpeed = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "motorSpeed", box2d.b2RevoluteJointDef.prototype.motorSpeed);
box2d.b2RevoluteJointDef.prototype.maxMotorTorque = 0;
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "maxMotorTorque", box2d.b2RevoluteJointDef.prototype.maxMotorTorque);
box2d.b2RevoluteJointDef.prototype.Initialize = function(a, b, c) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB);
    this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
};
goog.exportProperty(box2d.b2RevoluteJointDef.prototype, "Initialize", box2d.b2RevoluteJointDef.prototype.Initialize);
box2d.b2RevoluteJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorA = new box2d.b2Vec2;
    this.m_localAnchorB = new box2d.b2Vec2;
    this.m_impulse = new box2d.b2Vec3;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_mass = new box2d.b2Mat33;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_K = new box2d.b2Mat22;
    this.m_localAnchorA.Copy(a.localAnchorA);
    this.m_localAnchorB.Copy(a.localAnchorB);
    this.m_referenceAngle = a.referenceAngle;
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0;
    this.m_lowerAngle = a.lowerAngle;
    this.m_upperAngle = a.upperAngle;
    this.m_maxMotorTorque = a.maxMotorTorque;
    this.m_motorSpeed = a.motorSpeed;
    this.m_enableLimit = a.enableLimit;
    this.m_enableMotor = a.enableMotor;
    this.m_limitState = box2d.b2LimitState.e_inactiveLimit
};
goog.inherits(box2d.b2RevoluteJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2RevoluteJoint", box2d.b2RevoluteJoint);
box2d.b2RevoluteJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_localAnchorA", box2d.b2RevoluteJoint.prototype.m_localAnchorA);
box2d.b2RevoluteJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_localAnchorB", box2d.b2RevoluteJoint.prototype.m_localAnchorB);
box2d.b2RevoluteJoint.prototype.m_impulse = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_impulse", box2d.b2RevoluteJoint.prototype.m_impulse);
box2d.b2RevoluteJoint.prototype.m_motorImpulse = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_motorImpulse", box2d.b2RevoluteJoint.prototype.m_motorImpulse);
box2d.b2RevoluteJoint.prototype.m_enableMotor = !1;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_enableMotor", box2d.b2RevoluteJoint.prototype.m_enableMotor);
box2d.b2RevoluteJoint.prototype.m_maxMotorTorque = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_maxMotorTorque", box2d.b2RevoluteJoint.prototype.m_maxMotorTorque);
box2d.b2RevoluteJoint.prototype.m_motorSpeed = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_motorSpeed", box2d.b2RevoluteJoint.prototype.m_motorSpeed);
box2d.b2RevoluteJoint.prototype.m_enableLimit = !1;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_enableLimit", box2d.b2RevoluteJoint.prototype.m_enableLimit);
box2d.b2RevoluteJoint.prototype.m_referenceAngle = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_referenceAngle", box2d.b2RevoluteJoint.prototype.m_referenceAngle);
box2d.b2RevoluteJoint.prototype.m_lowerAngle = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_lowerAngle", box2d.b2RevoluteJoint.prototype.m_lowerAngle);
box2d.b2RevoluteJoint.prototype.m_upperAngle = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_upperAngle", box2d.b2RevoluteJoint.prototype.m_upperAngle);
box2d.b2RevoluteJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_indexA", box2d.b2RevoluteJoint.prototype.m_indexA);
box2d.b2RevoluteJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_indexB", box2d.b2RevoluteJoint.prototype.m_indexB);
box2d.b2RevoluteJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_rA", box2d.b2RevoluteJoint.prototype.m_rA);
box2d.b2RevoluteJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_rB", box2d.b2RevoluteJoint.prototype.m_rB);
box2d.b2RevoluteJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_localCenterA", box2d.b2RevoluteJoint.prototype.m_localCenterA);
box2d.b2RevoluteJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_localCenterB", box2d.b2RevoluteJoint.prototype.m_localCenterB);
box2d.b2RevoluteJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_invMassA", box2d.b2RevoluteJoint.prototype.m_invMassA);
box2d.b2RevoluteJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_invMassB", box2d.b2RevoluteJoint.prototype.m_invMassB);
box2d.b2RevoluteJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_invIA", box2d.b2RevoluteJoint.prototype.m_invIA);
box2d.b2RevoluteJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_invIB", box2d.b2RevoluteJoint.prototype.m_invIB);
box2d.b2RevoluteJoint.prototype.m_mass = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_mass", box2d.b2RevoluteJoint.prototype.m_mass);
box2d.b2RevoluteJoint.prototype.m_motorMass = 0;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_motorMass", box2d.b2RevoluteJoint.prototype.m_motorMass);
box2d.b2RevoluteJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_limitState", box2d.b2RevoluteJoint.prototype.m_limitState);
box2d.b2RevoluteJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_qA", box2d.b2RevoluteJoint.prototype.m_qA);
box2d.b2RevoluteJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_qB", box2d.b2RevoluteJoint.prototype.m_qB);
box2d.b2RevoluteJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_lalcA", box2d.b2RevoluteJoint.prototype.m_lalcA);
box2d.b2RevoluteJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_lalcB", box2d.b2RevoluteJoint.prototype.m_lalcB);
box2d.b2RevoluteJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "m_K", box2d.b2RevoluteJoint.prototype.m_K);
box2d.b2RevoluteJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].a, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].a, f = a.velocities[this.m_indexB].v, g = a.velocities[this.m_indexB].w, h = this.m_qA.SetAngleRadians(b), l = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(h, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(l, this.m_lalcB, this.m_rB);
    var h = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB, n = 0 == k + m;
    this.m_mass.ex.x = h + l + this.m_rA.y * this.m_rA.y * k + this.m_rB.y *
            this.m_rB.y * m;
    this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * k - this.m_rB.y * this.m_rB.x * m;
    this.m_mass.ez.x = -this.m_rA.y * k - this.m_rB.y * m;
    this.m_mass.ex.y = this.m_mass.ey.x;
    this.m_mass.ey.y = h + l + this.m_rA.x * this.m_rA.x * k + this.m_rB.x * this.m_rB.x * m;
    this.m_mass.ez.y = this.m_rA.x * k + this.m_rB.x * m;
    this.m_mass.ex.z = this.m_mass.ez.x;
    this.m_mass.ey.z = this.m_mass.ez.y;
    this.m_mass.ez.z = k + m;
    this.m_motorMass = k + m;
    0 < this.m_motorMass && (this.m_motorMass = 1 / this.m_motorMass);
    if (!1 == this.m_enableMotor || n)
        this.m_motorImpulse = 0;
    this.m_enableLimit && !1 == n ? (b = d - b - this.m_referenceAngle, box2d.b2Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * box2d.b2_angularSlop ? this.m_limitState = box2d.b2LimitState.e_equalLimits : b <= this.m_lowerAngle ? (this.m_limitState != box2d.b2LimitState.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = box2d.b2LimitState.e_atLowerLimit) : b >= this.m_upperAngle ? (this.m_limitState != box2d.b2LimitState.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = box2d.b2LimitState.e_atUpperLimit) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit,
            this.m_impulse.z = 0)) : this.m_limitState = box2d.b2LimitState.e_inactiveLimit;
    a.step.warmStarting ? (this.m_impulse.SelfMul(a.step.dtRatio), this.m_motorImpulse *= a.step.dtRatio, b = box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y), c.SelfMulSub(h, b), e -= k * (box2d.b2CrossVV(this.m_rA, b) + this.m_motorImpulse + this.m_impulse.z), f.SelfMulAdd(l, b), g += m * (box2d.b2CrossVV(this.m_rB, b) + this.m_motorImpulse + this.m_impulse.z)) : (this.m_impulse.SetZero(), this.m_motorImpulse =
            0);
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w = g
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "InitVelocityConstraints", box2d.b2RevoluteJoint.prototype.InitVelocityConstraints);
box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB, k = 0 == h + l;
    if (this.m_enableMotor && this.m_limitState != box2d.b2LimitState.e_equalLimits && !1 == k) {
        var m = d - c - this.m_motorSpeed, m = -this.m_motorMass * m, n = this.m_motorImpulse, p = a.step.dt * this.m_maxMotorTorque;
        this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse +
                m, -p, p);
        m = this.m_motorImpulse - n;
        c -= h * m;
        d += l * m
    }
    this.m_enableLimit && this.m_limitState != box2d.b2LimitState.e_inactiveLimit && !1 == k ? (k = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1), m = this.m_mass.Solve33(k.x, k.y, d - c, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3).SelfNeg(), this.m_limitState == box2d.b2LimitState.e_equalLimits ? this.m_impulse.SelfAdd(m) :
            this.m_limitState == box2d.b2LimitState.e_atLowerLimit ? (n = this.m_impulse.z + m.z, 0 > n ? (n = -k.x + this.m_impulse.z * this.m_mass.ez.x, k = -k.y + this.m_impulse.z * this.m_mass.ez.y, k = this.m_mass.Solve22(n, k, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced), m.x = k.x, m.y = k.y, m.z = -this.m_impulse.z, this.m_impulse.x += k.x, this.m_impulse.y += k.y, this.m_impulse.z = 0) : this.m_impulse.SelfAdd(m)) : this.m_limitState == box2d.b2LimitState.e_atUpperLimit && (n = this.m_impulse.z + m.z, 0 < n ? (n = -k.x + this.m_impulse.z * this.m_mass.ez.x,
            k = -k.y + this.m_impulse.z * this.m_mass.ez.y, k = this.m_mass.Solve22(n, k, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced), m.x = k.x, m.y = k.y, m.z = -this.m_impulse.z, this.m_impulse.x += k.x, this.m_impulse.y += k.y, this.m_impulse.z = 0) : this.m_impulse.SelfAdd(m)), k = box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P.SetXY(m.x, m.y), b.SelfMulSub(f, k), c -= h * (box2d.b2CrossVV(this.m_rA, k) + m.z), e.SelfMulAdd(g, k), d += l * (box2d.b2CrossVV(this.m_rB, k) + m.z)) : (m = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB,
            box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot), m = this.m_mass.Solve22(-m.x, -m.y, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2), this.m_impulse.x += m.x, this.m_impulse.y += m.y, b.SelfMulSub(f, m), c -= h * box2d.b2CrossVV(this.m_rA, m), e.SelfMulAdd(g, m), d += l * box2d.b2CrossVV(this.m_rB, m));
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SolveVelocityConstraints", box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints);
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3 = new box2d.b2Vec3;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2 = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d), h = 0, l = 0, l = 0 == this.m_invIA + this.m_invIB;
    if (this.m_enableLimit && this.m_limitState != box2d.b2LimitState.e_inactiveLimit && !1 == l) {
        var k = d - c - this.m_referenceAngle, l = 0;
        this.m_limitState == box2d.b2LimitState.e_equalLimits ? (k = box2d.b2Clamp(k - this.m_lowerAngle,
                -box2d.b2_maxAngularCorrection, box2d.b2_maxAngularCorrection), l = -this.m_motorMass * k, h = box2d.b2Abs(k)) : this.m_limitState == box2d.b2LimitState.e_atLowerLimit ? (k -= this.m_lowerAngle, h = -k, k = box2d.b2Clamp(k + box2d.b2_angularSlop, -box2d.b2_maxAngularCorrection, 0), l = -this.m_motorMass * k) : this.m_limitState == box2d.b2LimitState.e_atUpperLimit && (h = k -= this.m_upperAngle, k = box2d.b2Clamp(k - box2d.b2_angularSlop, 0, box2d.b2_maxAngularCorrection), l = -this.m_motorMass * k);
        c -= this.m_invIA * l;
        d += this.m_invIB * l
    }
    f.SetAngleRadians(c);
    g.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    f = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var g = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), k = box2d.b2SubVV(box2d.b2AddVV(e, g, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, f, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C), l = k.GetLength(), m = this.m_invMassA, n = this.m_invMassB, p = this.m_invIA, q = this.m_invIB, r = this.m_K;
    r.ex.x = m + n +
            p * f.y * f.y + q * g.y * g.y;
    r.ex.y = -p * f.x * f.y - q * g.x * g.y;
    r.ey.x = r.ex.y;
    r.ey.y = m + n + p * f.x * f.x + q * g.x * g.x;
    k = r.Solve(k.x, k.y, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg();
    b.SelfMulSub(m, k);
    c -= p * box2d.b2CrossVV(f, k);
    e.SelfMulAdd(n, k);
    d += q * box2d.b2CrossVV(g, k);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return l <= box2d.b2_linearSlop && h <= box2d.b2_angularSlop
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SolvePositionConstraints", box2d.b2RevoluteJoint.prototype.SolvePositionConstraints);
box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec2;
box2d.b2RevoluteJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetAnchorA", box2d.b2RevoluteJoint.prototype.GetAnchorA);
box2d.b2RevoluteJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetAnchorB", box2d.b2RevoluteJoint.prototype.GetAnchorB);
box2d.b2RevoluteJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_impulse.x, a * this.m_impulse.y)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetReactionForce", box2d.b2RevoluteJoint.prototype.GetReactionForce);
box2d.b2RevoluteJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_impulse.z
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetReactionTorque", box2d.b2RevoluteJoint.prototype.GetReactionTorque);
box2d.b2RevoluteJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetLocalAnchorA", box2d.b2RevoluteJoint.prototype.GetLocalAnchorA);
box2d.b2RevoluteJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetLocalAnchorB", box2d.b2RevoluteJoint.prototype.GetLocalAnchorB);
box2d.b2RevoluteJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetReferenceAngle", box2d.b2RevoluteJoint.prototype.GetReferenceAngle);
box2d.b2RevoluteJoint.prototype.GetJointAngleRadians = function() {
    return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetJointAngleRadians", box2d.b2RevoluteJoint.prototype.GetJointAngleRadians);
box2d.b2RevoluteJoint.prototype.GetJointSpeed = function() {
    return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetJointSpeed", box2d.b2RevoluteJoint.prototype.GetJointSpeed);
box2d.b2RevoluteJoint.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "IsMotorEnabled", box2d.b2RevoluteJoint.prototype.IsMotorEnabled);
box2d.b2RevoluteJoint.prototype.EnableMotor = function(a) {
    this.m_enableMotor != a && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = a)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "EnableMotor", box2d.b2RevoluteJoint.prototype.EnableMotor);
box2d.b2RevoluteJoint.prototype.GetMotorTorque = function(a) {
    return a * this.m_motorImpulse
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetMotorTorque", box2d.b2RevoluteJoint.prototype.GetMotorTorque);
box2d.b2RevoluteJoint.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetMotorSpeed", box2d.b2RevoluteJoint.prototype.GetMotorSpeed);
box2d.b2RevoluteJoint.prototype.SetMaxMotorTorque = function(a) {
    this.m_maxMotorTorque = a
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SetMaxMotorTorque", box2d.b2RevoluteJoint.prototype.SetMaxMotorTorque);
box2d.b2RevoluteJoint.prototype.GetMaxMotorTorque = function() {
    return this.m_maxMotorTorque
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetMaxMotorTorque", box2d.b2RevoluteJoint.prototype.GetMaxMotorTorque);
box2d.b2RevoluteJoint.prototype.IsLimitEnabled = function() {
    return this.m_enableLimit
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "IsLimitEnabled", box2d.b2RevoluteJoint.prototype.IsLimitEnabled);
box2d.b2RevoluteJoint.prototype.EnableLimit = function(a) {
    a != this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = a, this.m_impulse.z = 0)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "EnableLimit", box2d.b2RevoluteJoint.prototype.EnableLimit);
box2d.b2RevoluteJoint.prototype.GetLowerLimit = function() {
    return this.m_lowerAngle
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetLowerLimit", box2d.b2RevoluteJoint.prototype.GetLowerLimit);
box2d.b2RevoluteJoint.prototype.GetUpperLimit = function() {
    return this.m_upperAngle
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "GetUpperLimit", box2d.b2RevoluteJoint.prototype.GetUpperLimit);
box2d.b2RevoluteJoint.prototype.SetLimits = function(a, b) {
    if (a != this.m_lowerAngle || b != this.m_upperAngle)
        this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_impulse.z = 0, this.m_lowerAngle = a, this.m_upperAngle = b
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SetLimits", box2d.b2RevoluteJoint.prototype.SetLimits);
box2d.b2RevoluteJoint.prototype.SetMotorSpeed = function(a) {
    this.m_motorSpeed != a && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = a)
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "SetMotorSpeed", box2d.b2RevoluteJoint.prototype.SetMotorSpeed);
box2d.b2RevoluteJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2RevoluteJointDef*/ var jd = new box2d.b2RevoluteJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
        box2d.b2Log("  jd.enableLimit = %s;\n", this.m_enableLimit ? "true" : "false");
        box2d.b2Log("  jd.lowerAngle = %.15f;\n", this.m_lowerAngle);
        box2d.b2Log("  jd.upperAngle = %.15f;\n", this.m_upperAngle);
        box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false");
        box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
        box2d.b2Log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2RevoluteJoint.prototype, "Dump", box2d.b2RevoluteJoint.prototype.Dump);
box2d.b2PrismaticJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_prismaticJoint);
    this.localAnchorA = new box2d.b2Vec2;
    this.localAnchorB = new box2d.b2Vec2;
    this.localAxisA = new box2d.b2Vec2(1, 0)
};
goog.inherits(box2d.b2PrismaticJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2PrismaticJointDef", box2d.b2PrismaticJointDef);
box2d.b2PrismaticJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "localAnchorA", box2d.b2PrismaticJointDef.prototype.localAnchorA);
box2d.b2PrismaticJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "localAnchorB", box2d.b2PrismaticJointDef.prototype.localAnchorB);
box2d.b2PrismaticJointDef.prototype.localAxisA = null;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "localAxisA", box2d.b2PrismaticJointDef.prototype.localAxisA);
box2d.b2PrismaticJointDef.prototype.referenceAngle = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "referenceAngle", box2d.b2PrismaticJointDef.prototype.referenceAngle);
box2d.b2PrismaticJointDef.prototype.enableLimit = !1;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "enableLimit", box2d.b2PrismaticJointDef.prototype.enableLimit);
box2d.b2PrismaticJointDef.prototype.lowerTranslation = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "lowerTranslation", box2d.b2PrismaticJointDef.prototype.lowerTranslation);
box2d.b2PrismaticJointDef.prototype.upperTranslation = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "upperTranslation", box2d.b2PrismaticJointDef.prototype.upperTranslation);
box2d.b2PrismaticJointDef.prototype.enableMotor = !1;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "enableMotor", box2d.b2PrismaticJointDef.prototype.enableMotor);
box2d.b2PrismaticJointDef.prototype.maxMotorForce = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "maxMotorForce", box2d.b2PrismaticJointDef.prototype.maxMotorForce);
box2d.b2PrismaticJointDef.prototype.motorSpeed = 0;
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "motorSpeed", box2d.b2PrismaticJointDef.prototype.motorSpeed);
box2d.b2PrismaticJointDef.prototype.Initialize = function(a, b, c, e) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB);
    this.bodyA.GetLocalVector(e, this.localAxisA);
    this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
};
goog.exportProperty(box2d.b2PrismaticJointDef.prototype, "Initialize", box2d.b2PrismaticJointDef.prototype.Initialize);
box2d.b2PrismaticJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_localXAxisA = a.localAxisA.Clone().SelfNormalize();
    this.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2);
    this.m_referenceAngle = a.referenceAngle;
    this.m_impulse = new box2d.b2Vec3(0, 0, 0);
    this.m_lowerTranslation = a.lowerTranslation;
    this.m_upperTranslation = a.upperTranslation;
    this.m_maxMotorForce = a.maxMotorForce;
    this.m_motorSpeed = a.motorSpeed;
    this.m_enableLimit = a.enableLimit;
    this.m_enableMotor = a.enableMotor;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_axis = new box2d.b2Vec2(0, 0);
    this.m_perp = new box2d.b2Vec2(0, 0);
    this.m_K = new box2d.b2Mat33;
    this.m_K3 = new box2d.b2Mat33;
    this.m_K2 = new box2d.b2Mat22;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2
};
goog.inherits(box2d.b2PrismaticJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2PrismaticJoint", box2d.b2PrismaticJoint);
box2d.b2PrismaticJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localAnchorA", box2d.b2PrismaticJoint.prototype.m_localAnchorA);
box2d.b2PrismaticJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localAnchorB", box2d.b2PrismaticJoint.prototype.m_localAnchorB);
box2d.b2PrismaticJoint.prototype.m_localXAxisA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localXAxisA", box2d.b2PrismaticJoint.prototype.m_localXAxisA);
box2d.b2PrismaticJoint.prototype.m_localYAxisA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localYAxisA", box2d.b2PrismaticJoint.prototype.m_localYAxisA);
box2d.b2PrismaticJoint.prototype.m_referenceAngle = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_referenceAngle", box2d.b2PrismaticJoint.prototype.m_referenceAngle);
box2d.b2PrismaticJoint.prototype.m_impulse = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_impulse", box2d.b2PrismaticJoint.prototype.m_impulse);
box2d.b2PrismaticJoint.prototype.m_motorImpulse = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_motorImpulse", box2d.b2PrismaticJoint.prototype.m_motorImpulse);
box2d.b2PrismaticJoint.prototype.m_lowerTranslation = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_lowerTranslation", box2d.b2PrismaticJoint.prototype.m_lowerTranslation);
box2d.b2PrismaticJoint.prototype.m_upperTranslation = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_upperTranslation", box2d.b2PrismaticJoint.prototype.m_upperTranslation);
box2d.b2PrismaticJoint.prototype.m_maxMotorForce = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_maxMotorForce", box2d.b2PrismaticJoint.prototype.m_maxMotorForce);
box2d.b2PrismaticJoint.prototype.m_motorSpeed = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_motorSpeed", box2d.b2PrismaticJoint.prototype.m_motorSpeed);
box2d.b2PrismaticJoint.prototype.m_enableLimit = !1;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_enableLimit", box2d.b2PrismaticJoint.prototype.m_enableLimit);
box2d.b2PrismaticJoint.prototype.m_enableMotor = !1;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_enableMotor", box2d.b2PrismaticJoint.prototype.m_enableMotor);
box2d.b2PrismaticJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_limitState", box2d.b2PrismaticJoint.prototype.m_limitState);
box2d.b2PrismaticJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_indexA", box2d.b2PrismaticJoint.prototype.m_indexA);
box2d.b2PrismaticJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_indexB", box2d.b2PrismaticJoint.prototype.m_indexB);
box2d.b2PrismaticJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localCenterA", box2d.b2PrismaticJoint.prototype.m_localCenterA);
box2d.b2PrismaticJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_localCenterB", box2d.b2PrismaticJoint.prototype.m_localCenterB);
box2d.b2PrismaticJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_invMassA", box2d.b2PrismaticJoint.prototype.m_invMassA);
box2d.b2PrismaticJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_invMassB", box2d.b2PrismaticJoint.prototype.m_invMassB);
box2d.b2PrismaticJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_invIA", box2d.b2PrismaticJoint.prototype.m_invIA);
box2d.b2PrismaticJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_invIB", box2d.b2PrismaticJoint.prototype.m_invIB);
box2d.b2PrismaticJoint.prototype.m_axis = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_axis", box2d.b2PrismaticJoint.prototype.m_axis);
box2d.b2PrismaticJoint.prototype.m_perp = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_perp", box2d.b2PrismaticJoint.prototype.m_perp);
box2d.b2PrismaticJoint.prototype.m_s1 = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_s1", box2d.b2PrismaticJoint.prototype.m_s1);
box2d.b2PrismaticJoint.prototype.m_s2 = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_s2", box2d.b2PrismaticJoint.prototype.m_s2);
box2d.b2PrismaticJoint.prototype.m_a1 = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_a1", box2d.b2PrismaticJoint.prototype.m_a1);
box2d.b2PrismaticJoint.prototype.m_a2 = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_a2", box2d.b2PrismaticJoint.prototype.m_a2);
box2d.b2PrismaticJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_K", box2d.b2PrismaticJoint.prototype.m_K);
box2d.b2PrismaticJoint.prototype.m_K3 = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_K3", box2d.b2PrismaticJoint.prototype.m_K3);
box2d.b2PrismaticJoint.prototype.m_K2 = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_K2", box2d.b2PrismaticJoint.prototype.m_K2);
box2d.b2PrismaticJoint.prototype.m_motorMass = 0;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_motorMass", box2d.b2PrismaticJoint.prototype.m_motorMass);
box2d.b2PrismaticJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_qA", box2d.b2PrismaticJoint.prototype.m_qA);
box2d.b2PrismaticJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_qB", box2d.b2PrismaticJoint.prototype.m_qB);
box2d.b2PrismaticJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_lalcA", box2d.b2PrismaticJoint.prototype.m_lalcA);
box2d.b2PrismaticJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_lalcB", box2d.b2PrismaticJoint.prototype.m_lalcB);
box2d.b2PrismaticJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_rA", box2d.b2PrismaticJoint.prototype.m_rA);
box2d.b2PrismaticJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "m_rB", box2d.b2PrismaticJoint.prototype.m_rB);
box2d.b2PrismaticJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].c, f = a.positions[this.m_indexB].a, g = a.velocities[this.m_indexB].v, h = a.velocities[this.m_indexB].w, l = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), f = this.m_qB.SetAngleRadians(f);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var k = box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var m = box2d.b2MulRV(f, this.m_lalcB, this.m_rB), n = box2d.b2AddVV(box2d.b2SubVV(d, b, box2d.b2Vec2.s_t0), box2d.b2SubVV(m,
            k, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d), b = this.m_invMassA, d = this.m_invMassB, f = this.m_invIA, p = this.m_invIB;
    box2d.b2MulRV(l, this.m_localXAxisA, this.m_axis);
    this.m_a1 = box2d.b2CrossVV(box2d.b2AddVV(n, k, box2d.b2Vec2.s_t0), this.m_axis);
    this.m_a2 = box2d.b2CrossVV(m, this.m_axis);
    this.m_motorMass = b + d + f * this.m_a1 * this.m_a1 + p * this.m_a2 * this.m_a2;
    0 < this.m_motorMass && (this.m_motorMass = 1 / this.m_motorMass);
    box2d.b2MulRV(l, this.m_localYAxisA, this.m_perp);
    this.m_s1 = box2d.b2CrossVV(box2d.b2AddVV(n,
            k, box2d.b2Vec2.s_t0), this.m_perp);
    this.m_s2 = box2d.b2CrossVV(m, this.m_perp);
    this.m_K.ex.x = b + d + f * this.m_s1 * this.m_s1 + p * this.m_s2 * this.m_s2;
    this.m_K.ex.y = f * this.m_s1 + p * this.m_s2;
    this.m_K.ex.z = f * this.m_s1 * this.m_a1 + p * this.m_s2 * this.m_a2;
    this.m_K.ey.x = this.m_K.ex.y;
    this.m_K.ey.y = f + p;
    0 == this.m_K.ey.y && (this.m_K.ey.y = 1);
    this.m_K.ey.z = f * this.m_a1 + p * this.m_a2;
    this.m_K.ez.x = this.m_K.ex.z;
    this.m_K.ez.y = this.m_K.ey.z;
    this.m_K.ez.z = b + d + f * this.m_a1 * this.m_a1 + p * this.m_a2 * this.m_a2;
    this.m_enableLimit ? (l = box2d.b2DotVV(this.m_axis,
            n), box2d.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * box2d.b2_linearSlop ? this.m_limitState = box2d.b2LimitState.e_equalLimits : l <= this.m_lowerTranslation ? this.m_limitState != box2d.b2LimitState.e_atLowerLimit && (this.m_limitState = box2d.b2LimitState.e_atLowerLimit, this.m_impulse.z = 0) : l >= this.m_upperTranslation ? this.m_limitState != box2d.b2LimitState.e_atUpperLimit && (this.m_limitState = box2d.b2LimitState.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z =
            0)) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z = 0);
    !1 == this.m_enableMotor && (this.m_motorImpulse = 0);
    a.step.warmStarting ? (this.m_impulse.SelfMul(a.step.dtRatio), this.m_motorImpulse *= a.step.dtRatio, l = box2d.b2AddVV(box2d.b2MulSV(this.m_impulse.x, this.m_perp, box2d.b2Vec2.s_t0), box2d.b2MulSV(this.m_motorImpulse + this.m_impulse.z, this.m_axis, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P), k = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse +
            this.m_impulse.z) * this.m_a1, m = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2, c.SelfMulSub(b, l), e -= f * k, g.SelfMulAdd(d, l), h += p * m) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0);
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w = h
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "InitVelocityConstraints", box2d.b2PrismaticJoint.prototype.InitVelocityConstraints);
box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB;
    if (this.m_enableMotor && this.m_limitState != box2d.b2LimitState.e_equalLimits) {
        var k = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(e, b, box2d.b2Vec2.s_t0)) + this.m_a2 * d - this.m_a1 * c, k = this.m_motorMass * (this.m_motorSpeed - k), m = this.m_motorImpulse,
                n = a.step.dt * this.m_maxMotorForce;
        this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + k, -n, n);
        k = this.m_motorImpulse - m;
        m = box2d.b2MulSV(k, this.m_axis, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P);
        n = k * this.m_a1;
        k *= this.m_a2;
        b.SelfMulSub(f, m);
        c -= h * n;
        e.SelfMulAdd(g, m);
        d += l * k
    }
    var n = box2d.b2DotVV(this.m_perp, box2d.b2SubVV(e, b, box2d.b2Vec2.s_t0)) + this.m_s2 * d - this.m_s1 * c, p = d - c;
    this.m_enableLimit && this.m_limitState != box2d.b2LimitState.e_inactiveLimit ? (k = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(e,
            b, box2d.b2Vec2.s_t0)) + this.m_a2 * d - this.m_a1 * c, m = box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1.Copy(this.m_impulse), k = this.m_K.Solve33(-n, -p, -k, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3), this.m_impulse.SelfAdd(k), this.m_limitState == box2d.b2LimitState.e_atLowerLimit ? this.m_impulse.z = box2d.b2Max(this.m_impulse.z, 0) : this.m_limitState == box2d.b2LimitState.e_atUpperLimit && (this.m_impulse.z = box2d.b2Min(this.m_impulse.z, 0)), n = this.m_K.Solve22(-n - (this.m_impulse.z - m.z) *
            this.m_K.ez.x, -p - (this.m_impulse.z - m.z) * this.m_K.ez.y, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r), n.x += m.x, n.y += m.y, this.m_impulse.x = n.x, this.m_impulse.y = n.y, k.x = this.m_impulse.x - m.x, k.y = this.m_impulse.y - m.y, k.z = this.m_impulse.z - m.z, m = box2d.b2AddVV(box2d.b2MulSV(k.x, this.m_perp, box2d.b2Vec2.s_t0), box2d.b2MulSV(k.z, this.m_axis, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P), n = k.x * this.m_s1 + k.y + k.z * this.m_a1, k = k.x * this.m_s2 + k.y + k.z * this.m_a2) : (k =
            this.m_K.Solve22(-n, -p, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2), this.m_impulse.x += k.x, this.m_impulse.y += k.y, m = box2d.b2MulSV(k.x, this.m_perp, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P), n = k.x * this.m_s1 + k.y, k = k.x * this.m_s2 + k.y);
    b.SelfMulSub(f, m);
    c -= h * n;
    e.SelfMulAdd(g, m);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d + l * k
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SolveVelocityConstraints", box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints);
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1 = new box2d.b2Vec3;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3 = new box2d.b2Vec3;
box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2 = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d), h = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB, n = box2d.b2MulRV(f, this.m_lalcA, this.m_rA), p = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), q = box2d.b2SubVV(box2d.b2AddVV(e, p, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, n, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d),
            r = box2d.b2MulRV(f, this.m_localXAxisA, this.m_axis), t = box2d.b2CrossVV(box2d.b2AddVV(q, n, box2d.b2Vec2.s_t0), r), g = box2d.b2CrossVV(p, r), f = box2d.b2MulRV(f, this.m_localYAxisA, this.m_perp), s = box2d.b2CrossVV(box2d.b2AddVV(q, n, box2d.b2Vec2.s_t0), f), u = box2d.b2CrossVV(p, f), v = box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse, y = box2d.b2DotVV(f, q), D = d - c - this.m_referenceAngle, n = box2d.b2Abs(y), p = box2d.b2Abs(D), x = !1, w = 0;
    this.m_enableLimit && (q = box2d.b2DotVV(r, q), box2d.b2Abs(this.m_upperTranslation -
            this.m_lowerTranslation) < 2 * box2d.b2_linearSlop ? (w = box2d.b2Clamp(q, -box2d.b2_maxLinearCorrection, box2d.b2_maxLinearCorrection), n = box2d.b2Max(n, box2d.b2Abs(q)), x = !0) : q <= this.m_lowerTranslation ? (w = box2d.b2Clamp(q - this.m_lowerTranslation + box2d.b2_linearSlop, -box2d.b2_maxLinearCorrection, 0), n = box2d.b2Max(n, this.m_lowerTranslation - q), x = !0) : q >= this.m_upperTranslation && (w = box2d.b2Clamp(q - this.m_upperTranslation - box2d.b2_linearSlop, 0, box2d.b2_maxLinearCorrection), n = box2d.b2Max(n, q - this.m_upperTranslation),
            x = !0));
    if (x) {
        var q = k * s + m * u, C = k * s * t + m * u * g, x = k + m;
        0 == x && (x = 1);
        var A = k * t + m * g, E = h + l + k * t * t + m * g * g, B = this.m_K3;
        B.ex.SetXYZ(h + l + k * s * s + m * u * u, q, C);
        B.ey.SetXYZ(q, x, A);
        B.ez.SetXYZ(C, A, E);
        v = B.Solve33(-y, -D, -w, v)
    } else
        q = k * s + m * u, x = k + m, 0 == x && (x = 1), w = this.m_K2, w.ex.SetXY(h + l + k * s * s + m * u * u, q), w.ey.SetXY(q, x), y = w.Solve(-y, -D, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1), v.x = y.x, v.y = y.y, v.z = 0;
    r = box2d.b2AddVV(box2d.b2MulSV(v.x, f, box2d.b2Vec2.s_t0), box2d.b2MulSV(v.z, r, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P);
    t = v.x * s + v.y + v.z * t;
    g = v.x * u + v.y + v.z * g;
    b.SelfMulSub(h, r);
    c -= k * t;
    e.SelfMulAdd(l, r);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d + m * g;
    return n <= box2d.b2_linearSlop && p <= box2d.b2_angularSlop
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SolvePositionConstraints", box2d.b2PrismaticJoint.prototype.SolvePositionConstraints);
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3;
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1 = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetAnchorA", box2d.b2PrismaticJoint.prototype.GetAnchorA);
box2d.b2PrismaticJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetAnchorB", box2d.b2PrismaticJoint.prototype.GetAnchorB);
box2d.b2PrismaticJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), a * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetReactionForce", box2d.b2PrismaticJoint.prototype.GetReactionForce);
box2d.b2PrismaticJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_impulse.y
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetReactionTorque", box2d.b2PrismaticJoint.prototype.GetReactionTorque);
box2d.b2PrismaticJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetLocalAnchorA", box2d.b2PrismaticJoint.prototype.GetLocalAnchorA);
box2d.b2PrismaticJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetLocalAnchorB", box2d.b2PrismaticJoint.prototype.GetLocalAnchorB);
box2d.b2PrismaticJoint.prototype.GetLocalAxisA = function(a) {
    return a.Copy(this.m_localXAxisA)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetLocalAxisA", box2d.b2PrismaticJoint.prototype.GetLocalAxisA);
box2d.b2PrismaticJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetReferenceAngle", box2d.b2PrismaticJoint.prototype.GetReferenceAngle);
box2d.b2PrismaticJoint.prototype.GetJointTranslation = function() {
    var a = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA), b = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB), a = box2d.b2SubVV(b, a, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d), b = this.m_bodyA.GetWorldVector(this.m_localXAxisA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis);
    return box2d.b2DotVV(a, b)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetJointTranslation", box2d.b2PrismaticJoint.prototype.GetJointTranslation);
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis = new box2d.b2Vec2;
box2d.b2PrismaticJoint.prototype.GetJointSpeed = function() {
    var a = this.m_bodyA, b = this.m_bodyB;
    box2d.b2SubVV(this.m_localAnchorA, a.m_sweep.localCenter, this.m_lalcA);
    var c = box2d.b2MulRV(a.m_xf.q, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, b.m_sweep.localCenter, this.m_lalcB);
    var e = box2d.b2MulRV(b.m_xf.q, this.m_lalcB, this.m_rB), d = box2d.b2AddVV(a.m_sweep.c, c, box2d.b2Vec2.s_t0), f = box2d.b2AddVV(b.m_sweep.c, e, box2d.b2Vec2.s_t1), d = box2d.b2SubVV(f, d, box2d.b2Vec2.s_t2), f = a.GetWorldVector(this.m_localXAxisA,
            this.m_axis), g = a.m_linearVelocity, h = b.m_linearVelocity, a = a.m_angularVelocity, b = b.m_angularVelocity;
    return box2d.b2DotVV(d, box2d.b2CrossSV(a, f, box2d.b2Vec2.s_t0)) + box2d.b2DotVV(f, box2d.b2SubVV(box2d.b2AddVCrossSV(h, b, e, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(g, a, c, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0))
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetJointSpeed", box2d.b2PrismaticJoint.prototype.GetJointSpeed);
box2d.b2PrismaticJoint.prototype.IsLimitEnabled = function() {
    return this.m_enableLimit
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "IsLimitEnabled", box2d.b2PrismaticJoint.prototype.IsLimitEnabled);
box2d.b2PrismaticJoint.prototype.EnableLimit = function(a) {
    a != this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = a, this.m_impulse.z = 0)
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "EnableLimit", box2d.b2PrismaticJoint.prototype.EnableLimit);
box2d.b2PrismaticJoint.prototype.GetLowerLimit = function() {
    return this.m_lowerTranslation
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetLowerLimit", box2d.b2PrismaticJoint.prototype.GetLowerLimit);
box2d.b2PrismaticJoint.prototype.GetUpperLimit = function() {
    return this.m_upperTranslation
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetUpperLimit", box2d.b2PrismaticJoint.prototype.GetUpperLimit);
box2d.b2PrismaticJoint.prototype.SetLimits = function(a, b) {
    if (a != this.m_lowerTranslation || b != this.m_upperTranslation)
        this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = a, this.m_upperTranslation = b, this.m_impulse.z = 0
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SetLimits", box2d.b2PrismaticJoint.prototype.SetLimits);
box2d.b2PrismaticJoint.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "IsMotorEnabled", box2d.b2PrismaticJoint.prototype.IsMotorEnabled);
box2d.b2PrismaticJoint.prototype.EnableMotor = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_enableMotor = a
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "EnableMotor", box2d.b2PrismaticJoint.prototype.EnableMotor);
box2d.b2PrismaticJoint.prototype.SetMotorSpeed = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_motorSpeed = a
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SetMotorSpeed", box2d.b2PrismaticJoint.prototype.SetMotorSpeed);
box2d.b2PrismaticJoint.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetMotorSpeed", box2d.b2PrismaticJoint.prototype.GetMotorSpeed);
box2d.b2PrismaticJoint.prototype.SetMaxMotorForce = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_maxMotorForce = a
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "SetMaxMotorForce", box2d.b2PrismaticJoint.prototype.SetMaxMotorForce);
box2d.b2PrismaticJoint.prototype.GetMaxMotorForce = function() {
    return this.m_maxMotorForce
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetMaxMotorForce", box2d.b2PrismaticJoint.prototype.GetMaxMotorForce);
box2d.b2PrismaticJoint.prototype.GetMotorForce = function(a) {
    return a * this.m_motorImpulse
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "GetMotorForce", box2d.b2PrismaticJoint.prototype.GetMotorForce);
box2d.b2PrismaticJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2PrismaticJointDef*/ var jd = new box2d.b2PrismaticJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.localAxisA.SetXY(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y);
        box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
        box2d.b2Log("  jd.enableLimit = %s;\n", this.m_enableLimit ? "true" : "false");
        box2d.b2Log("  jd.lowerTranslation = %.15f;\n", this.m_lowerTranslation);
        box2d.b2Log("  jd.upperTranslation = %.15f;\n", this.m_upperTranslation);
        box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false");
        box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
        box2d.b2Log("  jd.maxMotorForce = %.15f;\n", this.m_maxMotorForce);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2PrismaticJoint.prototype, "Dump", box2d.b2PrismaticJoint.prototype.Dump);
box2d.b2GearJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_gearJoint)
};
goog.inherits(box2d.b2GearJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2GearJointDef", box2d.b2GearJointDef);
box2d.b2GearJointDef.prototype.joint1 = null;
goog.exportProperty(box2d.b2GearJointDef.prototype, "joint1", box2d.b2GearJointDef.prototype.joint1);
box2d.b2GearJointDef.prototype.joint2 = null;
goog.exportProperty(box2d.b2GearJointDef.prototype, "joint2", box2d.b2GearJointDef.prototype.joint2);
box2d.b2GearJointDef.prototype.ratio = 1;
goog.exportProperty(box2d.b2GearJointDef.prototype, "ratio", box2d.b2GearJointDef.prototype.ratio);
box2d.b2GearJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_joint1 = a.joint1;
    this.m_joint2 = a.joint2;
    this.m_localAnchorA = new box2d.b2Vec2;
    this.m_localAnchorB = new box2d.b2Vec2;
    this.m_localAnchorC = new box2d.b2Vec2;
    this.m_localAnchorD = new box2d.b2Vec2;
    this.m_localAxisC = new box2d.b2Vec2;
    this.m_localAxisD = new box2d.b2Vec2;
    this.m_lcA = new box2d.b2Vec2;
    this.m_lcB = new box2d.b2Vec2;
    this.m_lcC = new box2d.b2Vec2;
    this.m_lcD = new box2d.b2Vec2;
    this.m_JvAC = new box2d.b2Vec2;
    this.m_JvBD = new box2d.b2Vec2;
    this.m_qA =
            new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_qC = new box2d.b2Rot;
    this.m_qD = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_lalcC = new box2d.b2Vec2;
    this.m_lalcD = new box2d.b2Vec2;
    this.m_typeA = this.m_joint1.GetType();
    this.m_typeB = this.m_joint2.GetType();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_typeA == box2d.b2JointType.e_revoluteJoint || this.m_typeA == box2d.b2JointType.e_prismaticJoint);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_typeB == box2d.b2JointType.e_revoluteJoint ||
            this.m_typeB == box2d.b2JointType.e_prismaticJoint);
    var b, c;
    this.m_bodyC = this.m_joint1.GetBodyA();
    this.m_bodyA = this.m_joint1.GetBodyB();
    b = this.m_bodyA.m_xf;
    var e = this.m_bodyA.m_sweep.a;
    c = this.m_bodyC.m_xf;
    var d = this.m_bodyC.m_sweep.a;
    this.m_typeA == box2d.b2JointType.e_revoluteJoint ? (c = a.joint1, this.m_localAnchorC.Copy(c.m_localAnchorA), this.m_localAnchorA.Copy(c.m_localAnchorB), this.m_referenceAngleA = c.m_referenceAngle, this.m_localAxisC.SetZero(), b = e - d - this.m_referenceAngleA) : (d = a.joint1, this.m_localAnchorC.Copy(d.m_localAnchorA),
            this.m_localAnchorA.Copy(d.m_localAnchorB), this.m_referenceAngleA = d.m_referenceAngle, this.m_localAxisC.Copy(d.m_localXAxisA), e = this.m_localAnchorC, b = box2d.b2MulTRV(c.q, box2d.b2AddVV(box2d.b2MulRV(b.q, this.m_localAnchorA, box2d.b2Vec2.s_t0), box2d.b2SubVV(b.p, c.p, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), b = box2d.b2DotVV(box2d.b2SubVV(b, e, box2d.b2Vec2.s_t0), this.m_localAxisC));
    this.m_bodyD = this.m_joint2.GetBodyA();
    this.m_bodyB = this.m_joint2.GetBodyB();
    c = this.m_bodyB.m_xf;
    var d = this.m_bodyB.m_sweep.a,
            e = this.m_bodyD.m_xf, f = this.m_bodyD.m_sweep.a;
    this.m_typeB == box2d.b2JointType.e_revoluteJoint ? (c = a.joint2, this.m_localAnchorD.Copy(c.m_localAnchorA), this.m_localAnchorB.Copy(c.m_localAnchorB), this.m_referenceAngleB = c.m_referenceAngle, this.m_localAxisD.SetZero(), c = d - f - this.m_referenceAngleB) : (d = a.joint2, this.m_localAnchorD.Copy(d.m_localAnchorA), this.m_localAnchorB.Copy(d.m_localAnchorB), this.m_referenceAngleB = d.m_referenceAngle, this.m_localAxisD.Copy(d.m_localXAxisA), d = this.m_localAnchorD, c = box2d.b2MulTRV(e.q,
            box2d.b2AddVV(box2d.b2MulRV(c.q, this.m_localAnchorB, box2d.b2Vec2.s_t0), box2d.b2SubVV(c.p, e.p, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), c = box2d.b2DotVV(box2d.b2SubVV(c, d, box2d.b2Vec2.s_t0), this.m_localAxisD));
    this.m_ratio = a.ratio;
    this.m_constant = b + this.m_ratio * c;
    this.m_impulse = 0
};
goog.inherits(box2d.b2GearJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2GearJoint", box2d.b2GearJoint);
box2d.b2GearJoint.prototype.m_joint1 = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_joint1", box2d.b2GearJoint.prototype.m_joint1);
box2d.b2GearJoint.prototype.m_joint2 = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_joint2", box2d.b2GearJoint.prototype.m_joint2);
box2d.b2GearJoint.prototype.m_typeA = box2d.b2JointType.e_unknownJoint;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_typeA", box2d.b2GearJoint.prototype.m_typeA);
box2d.b2GearJoint.prototype.m_typeB = box2d.b2JointType.e_unknownJoint;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_typeB", box2d.b2GearJoint.prototype.m_typeB);
box2d.b2GearJoint.prototype.m_bodyC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_bodyC", box2d.b2GearJoint.prototype.m_bodyC);
box2d.b2GearJoint.prototype.m_bodyD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_bodyD", box2d.b2GearJoint.prototype.m_bodyD);
box2d.b2GearJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAnchorA", box2d.b2GearJoint.prototype.m_localAnchorA);
box2d.b2GearJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAnchorB", box2d.b2GearJoint.prototype.m_localAnchorB);
box2d.b2GearJoint.prototype.m_localAnchorC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAnchorC", box2d.b2GearJoint.prototype.m_localAnchorC);
box2d.b2GearJoint.prototype.m_localAnchorD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAnchorD", box2d.b2GearJoint.prototype.m_localAnchorD);
box2d.b2GearJoint.prototype.m_localAxisC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAxisC", box2d.b2GearJoint.prototype.m_localAxisC);
box2d.b2GearJoint.prototype.m_localAxisD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_localAxisD", box2d.b2GearJoint.prototype.m_localAxisD);
box2d.b2GearJoint.prototype.m_referenceAngleA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_referenceAngleA", box2d.b2GearJoint.prototype.m_referenceAngleA);
box2d.b2GearJoint.prototype.m_referenceAngleB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_referenceAngleB", box2d.b2GearJoint.prototype.m_referenceAngleB);
box2d.b2GearJoint.prototype.m_constant = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_constant", box2d.b2GearJoint.prototype.m_constant);
box2d.b2GearJoint.prototype.m_ratio = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_ratio", box2d.b2GearJoint.prototype.m_ratio);
box2d.b2GearJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_impulse", box2d.b2GearJoint.prototype.m_impulse);
box2d.b2GearJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_indexA", box2d.b2GearJoint.prototype.m_indexA);
box2d.b2GearJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_indexB", box2d.b2GearJoint.prototype.m_indexB);
box2d.b2GearJoint.prototype.m_indexC = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_indexC", box2d.b2GearJoint.prototype.m_indexC);
box2d.b2GearJoint.prototype.m_indexD = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_indexD", box2d.b2GearJoint.prototype.m_indexD);
box2d.b2GearJoint.prototype.m_lcA = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lcA", box2d.b2GearJoint.prototype.m_lcA);
box2d.b2GearJoint.prototype.m_lcB = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lcB", box2d.b2GearJoint.prototype.m_lcB);
box2d.b2GearJoint.prototype.m_lcC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lcC", box2d.b2GearJoint.prototype.m_lcC);
box2d.b2GearJoint.prototype.m_lcD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lcD", box2d.b2GearJoint.prototype.m_lcD);
box2d.b2GearJoint.prototype.m_mA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mA", box2d.b2GearJoint.prototype.m_mA);
box2d.b2GearJoint.prototype.m_mB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mB", box2d.b2GearJoint.prototype.m_mB);
box2d.b2GearJoint.prototype.m_mC = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mC", box2d.b2GearJoint.prototype.m_mC);
box2d.b2GearJoint.prototype.m_mD = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mD", box2d.b2GearJoint.prototype.m_mD);
box2d.b2GearJoint.prototype.m_iA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_iA", box2d.b2GearJoint.prototype.m_iA);
box2d.b2GearJoint.prototype.m_iB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_iB", box2d.b2GearJoint.prototype.m_iB);
box2d.b2GearJoint.prototype.m_iC = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_iC", box2d.b2GearJoint.prototype.m_iC);
box2d.b2GearJoint.prototype.m_iD = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_iD", box2d.b2GearJoint.prototype.m_iD);
box2d.b2GearJoint.prototype.m_JvAC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JvAC", box2d.b2GearJoint.prototype.m_JvAC);
box2d.b2GearJoint.prototype.m_JvBD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JvBD", box2d.b2GearJoint.prototype.m_JvBD);
box2d.b2GearJoint.prototype.m_JwA = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JwA", box2d.b2GearJoint.prototype.m_JwA);
box2d.b2GearJoint.prototype.m_JwB = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JwB", box2d.b2GearJoint.prototype.m_JwB);
box2d.b2GearJoint.prototype.m_JwC = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JwC", box2d.b2GearJoint.prototype.m_JwC);
box2d.b2GearJoint.prototype.m_JwD = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_JwD", box2d.b2GearJoint.prototype.m_JwD);
box2d.b2GearJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_mass", box2d.b2GearJoint.prototype.m_mass);
box2d.b2GearJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_qA", box2d.b2GearJoint.prototype.m_qA);
box2d.b2GearJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_qB", box2d.b2GearJoint.prototype.m_qB);
box2d.b2GearJoint.prototype.m_qC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_qC", box2d.b2GearJoint.prototype.m_qC);
box2d.b2GearJoint.prototype.m_qD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_qD", box2d.b2GearJoint.prototype.m_qD);
box2d.b2GearJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lalcA", box2d.b2GearJoint.prototype.m_lalcA);
box2d.b2GearJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lalcB", box2d.b2GearJoint.prototype.m_lalcB);
box2d.b2GearJoint.prototype.m_lalcC = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lalcC", box2d.b2GearJoint.prototype.m_lalcC);
box2d.b2GearJoint.prototype.m_lalcD = null;
goog.exportProperty(box2d.b2GearJoint.prototype, "m_lalcD", box2d.b2GearJoint.prototype.m_lalcD);
box2d.b2GearJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_indexC = this.m_bodyC.m_islandIndex;
    this.m_indexD = this.m_bodyD.m_islandIndex;
    this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter);
    this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter);
    this.m_mA = this.m_bodyA.m_invMass;
    this.m_mB = this.m_bodyB.m_invMass;
    this.m_mC =
            this.m_bodyC.m_invMass;
    this.m_mD = this.m_bodyD.m_invMass;
    this.m_iA = this.m_bodyA.m_invI;
    this.m_iB = this.m_bodyB.m_invI;
    this.m_iC = this.m_bodyC.m_invI;
    this.m_iD = this.m_bodyD.m_invI;
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.positions[this.m_indexB].a, d = a.velocities[this.m_indexB].v, f = a.velocities[this.m_indexB].w, g = a.positions[this.m_indexC].a, h = a.velocities[this.m_indexC].v, l = a.velocities[this.m_indexC].w, k = a.positions[this.m_indexD].a, m = a.velocities[this.m_indexD].v, n = a.velocities[this.m_indexD].w,
            p = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), e = this.m_qB.SetAngleRadians(e), q = this.m_qC.SetAngleRadians(g), g = this.m_qD.SetAngleRadians(k);
    this.m_mass = 0;
    this.m_typeA == box2d.b2JointType.e_revoluteJoint ? (this.m_JvAC.SetZero(), this.m_JwC = this.m_JwA = 1, this.m_mass += this.m_iA + this.m_iC) : (k = box2d.b2MulRV(q, this.m_localAxisC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u), box2d.b2SubVV(this.m_localAnchorC, this.m_lcC, this.m_lalcC), q = box2d.b2MulRV(q, this.m_lalcC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC),
            box2d.b2SubVV(this.m_localAnchorA, this.m_lcA, this.m_lalcA), p = box2d.b2MulRV(p, this.m_lalcA, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA), this.m_JvAC.Copy(k), this.m_JwC = box2d.b2CrossVV(q, k), this.m_JwA = box2d.b2CrossVV(p, k), this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA);
    this.m_typeB == box2d.b2JointType.e_revoluteJoint ? (this.m_JvBD.SetZero(), this.m_JwD = this.m_JwB = this.m_ratio, this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD)) : (k =
            box2d.b2MulRV(g, this.m_localAxisD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u), box2d.b2SubVV(this.m_localAnchorD, this.m_lcD, this.m_lalcD), p = box2d.b2MulRV(g, this.m_lalcD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD), box2d.b2SubVV(this.m_localAnchorB, this.m_lcB, this.m_lalcB), e = box2d.b2MulRV(e, this.m_lalcB, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB), box2d.b2MulSV(this.m_ratio, k, this.m_JvBD), this.m_JwD = this.m_ratio * box2d.b2CrossVV(p, k), this.m_JwB = this.m_ratio * box2d.b2CrossVV(e,
            k), this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB);
    this.m_mass = 0 < this.m_mass ? 1 / this.m_mass : 0;
    a.step.warmStarting ? (b.SelfMulAdd(this.m_mA * this.m_impulse, this.m_JvAC), c += this.m_iA * this.m_impulse * this.m_JwA, d.SelfMulAdd(this.m_mB * this.m_impulse, this.m_JvBD), f += this.m_iB * this.m_impulse * this.m_JwB, h.SelfMulSub(this.m_mC * this.m_impulse, this.m_JvAC), l -= this.m_iC * this.m_impulse * this.m_JwC, m.SelfMulSub(this.m_mD * this.m_impulse, this.m_JvBD),
            n -= this.m_iD * this.m_impulse * this.m_JwD) : this.m_impulse = 0;
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = f;
    a.velocities[this.m_indexC].w = l;
    a.velocities[this.m_indexD].w = n
};
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = a.velocities[this.m_indexC].v, g = a.velocities[this.m_indexC].w, h = a.velocities[this.m_indexD].v, l = a.velocities[this.m_indexD].w, k = box2d.b2DotVV(this.m_JvAC, box2d.b2SubVV(b, f, box2d.b2Vec2.s_t0)) + box2d.b2DotVV(this.m_JvBD, box2d.b2SubVV(e, h, box2d.b2Vec2.s_t0)), k = k + (this.m_JwA * c - this.m_JwC * g + (this.m_JwB * d - this.m_JwD *
            l)), k = -this.m_mass * k;
    this.m_impulse += k;
    b.SelfMulAdd(this.m_mA * k, this.m_JvAC);
    c += this.m_iA * k * this.m_JwA;
    e.SelfMulAdd(this.m_mB * k, this.m_JvBD);
    d += this.m_iB * k * this.m_JwB;
    f.SelfMulSub(this.m_mC * k, this.m_JvAC);
    g -= this.m_iC * k * this.m_JwC;
    h.SelfMulSub(this.m_mD * k, this.m_JvBD);
    l -= this.m_iD * k * this.m_JwD;
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d;
    a.velocities[this.m_indexC].w = g;
    a.velocities[this.m_indexD].w = l
};
box2d.b2GearJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = a.positions[this.m_indexC].c, g = a.positions[this.m_indexC].a, h = a.positions[this.m_indexD].c, l = a.positions[this.m_indexD].a, k = this.m_qA.SetAngleRadians(c), m = this.m_qB.SetAngleRadians(d), n = this.m_qC.SetAngleRadians(g), p = this.m_qD.SetAngleRadians(l), q = this.m_JvAC, r = this.m_JvBD, t, s, u = 0;
    if (this.m_typeA == box2d.b2JointType.e_revoluteJoint)
        q.SetZero(),
                k = t = 1, u += this.m_iA + this.m_iC, n = c - g - this.m_referenceAngleA;
    else {
        s = box2d.b2MulRV(n, this.m_localAxisC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u);
        t = box2d.b2MulRV(n, this.m_lalcC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC);
        var v = box2d.b2MulRV(k, this.m_lalcA, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA);
        q.Copy(s);
        k = box2d.b2CrossVV(t, s);
        t = box2d.b2CrossVV(v, s);
        u += this.m_mC + this.m_mA + this.m_iC * k * k + this.m_iA * t * t;
        s = this.m_lalcC;
        n = box2d.b2MulTRV(n, box2d.b2AddVV(v, box2d.b2SubVV(b,
                f, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        n = box2d.b2DotVV(box2d.b2SubVV(n, s, box2d.b2Vec2.s_t0), this.m_localAxisC)
    }
    if (this.m_typeB == box2d.b2JointType.e_revoluteJoint)
        r.SetZero(), m = s = this.m_ratio, u += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD), p = d - l - this.m_referenceAngleB;
    else {
        s = box2d.b2MulRV(p, this.m_localAxisD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u);
        var y = box2d.b2MulRV(p, this.m_lalcD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD), v = box2d.b2MulRV(m,
                this.m_lalcB, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB);
        box2d.b2MulSV(this.m_ratio, s, r);
        m = this.m_ratio * box2d.b2CrossVV(y, s);
        s = this.m_ratio * box2d.b2CrossVV(v, s);
        u += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * m * m + this.m_iB * s * s;
        y = this.m_lalcD;
        p = box2d.b2MulTRV(p, box2d.b2AddVV(v, box2d.b2SubVV(e, h, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        p = box2d.b2DotVV(box2d.b2SubVV(p, y, box2d.b2Vec2.s_t0), this.m_localAxisD)
    }
    p = n + this.m_ratio * p - this.m_constant;
    n = 0;
    0 < u && (n = -p /
            u);
    b.SelfMulAdd(this.m_mA * n, q);
    c += this.m_iA * n * t;
    e.SelfMulAdd(this.m_mB * n, r);
    d += this.m_iB * n * s;
    f.SelfMulSub(this.m_mC * n, q);
    g -= this.m_iC * n * k;
    h.SelfMulSub(this.m_mD * n, r);
    l -= this.m_iD * n * m;
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    a.positions[this.m_indexC].a = g;
    a.positions[this.m_indexD].a = l;
    return 0 < box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2GearJoint.prototype, "SolvePositionConstraints", box2d.b2GearJoint.prototype.SolvePositionConstraints);
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD = new box2d.b2Vec2;
box2d.b2GearJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetAnchorA", box2d.b2GearJoint.prototype.GetAnchorA);
box2d.b2GearJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetAnchorB", box2d.b2GearJoint.prototype.GetAnchorB);
box2d.b2GearJoint.prototype.GetReactionForce = function(a, b) {
    return box2d.b2MulSV(a * this.m_impulse, this.m_JvAC, b)
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetReactionForce", box2d.b2GearJoint.prototype.GetReactionForce);
box2d.b2GearJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_impulse * this.m_JwA
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetReactionTorque", box2d.b2GearJoint.prototype.GetReactionTorque);
box2d.b2GearJoint.prototype.GetJoint1 = function() {
    return this.m_joint1
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetJoint1", box2d.b2GearJoint.prototype.GetJoint1);
box2d.b2GearJoint.prototype.GetJoint2 = function() {
    return this.m_joint2
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetJoint2", box2d.b2GearJoint.prototype.GetJoint2);
box2d.b2GearJoint.prototype.GetRatio = function() {
    return this.m_ratio
};
goog.exportProperty(box2d.b2GearJoint.prototype, "GetRatio", box2d.b2GearJoint.prototype.GetRatio);
box2d.b2GearJoint.prototype.SetRatio = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a));
    this.m_ratio = a
};
goog.exportProperty(box2d.b2GearJoint.prototype, "SetRatio", box2d.b2GearJoint.prototype.SetRatio);
box2d.b2GearJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex, c = this.m_joint1.m_index, e = this.m_joint2.m_index;
        box2d.b2Log("  /*box2d.b2GearJointDef*/ var jd = new box2d.b2GearJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.joint1 = joints[%d];\n", c);
        box2d.b2Log("  jd.joint2 = joints[%d];\n",
                e);
        box2d.b2Log("  jd.ratio = %.15f;\n", this.m_ratio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2GearJoint.prototype, "Dump", box2d.b2GearJoint.prototype.Dump);
box2d.b2DistanceProxy = function() {
    this.m_buffer = box2d.b2Vec2.MakeArray(2)
};
goog.exportSymbol("box2d.b2DistanceProxy", box2d.b2DistanceProxy);
box2d.b2DistanceProxy.prototype.m_buffer = null;
goog.exportProperty(box2d.b2DistanceProxy.prototype, "m_buffer", box2d.b2DistanceProxy.prototype.m_buffer);
box2d.b2DistanceProxy.prototype.m_vertices = null;
goog.exportProperty(box2d.b2DistanceProxy.prototype, "m_vertices", box2d.b2DistanceProxy.prototype.m_vertices);
box2d.b2DistanceProxy.prototype.m_count = 0;
goog.exportProperty(box2d.b2DistanceProxy.prototype, "m_count", box2d.b2DistanceProxy.prototype.m_count);
box2d.b2DistanceProxy.prototype.m_radius = 0;
goog.exportProperty(box2d.b2DistanceProxy.prototype, "m_radius", box2d.b2DistanceProxy.prototype.m_radius);
box2d.b2DistanceProxy.prototype.Reset = function() {
    this.m_vertices = null;
    this.m_radius = this.m_count = 0;
    return this
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "Reset", box2d.b2DistanceProxy.prototype.Reset);
box2d.b2DistanceProxy.prototype.SetShape = function(a, b) {
    a.SetupDistanceProxy(this, b)
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "SetShape", box2d.b2DistanceProxy.prototype.SetShape);
box2d.b2DistanceProxy.prototype.GetSupport = function(a) {
    for (var b = 0, c = box2d.b2DotVV(this.m_vertices[0], a), e = 1; e < this.m_count; ++e) {
        var d = box2d.b2DotVV(this.m_vertices[e], a);
        d > c && (b = e, c = d)
    }
    return b
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "GetSupport", box2d.b2DistanceProxy.prototype.GetSupport);
box2d.b2DistanceProxy.prototype.GetSupportVertex = function(a, b) {
    for (var c = 0, e = box2d.b2DotVV(this.m_vertices[0], a), d = 1; d < this.m_count; ++d) {
        var f = box2d.b2DotVV(this.m_vertices[d], a);
        f > e && (c = d, e = f)
    }
    return b.Copy(this.m_vertices[c])
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "GetSupportVertex", box2d.b2DistanceProxy.prototype.GetSupportVertex);
box2d.b2DistanceProxy.prototype.GetVertexCount = function() {
    return this.m_count
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "GetVertexCount", box2d.b2DistanceProxy.prototype.GetVertexCount);
box2d.b2DistanceProxy.prototype.GetVertex = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= a && a < this.m_count);
    return this.m_vertices[a]
};
goog.exportProperty(box2d.b2DistanceProxy.prototype, "GetVertex", box2d.b2DistanceProxy.prototype.GetVertex);
box2d.b2SimplexCache = function() {
    this.indexA = box2d.b2MakeNumberArray(3);
    this.indexB = box2d.b2MakeNumberArray(3)
};
goog.exportSymbol("box2d.b2SimplexCache", box2d.b2SimplexCache);
box2d.b2SimplexCache.prototype.metric = 0;
goog.exportProperty(box2d.b2SimplexCache.prototype, "metric", box2d.b2SimplexCache.prototype.metric);
box2d.b2SimplexCache.prototype.count = 0;
goog.exportProperty(box2d.b2SimplexCache.prototype, "count", box2d.b2SimplexCache.prototype.count);
box2d.b2SimplexCache.prototype.indexA = null;
goog.exportProperty(box2d.b2SimplexCache.prototype, "indexA", box2d.b2SimplexCache.prototype.indexA);
box2d.b2SimplexCache.prototype.indexB = null;
goog.exportProperty(box2d.b2SimplexCache.prototype, "indexB", box2d.b2SimplexCache.prototype.indexB);
box2d.b2SimplexCache.prototype.Reset = function() {
    this.count = this.metric = 0;
    return this
};
goog.exportProperty(box2d.b2SimplexCache.prototype, "Reset", box2d.b2SimplexCache.prototype.Reset);
box2d.b2DistanceInput = function() {
    this.proxyA = new box2d.b2DistanceProxy;
    this.proxyB = new box2d.b2DistanceProxy;
    this.transformA = new box2d.b2Transform;
    this.transformB = new box2d.b2Transform
};
goog.exportSymbol("box2d.b2DistanceInput", box2d.b2DistanceInput);
box2d.b2DistanceInput.prototype.proxyA = null;
goog.exportProperty(box2d.b2DistanceInput.prototype, "proxyA", box2d.b2DistanceInput.prototype.proxyA);
box2d.b2DistanceInput.prototype.proxyB = null;
goog.exportProperty(box2d.b2DistanceInput.prototype, "proxyB", box2d.b2DistanceInput.prototype.proxyB);
box2d.b2DistanceInput.prototype.transformA = null;
goog.exportProperty(box2d.b2DistanceInput.prototype, "transformA", box2d.b2DistanceInput.prototype.transformA);
box2d.b2DistanceInput.prototype.transformB = null;
goog.exportProperty(box2d.b2DistanceInput.prototype, "transformB", box2d.b2DistanceInput.prototype.transformB);
box2d.b2DistanceInput.prototype.useRadii = !1;
goog.exportProperty(box2d.b2DistanceInput.prototype, "useRadii", box2d.b2DistanceInput.prototype.useRadii);
box2d.b2DistanceInput.prototype.Reset = function() {
    this.proxyA.Reset();
    this.proxyB.Reset();
    this.transformA.SetIdentity();
    this.transformB.SetIdentity();
    this.useRadii = !1;
    return this
};
goog.exportProperty(box2d.b2DistanceInput.prototype, "Reset", box2d.b2DistanceInput.prototype.Reset);
box2d.b2DistanceOutput = function() {
    this.pointA = new box2d.b2Vec2;
    this.pointB = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2DistanceOutput", box2d.b2DistanceOutput);
box2d.b2DistanceOutput.prototype.pointA = null;
goog.exportProperty(box2d.b2DistanceOutput.prototype, "pointA", box2d.b2DistanceOutput.prototype.pointA);
box2d.b2DistanceOutput.prototype.pointB = null;
goog.exportProperty(box2d.b2DistanceOutput.prototype, "pointB", box2d.b2DistanceOutput.prototype.pointB);
box2d.b2DistanceOutput.prototype.distance = 0;
goog.exportProperty(box2d.b2DistanceOutput.prototype, "distance", box2d.b2DistanceOutput.prototype.distance);
box2d.b2DistanceOutput.prototype.iterations = 0;
goog.exportProperty(box2d.b2DistanceOutput.prototype, "iterations", box2d.b2DistanceOutput.prototype.iterations);
box2d.b2DistanceOutput.prototype.Reset = function() {
    this.pointA.SetZero();
    this.pointB.SetZero();
    this.iterations = this.distance = 0;
    return this
};
goog.exportProperty(box2d.b2DistanceOutput.prototype, "Reset", box2d.b2DistanceOutput.prototype.Reset);
box2d.b2_gjkCalls = 0;
goog.exportSymbol("box2d.b2_gjkCalls", box2d.b2_gjkCalls);
box2d.b2_gjkIters = 0;
goog.exportSymbol("box2d.b2_gjkIters", box2d.b2_gjkIters);
box2d.b2_gjkMaxIters = 0;
goog.exportSymbol("box2d.b2_gjkMaxIters", box2d.b2_gjkMaxIters);
box2d.b2SimplexVertex = function() {
    this.wA = new box2d.b2Vec2;
    this.wB = new box2d.b2Vec2;
    this.w = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2SimplexVertex", box2d.b2SimplexVertex);
box2d.b2SimplexVertex.prototype.wA = null;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "wA", box2d.b2SimplexVertex.prototype.wA);
box2d.b2SimplexVertex.prototype.wB = null;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "wB", box2d.b2SimplexVertex.prototype.wB);
box2d.b2SimplexVertex.prototype.w = null;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "w", box2d.b2SimplexVertex.prototype.w);
box2d.b2SimplexVertex.prototype.a = 0;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "a", box2d.b2SimplexVertex.prototype.a);
box2d.b2SimplexVertex.prototype.indexA = 0;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "indexA", box2d.b2SimplexVertex.prototype.indexA);
box2d.b2SimplexVertex.prototype.indexB = 0;
goog.exportProperty(box2d.b2SimplexVertex.prototype, "indexB", box2d.b2SimplexVertex.prototype.indexB);
box2d.b2SimplexVertex.prototype.Copy = function(a) {
    this.wA.Copy(a.wA);
    this.wB.Copy(a.wB);
    this.w.Copy(a.w);
    this.a = a.a;
    this.indexA = a.indexA;
    this.indexB = a.indexB;
    return this
};
goog.exportProperty(box2d.b2SimplexVertex.prototype, "Copy", box2d.b2SimplexVertex.prototype.Copy);
box2d.b2Simplex = function() {
    this.m_v1 = new box2d.b2SimplexVertex;
    this.m_v2 = new box2d.b2SimplexVertex;
    this.m_v3 = new box2d.b2SimplexVertex;
    this.m_vertices = Array(3);
    this.m_vertices[0] = this.m_v1;
    this.m_vertices[1] = this.m_v2;
    this.m_vertices[2] = this.m_v3
};
goog.exportSymbol("box2d.b2Simplex", box2d.b2Simplex);
box2d.b2Simplex.prototype.m_v1 = null;
goog.exportProperty(box2d.b2Simplex.prototype, "m_v1", box2d.b2Simplex.prototype.m_v1);
box2d.b2Simplex.prototype.m_v2 = null;
goog.exportProperty(box2d.b2Simplex.prototype, "m_v2", box2d.b2Simplex.prototype.m_v2);
box2d.b2Simplex.prototype.m_v3 = null;
goog.exportProperty(box2d.b2Simplex.prototype, "m_v3", box2d.b2Simplex.prototype.m_v3);
box2d.b2Simplex.prototype.m_vertices = null;
goog.exportProperty(box2d.b2Simplex.prototype, "m_vertices", box2d.b2Simplex.prototype.m_vertices);
box2d.b2Simplex.prototype.m_count = 0;
goog.exportProperty(box2d.b2Simplex.prototype, "m_count", box2d.b2Simplex.prototype.m_count);
box2d.b2Simplex.prototype.ReadCache = function(a, b, c, e, d) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= a.count && 3 >= a.count);
    this.m_count = a.count;
    for (var f = this.m_vertices, g = 0; g < this.m_count; ++g) {
        var h = f[g];
        h.indexA = a.indexA[g];
        h.indexB = a.indexB[g];
        var l = b.GetVertex(h.indexA), k = e.GetVertex(h.indexB);
        box2d.b2MulXV(c, l, h.wA);
        box2d.b2MulXV(d, k, h.wB);
        box2d.b2SubVV(h.wB, h.wA, h.w);
        h.a = 0
    }
    1 < this.m_count && (a = a.metric, g = this.GetMetric(), g < 0.5 * a || 2 * a < g || g < box2d.b2_epsilon) && (this.m_count = 0);
    0 == this.m_count && (h = f[0],
            h.indexA = 0, h.indexB = 0, l = b.GetVertex(0), k = e.GetVertex(0), box2d.b2MulXV(c, l, h.wA), box2d.b2MulXV(d, k, h.wB), box2d.b2SubVV(h.wB, h.wA, h.w), this.m_count = h.a = 1)
};
goog.exportProperty(box2d.b2Simplex.prototype, "ReadCache", box2d.b2Simplex.prototype.ReadCache);
box2d.b2Simplex.prototype.WriteCache = function(a) {
    a.metric = this.GetMetric();
    a.count = this.m_count;
    for (var b = this.m_vertices, c = 0; c < this.m_count; ++c)
        a.indexA[c] = b[c].indexA, a.indexB[c] = b[c].indexB
};
goog.exportProperty(box2d.b2Simplex.prototype, "WriteCache", box2d.b2Simplex.prototype.WriteCache);
box2d.b2Simplex.prototype.GetSearchDirection = function(a) {
    switch (this.m_count) {
        case 1:
            return box2d.b2NegV(this.m_v1.w, a);
        case 2:
            var b = box2d.b2SubVV(this.m_v2.w, this.m_v1.w, a);
            return 0 < box2d.b2CrossVV(b, box2d.b2NegV(this.m_v1.w, box2d.b2Vec2.s_t0)) ? box2d.b2CrossOneV(b, a) : box2d.b2CrossVOne(b, a);
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), a.SetZero()
        }
};
goog.exportProperty(box2d.b2Simplex.prototype, "GetSearchDirection", box2d.b2Simplex.prototype.GetSearchDirection);
box2d.b2Simplex.prototype.GetClosestPoint = function(a) {
    switch (this.m_count) {
        case 0:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), a.SetZero();
        case 1:
            return a.Copy(this.m_v1.w);
        case 2:
            return a.SetXY(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
        case 3:
            return a.SetZero();
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), a.SetZero()
        }
};
goog.exportProperty(box2d.b2Simplex.prototype, "GetClosestPoint", box2d.b2Simplex.prototype.GetClosestPoint);
box2d.b2Simplex.prototype.GetWitnessPoints = function(a, b) {
    switch (this.m_count) {
        case 0:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1);
            break;
        case 1:
            a.Copy(this.m_v1.wA);
            b.Copy(this.m_v1.wB);
            break;
        case 2:
            a.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
            a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
            b.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
            b.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
            break;
        case 3:
            b.x = a.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x +
                    this.m_v3.a * this.m_v3.wA.x;
            b.y = a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
            break;
        default:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
        }
};
goog.exportProperty(box2d.b2Simplex.prototype, "GetWitnessPoints", box2d.b2Simplex.prototype.GetWitnessPoints);
box2d.b2Simplex.prototype.GetMetric = function() {
    switch (this.m_count) {
        case 0:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0;
        case 1:
            return 0;
        case 2:
            return box2d.b2DistanceVV(this.m_v1.w, this.m_v2.w);
        case 3:
            return box2d.b2CrossVV(box2d.b2SubVV(this.m_v2.w, this.m_v1.w, box2d.b2Vec2.s_t0), box2d.b2SubVV(this.m_v3.w, this.m_v1.w, box2d.b2Vec2.s_t1));
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0
        }
};
goog.exportProperty(box2d.b2Simplex.prototype, "GetMetric", box2d.b2Simplex.prototype.GetMetric);
box2d.b2Simplex.prototype.Solve2 = function() {
    var a = this.m_v1.w, b = this.m_v2.w, c = box2d.b2SubVV(b, a, box2d.b2Simplex.s_e12), a = -box2d.b2DotVV(a, c);
    0 >= a ? this.m_count = this.m_v1.a = 1 : (b = box2d.b2DotVV(b, c), 0 >= b ? (this.m_count = this.m_v2.a = 1, this.m_v1.Copy(this.m_v2)) : (c = 1 / (b + a), this.m_v1.a = b * c, this.m_v2.a = a * c, this.m_count = 2))
};
goog.exportProperty(box2d.b2Simplex.prototype, "Solve2", box2d.b2Simplex.prototype.Solve2);
box2d.b2Simplex.prototype.Solve3 = function() {
    var a = this.m_v1.w, b = this.m_v2.w, c = this.m_v3.w, e = box2d.b2SubVV(b, a, box2d.b2Simplex.s_e12), d = box2d.b2DotVV(a, e), f = box2d.b2DotVV(b, e), d = -d, g = box2d.b2SubVV(c, a, box2d.b2Simplex.s_e13), h = box2d.b2DotVV(a, g), l = box2d.b2DotVV(c, g), h = -h, k = box2d.b2SubVV(c, b, box2d.b2Simplex.s_e23), m = box2d.b2DotVV(b, k), k = box2d.b2DotVV(c, k), m = -m, g = box2d.b2CrossVV(e, g), e = g * box2d.b2CrossVV(b, c), c = g * box2d.b2CrossVV(c, a), a = g * box2d.b2CrossVV(a, b);
    0 >= d && 0 >= h ? this.m_count = this.m_v1.a = 1 : 0 < f &&
            0 < d && 0 >= a ? (l = 1 / (f + d), this.m_v1.a = f * l, this.m_v2.a = d * l, this.m_count = 2) : 0 < l && 0 < h && 0 >= c ? (f = 1 / (l + h), this.m_v1.a = l * f, this.m_v3.a = h * f, this.m_count = 2, this.m_v2.Copy(this.m_v3)) : 0 >= f && 0 >= m ? (this.m_count = this.m_v2.a = 1, this.m_v1.Copy(this.m_v2)) : 0 >= l && 0 >= k ? (this.m_count = this.m_v3.a = 1, this.m_v1.Copy(this.m_v3)) : 0 < k && 0 < m && 0 >= e ? (f = 1 / (k + m), this.m_v2.a = k * f, this.m_v3.a = m * f, this.m_count = 2, this.m_v1.Copy(this.m_v3)) : (f = 1 / (e + c + a), this.m_v1.a = e * f, this.m_v2.a = c * f, this.m_v3.a = a * f, this.m_count = 3)
};
goog.exportProperty(box2d.b2Simplex.prototype, "Solve3", box2d.b2Simplex.prototype.Solve3);
box2d.b2Simplex.s_e12 = new box2d.b2Vec2;
box2d.b2Simplex.s_e13 = new box2d.b2Vec2;
box2d.b2Simplex.s_e23 = new box2d.b2Vec2;
box2d.b2Distance = function(a, b, c) {
    ++box2d.b2_gjkCalls;
    var e = c.proxyA, d = c.proxyB, f = c.transformA, g = c.transformB, h = box2d.b2Distance.s_simplex;
    h.ReadCache(b, e, f, d, g);
    for (var l = h.m_vertices, k = box2d.b2Distance.s_saveA, m = box2d.b2Distance.s_saveB, n = 0, p = 0; 20 > p; ) {
        for (var n = h.m_count, q = 0; q < n; ++q)
            k[q] = l[q].indexA, m[q] = l[q].indexB;
        switch (h.m_count) {
            case 1:
                break;
            case 2:
                h.Solve2();
                break;
            case 3:
                h.Solve3();
                break;
            default:
                box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
        }
        if (3 == h.m_count)
            break;
        var r = h.GetClosestPoint(box2d.b2Distance.s_p);
        r.GetLengthSquared();
        q = h.GetSearchDirection(box2d.b2Distance.s_d);
        if (q.GetLengthSquared() < box2d.b2_epsilon_sq)
            break;
        r = l[h.m_count];
        r.indexA = e.GetSupport(box2d.b2MulTRV(f.q, box2d.b2NegV(q, box2d.b2Vec2.s_t0), box2d.b2Distance.s_supportA));
        box2d.b2MulXV(f, e.GetVertex(r.indexA), r.wA);
        r.indexB = d.GetSupport(box2d.b2MulTRV(g.q, q, box2d.b2Distance.s_supportB));
        box2d.b2MulXV(g, d.GetVertex(r.indexB), r.wB);
        box2d.b2SubVV(r.wB, r.wA, r.w);
        ++p;
        ++box2d.b2_gjkIters;
        for (var t = !1, q = 0; q < n; ++q)
            if (r.indexA == k[q] && r.indexB ==
                    m[q]) {
                t = !0;
                break
            }
        if (t)
            break;
        ++h.m_count
    }
    box2d.b2_gjkMaxIters = box2d.b2Max(box2d.b2_gjkMaxIters, p);
    h.GetWitnessPoints(a.pointA, a.pointB);
    a.distance = box2d.b2DistanceVV(a.pointA, a.pointB);
    a.iterations = p;
    h.WriteCache(b);
    c.useRadii && (b = e.m_radius, d = d.m_radius, a.distance > b + d && a.distance > box2d.b2_epsilon ? (a.distance -= b + d, c = box2d.b2SubVV(a.pointB, a.pointA, box2d.b2Distance.s_normal), c.Normalize(), a.pointA.SelfMulAdd(b, c), a.pointB.SelfMulSub(d, c)) : (r = box2d.b2MidVV(a.pointA, a.pointB, box2d.b2Distance.s_p), a.pointA.Copy(r),
            a.pointB.Copy(r), a.distance = 0))
};
goog.exportSymbol("box2d.b2Distance", box2d.b2Distance);
box2d.b2Distance.s_simplex = new box2d.b2Simplex;
box2d.b2Distance.s_saveA = box2d.b2MakeNumberArray(3);
box2d.b2Distance.s_saveB = box2d.b2MakeNumberArray(3);
box2d.b2Distance.s_p = new box2d.b2Vec2;
box2d.b2Distance.s_d = new box2d.b2Vec2;
box2d.b2Distance.s_normal = new box2d.b2Vec2;
box2d.b2Distance.s_supportA = new box2d.b2Vec2;
box2d.b2Distance.s_supportB = new box2d.b2Vec2;
box2d.b2WeldJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_weldJoint);
    this.localAnchorA = new box2d.b2Vec2;
    this.localAnchorB = new box2d.b2Vec2
};
goog.inherits(box2d.b2WeldJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2WeldJointDef", box2d.b2WeldJointDef);
box2d.b2WeldJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "localAnchorA", box2d.b2WeldJointDef.prototype.localAnchorA);
box2d.b2WeldJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "localAnchorB", box2d.b2WeldJointDef.prototype.localAnchorB);
box2d.b2WeldJointDef.prototype.referenceAngle = 0;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "referenceAngle", box2d.b2WeldJointDef.prototype.referenceAngle);
box2d.b2WeldJointDef.prototype.frequencyHz = 0;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "frequencyHz", box2d.b2WeldJointDef.prototype.frequencyHz);
box2d.b2WeldJointDef.prototype.dampingRatio = 0;
goog.exportProperty(box2d.b2WeldJointDef.prototype, "dampingRatio", box2d.b2WeldJointDef.prototype.dampingRatio);
box2d.b2WeldJointDef.prototype.Initialize = function(a, b, c) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB);
    this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians()
};
goog.exportProperty(box2d.b2WeldJointDef.prototype, "Initialize", box2d.b2WeldJointDef.prototype.Initialize);
box2d.b2WeldJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_referenceAngle = a.referenceAngle;
    this.m_impulse = new box2d.b2Vec3(0, 0, 0);
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_mass = new box2d.b2Mat33;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA =
            new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_K = new box2d.b2Mat33
};
goog.inherits(box2d.b2WeldJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2WeldJoint", box2d.b2WeldJoint);
box2d.b2WeldJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_frequencyHz", box2d.b2WeldJoint.prototype.m_frequencyHz);
box2d.b2WeldJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_dampingRatio", box2d.b2WeldJoint.prototype.m_dampingRatio);
box2d.b2WeldJoint.prototype.m_bias = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_bias", box2d.b2WeldJoint.prototype.m_bias);
box2d.b2WeldJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_localAnchorA", box2d.b2WeldJoint.prototype.m_localAnchorA);
box2d.b2WeldJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_localAnchorB", box2d.b2WeldJoint.prototype.m_localAnchorB);
box2d.b2WeldJoint.prototype.m_referenceAngle = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_referenceAngle", box2d.b2WeldJoint.prototype.m_referenceAngle);
box2d.b2WeldJoint.prototype.m_gamma = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_gamma", box2d.b2WeldJoint.prototype.m_gamma);
box2d.b2WeldJoint.prototype.m_impulse = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_impulse", box2d.b2WeldJoint.prototype.m_impulse);
box2d.b2WeldJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_indexA", box2d.b2WeldJoint.prototype.m_indexA);
box2d.b2WeldJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_indexB", box2d.b2WeldJoint.prototype.m_indexB);
box2d.b2WeldJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_rA", box2d.b2WeldJoint.prototype.m_rA);
box2d.b2WeldJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_rB", box2d.b2WeldJoint.prototype.m_rB);
box2d.b2WeldJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_localCenterA", box2d.b2WeldJoint.prototype.m_localCenterA);
box2d.b2WeldJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_localCenterB", box2d.b2WeldJoint.prototype.m_localCenterB);
box2d.b2WeldJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_invMassA", box2d.b2WeldJoint.prototype.m_invMassA);
box2d.b2WeldJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_invMassB", box2d.b2WeldJoint.prototype.m_invMassB);
box2d.b2WeldJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_invIA", box2d.b2WeldJoint.prototype.m_invIA);
box2d.b2WeldJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_invIB", box2d.b2WeldJoint.prototype.m_invIB);
box2d.b2WeldJoint.prototype.m_mass = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_mass", box2d.b2WeldJoint.prototype.m_mass);
box2d.b2WeldJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_qA", box2d.b2WeldJoint.prototype.m_qA);
box2d.b2WeldJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_qB", box2d.b2WeldJoint.prototype.m_qB);
box2d.b2WeldJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_lalcA", box2d.b2WeldJoint.prototype.m_lalcA);
box2d.b2WeldJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_lalcB", box2d.b2WeldJoint.prototype.m_lalcB);
box2d.b2WeldJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2WeldJoint.prototype, "m_K", box2d.b2WeldJoint.prototype.m_K);
box2d.b2WeldJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].a, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].a, f = a.velocities[this.m_indexB].v, g = a.velocities[this.m_indexB].w, h = this.m_qA.SetAngleRadians(b), l = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(h, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(l, this.m_lalcB, this.m_rB);
    var h = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB, n = this.m_K;
    n.ex.x = h + l + this.m_rA.y * this.m_rA.y * k + this.m_rB.y *
            this.m_rB.y * m;
    n.ey.x = -this.m_rA.y * this.m_rA.x * k - this.m_rB.y * this.m_rB.x * m;
    n.ez.x = -this.m_rA.y * k - this.m_rB.y * m;
    n.ex.y = n.ey.x;
    n.ey.y = h + l + this.m_rA.x * this.m_rA.x * k + this.m_rB.x * this.m_rB.x * m;
    n.ez.y = this.m_rA.x * k + this.m_rB.x * m;
    n.ex.z = n.ez.x;
    n.ey.z = n.ez.y;
    n.ez.z = k + m;
    if (0 < this.m_frequencyHz) {
        n.GetInverse22(this.m_mass);
        var n = k + m, p = 0 < n ? 1 / n : 0, b = d - b - this.m_referenceAngle, d = 2 * box2d.b2_pi * this.m_frequencyHz, q = p * d * d, r = a.step.dt;
        this.m_gamma = r * (2 * p * this.m_dampingRatio * d + r * q);
        this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma :
                0;
        this.m_bias = b * r * q * this.m_gamma;
        n += this.m_gamma;
        this.m_mass.ez.z = 0 != n ? 1 / n : 0
    } else
        n.GetSymInverse33(this.m_mass), this.m_bias = this.m_gamma = 0;
    a.step.warmStarting ? (this.m_impulse.SelfMul(a.step.dtRatio), n = box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y), c.SelfMulSub(h, n), e -= k * (box2d.b2CrossVV(this.m_rA, n) + this.m_impulse.z), f.SelfMulAdd(l, n), g += m * (box2d.b2CrossVV(this.m_rB, n) + this.m_impulse.z)) : this.m_impulse.SetZero();
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w =
    g
};
box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB;
    if (0 < this.m_frequencyHz) {
        var k = -this.m_mass.ez.z * (d - c + this.m_bias + this.m_gamma * this.m_impulse.z);
        this.m_impulse.z += k;
        c -= h * k;
        d += l * k;
        k = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1),
                box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1);
        k = box2d.b2MulM33XY(this.m_mass, k.x, k.y, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1).SelfNeg();
        this.m_impulse.x += k.x;
        this.m_impulse.y += k.y;
        b.SelfMulSub(f, k);
        c -= h * box2d.b2CrossVV(this.m_rA, k);
        e.SelfMulAdd(g, k);
        d += l * box2d.b2CrossVV(this.m_rB, k)
    } else {
        var k = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1),
                m = box2d.b2MulM33XYZ(this.m_mass, k.x, k.y, d - c, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg();
        this.m_impulse.SelfAdd(m);
        k = box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P.SetXY(m.x, m.y);
        b.SelfMulSub(f, k);
        c -= h * (box2d.b2CrossVV(this.m_rA, k) + m.z);
        e.SelfMulAdd(g, k);
        d += l * (box2d.b2CrossVV(this.m_rB, k) + m.z)
    }
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "SolveVelocityConstraints", box2d.b2WeldJoint.prototype.SolveVelocityConstraints);
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1 = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec3;
box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d), h = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB;
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var n = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var p = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), q = this.m_K;
    q.ex.x = h + l + n.y * n.y * k + p.y * p.y * m;
    q.ey.x = -n.y * n.x * k - p.y * p.x * m;
    q.ez.x = -n.y * k - p.y * m;
    q.ex.y = q.ey.x;
    q.ey.y = h + l + n.x * n.x * k + p.x * p.x * m;
    q.ez.y = n.x * k + p.x * m;
    q.ex.z = q.ez.x;
    q.ey.z = q.ez.y;
    q.ez.z = k + m;
    if (0 < this.m_frequencyHz) {
        var r = box2d.b2SubVV(box2d.b2AddVV(e, p, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, n, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1), g = r.GetLength(), f = 0, q = q.Solve22(r.x, r.y, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P).SelfNeg();
        b.SelfMulSub(h, q);
        c -= k * box2d.b2CrossVV(n, q);
        e.SelfMulAdd(l, q);
        d += m * box2d.b2CrossVV(p, q)
    } else
        r = box2d.b2SubVV(box2d.b2AddVV(e, p, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, n, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1), n = d - c - this.m_referenceAngle, g = r.GetLength(), f = box2d.b2Abs(n), n = q.Solve33(r.x, r.y, n, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg(), q = box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P.SetXY(n.x, n.y), b.SelfMulSub(h, q), c -= k * (box2d.b2CrossVV(this.m_rA,
                q) + n.z), e.SelfMulAdd(l, q), d += m * (box2d.b2CrossVV(this.m_rB, q) + n.z);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return g <= box2d.b2_linearSlop && f <= box2d.b2_angularSlop
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "SolvePositionConstraints", box2d.b2WeldJoint.prototype.SolvePositionConstraints);
box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1 = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3;
box2d.b2WeldJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetAnchorA", box2d.b2WeldJoint.prototype.GetAnchorA);
box2d.b2WeldJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetAnchorB", box2d.b2WeldJoint.prototype.GetAnchorB);
box2d.b2WeldJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_impulse.x, a * this.m_impulse.y)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetReactionForce", box2d.b2WeldJoint.prototype.GetReactionForce);
box2d.b2WeldJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_impulse.z
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetReactionTorque", box2d.b2WeldJoint.prototype.GetReactionTorque);
box2d.b2WeldJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetLocalAnchorA", box2d.b2WeldJoint.prototype.GetLocalAnchorA);
box2d.b2WeldJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetLocalAnchorB", box2d.b2WeldJoint.prototype.GetLocalAnchorB);
box2d.b2WeldJoint.prototype.GetReferenceAngle = function() {
    return this.m_referenceAngle
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetReferenceAngle", box2d.b2WeldJoint.prototype.GetReferenceAngle);
box2d.b2WeldJoint.prototype.SetFrequency = function(a) {
    this.m_frequencyHz = a
};
box2d.b2WeldJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetFrequency", box2d.b2WeldJoint.prototype.GetFrequency);
box2d.b2WeldJoint.prototype.SetDampingRatio = function(a) {
    this.m_dampingRatio = a
};
box2d.b2WeldJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "GetDampingRatio", box2d.b2WeldJoint.prototype.GetDampingRatio);
box2d.b2WeldJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2WeldJointDef*/ var jd = new box2d.b2WeldJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
        box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
        box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2WeldJoint.prototype, "Dump", box2d.b2WeldJoint.prototype.Dump);
box2d.b2RopeJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_ropeJoint);
    this.localAnchorA = new box2d.b2Vec2(-1, 0);
    this.localAnchorB = new box2d.b2Vec2(1, 0)
};
goog.inherits(box2d.b2RopeJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2RopeJointDef", box2d.b2RopeJointDef);
box2d.b2RopeJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2RopeJointDef.prototype, "localAnchorA", box2d.b2RopeJointDef.prototype.localAnchorA);
box2d.b2RopeJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2RopeJointDef.prototype, "localAnchorB", box2d.b2RopeJointDef.prototype.localAnchorB);
box2d.b2RopeJointDef.prototype.maxLength = 0;
goog.exportProperty(box2d.b2RopeJointDef.prototype, "maxLength", box2d.b2RopeJointDef.prototype.maxLength);
box2d.b2RopeJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_maxLength = a.maxLength;
    this.m_u = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2
};
goog.inherits(box2d.b2RopeJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2RopeJoint", box2d.b2RopeJoint);
box2d.b2RopeJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_localAnchorA", box2d.b2RopeJoint.prototype.m_localAnchorA);
box2d.b2RopeJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_localAnchorB", box2d.b2RopeJoint.prototype.m_localAnchorB);
box2d.b2RopeJoint.prototype.m_maxLength = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_maxLength", box2d.b2RopeJoint.prototype.m_maxLength);
box2d.b2RopeJoint.prototype.m_length = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_length", box2d.b2RopeJoint.prototype.m_length);
box2d.b2RopeJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_impulse", box2d.b2RopeJoint.prototype.m_impulse);
box2d.b2RopeJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_indexA", box2d.b2RopeJoint.prototype.m_indexA);
box2d.b2RopeJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_indexB", box2d.b2RopeJoint.prototype.m_indexB);
box2d.b2RopeJoint.prototype.m_u = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_u", box2d.b2RopeJoint.prototype.m_u);
box2d.b2RopeJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_rA", box2d.b2RopeJoint.prototype.m_rA);
box2d.b2RopeJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_rB", box2d.b2RopeJoint.prototype.m_rB);
box2d.b2RopeJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_localCenterA", box2d.b2RopeJoint.prototype.m_localCenterA);
box2d.b2RopeJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_localCenterB", box2d.b2RopeJoint.prototype.m_localCenterB);
box2d.b2RopeJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_invMassA", box2d.b2RopeJoint.prototype.m_invMassA);
box2d.b2RopeJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_invMassB", box2d.b2RopeJoint.prototype.m_invMassB);
box2d.b2RopeJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_invIA", box2d.b2RopeJoint.prototype.m_invIA);
box2d.b2RopeJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_invIB", box2d.b2RopeJoint.prototype.m_invIB);
box2d.b2RopeJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_mass", box2d.b2RopeJoint.prototype.m_mass);
box2d.b2RopeJoint.prototype.m_state = box2d.b2LimitState.e_inactiveLimit;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_state", box2d.b2RopeJoint.prototype.m_state);
box2d.b2RopeJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_qA", box2d.b2RopeJoint.prototype.m_qA);
box2d.b2RopeJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_qB", box2d.b2RopeJoint.prototype.m_qB);
box2d.b2RopeJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_lalcA", box2d.b2RopeJoint.prototype.m_lalcA);
box2d.b2RopeJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2RopeJoint.prototype, "m_lalcB", box2d.b2RopeJoint.prototype.m_lalcB);
box2d.b2RopeJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].c, f = a.positions[this.m_indexB].a, g = a.velocities[this.m_indexB].v, h = a.velocities[this.m_indexB].w, l = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), f = this.m_qB.SetAngleRadians(f);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(f, this.m_lalcB, this.m_rB);
    this.m_u.Copy(d).SelfAdd(this.m_rB).SelfSub(b).SelfSub(this.m_rA);
    this.m_length =
            this.m_u.GetLength();
    this.m_state = 0 < this.m_length - this.m_maxLength ? box2d.b2LimitState.e_atUpperLimit : box2d.b2LimitState.e_inactiveLimit;
    this.m_length > box2d.b2_linearSlop ? (this.m_u.SelfMul(1 / this.m_length), b = box2d.b2CrossVV(this.m_rA, this.m_u), d = box2d.b2CrossVV(this.m_rB, this.m_u), b = this.m_invMassA + this.m_invIA * b * b + this.m_invMassB + this.m_invIB * d * d, this.m_mass = 0 != b ? 1 / b : 0, a.step.warmStarting ? (this.m_impulse *= a.step.dtRatio, b = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P),
            c.SelfMulSub(this.m_invMassA, b), e -= this.m_invIA * box2d.b2CrossVV(this.m_rA, b), g.SelfMulAdd(this.m_invMassB, b), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, b)) : this.m_impulse = 0, a.velocities[this.m_indexA].w = e, a.velocities[this.m_indexB].w = h) : (this.m_u.SetZero(), this.m_impulse = this.m_mass = 0)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "InitVelocityConstraints", box2d.b2RopeJoint.prototype.InitVelocityConstraints);
box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA), g = box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB), h = this.m_length - this.m_maxLength, f = box2d.b2DotVV(this.m_u, box2d.b2SubVV(g, f, box2d.b2Vec2.s_t0));
    0 > h && (f += a.step.inv_dt *
            h);
    h = -this.m_mass * f;
    f = this.m_impulse;
    this.m_impulse = box2d.b2Min(0, this.m_impulse + h);
    h = this.m_impulse - f;
    h = box2d.b2MulSV(h, this.m_u, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P);
    b.SelfMulSub(this.m_invMassA, h);
    c -= this.m_invIA * box2d.b2CrossVV(this.m_rA, h);
    e.SelfMulAdd(this.m_invMassB, h);
    d += this.m_invIB * box2d.b2CrossVV(this.m_rB, h);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "SolveVelocityConstraints", box2d.b2RopeJoint.prototype.SolveVelocityConstraints);
box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    f = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var g = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), h = this.m_u.Copy(e).SelfAdd(g).SelfSub(b).SelfSub(f),
            l = h.Normalize(), k = l - this.m_maxLength, k = box2d.b2Clamp(k, 0, box2d.b2_maxLinearCorrection), h = box2d.b2MulSV(-this.m_mass * k, h, box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P);
    b.SelfMulSub(this.m_invMassA, h);
    c -= this.m_invIA * box2d.b2CrossVV(f, h);
    e.SelfMulAdd(this.m_invMassB, h);
    d += this.m_invIB * box2d.b2CrossVV(g, h);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return l - this.m_maxLength < box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "SolvePositionConstraints", box2d.b2RopeJoint.prototype.SolvePositionConstraints);
box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2RopeJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetAnchorA", box2d.b2RopeJoint.prototype.GetAnchorA);
box2d.b2RopeJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetAnchorB", box2d.b2RopeJoint.prototype.GetAnchorB);
box2d.b2RopeJoint.prototype.GetReactionForce = function(a, b) {
    return box2d.b2MulSV(a * this.m_impulse, this.m_u, b)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetReactionForce", box2d.b2RopeJoint.prototype.GetReactionForce);
box2d.b2RopeJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetReactionTorque", box2d.b2RopeJoint.prototype.GetReactionTorque);
box2d.b2RopeJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetLocalAnchorA", box2d.b2RopeJoint.prototype.GetLocalAnchorA);
box2d.b2RopeJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetLocalAnchorB", box2d.b2RopeJoint.prototype.GetLocalAnchorB);
box2d.b2RopeJoint.prototype.SetMaxLength = function(a) {
    this.m_maxLength = a
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "SetMaxLength", box2d.b2RopeJoint.prototype.SetMaxLength);
box2d.b2RopeJoint.prototype.GetMaxLength = function() {
    return this.m_maxLength
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetMaxLength", box2d.b2RopeJoint.prototype.GetMaxLength);
box2d.b2RopeJoint.prototype.GetLimitState = function() {
    return this.m_state
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "GetLimitState", box2d.b2RopeJoint.prototype.GetLimitState);
box2d.b2RopeJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2RopeJointDef*/ var jd = new box2d.b2RopeJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.maxLength = %.15f;\n", this.m_maxLength);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2RopeJoint.prototype, "Dump", box2d.b2RopeJoint.prototype.Dump);
box2d.b2GravityController = function() {
    box2d.b2Controller.call(this)
};
goog.inherits(box2d.b2GravityController, box2d.b2Controller);
goog.exportSymbol("box2d.b2GravityController", box2d.b2GravityController);
box2d.b2GravityController.prototype.G = 1;
goog.exportProperty(box2d.b2GravityController.prototype, "G", box2d.b2GravityController.prototype.G);
box2d.b2GravityController.prototype.invSqr = !0;
goog.exportProperty(box2d.b2GravityController.prototype, "invSqr", box2d.b2GravityController.prototype.invSqr);
box2d.b2GravityController.prototype.Step = function(a) {
    if (this.invSqr)
        for (a = this.m_bodyList; a; a = a.nextBody)
            for (var b = a.body, c = b.GetWorldCenter(), e = b.GetMass(), d = this.m_bodyList; d != a; d = d.nextBody) {
                var f = d.body, g = f.GetWorldCenter(), h = f.GetMass(), l = g.x - c.x, k = g.y - c.y, m = l * l + k * k;
                m < box2d.b2_epsilon || (l = box2d.b2GravityController.prototype.Step.s_f.SetXY(l, k), l.SelfMul(this.G / m / box2d.b2Sqrt(m) * e * h), b.IsAwake() && b.ApplyForce(l, c), f.IsAwake() && f.ApplyForce(l.SelfMul(-1), g))
            }
    else
        for (a = this.m_bodyList; a; a = a.nextBody)
            for (b =
                    a.body, c = b.GetWorldCenter(), e = b.GetMass(), d = this.m_bodyList; d != a; d = d.nextBody)
                f = d.body, g = f.GetWorldCenter(), h = f.GetMass(), l = g.x - c.x, k = g.y - c.y, m = l * l + k * k, m < box2d.b2_epsilon || (l = box2d.b2GravityController.prototype.Step.s_f.SetXY(l, k), l.SelfMul(this.G / m * e * h), b.IsAwake() && b.ApplyForce(l, c), f.IsAwake() && f.ApplyForce(l.SelfMul(-1), g))
};
goog.exportProperty(box2d.b2GravityController.prototype, "Step", box2d.b2GravityController.prototype.Step);
box2d.b2GravityController.prototype.Step.s_f = new box2d.b2Vec2;
box2d.b2Profile = function() {
};
goog.exportSymbol("box2d.b2Profile", box2d.b2Profile);
box2d.b2Profile.prototype.step = 0;
goog.exportProperty(box2d.b2Profile.prototype, "step", box2d.b2Profile.prototype.step);
box2d.b2Profile.prototype.collide = 0;
goog.exportProperty(box2d.b2Profile.prototype, "collide", box2d.b2Profile.prototype.collide);
box2d.b2Profile.prototype.solve = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solve", box2d.b2Profile.prototype.solve);
box2d.b2Profile.prototype.solveInit = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solveInit", box2d.b2Profile.prototype.solveInit);
box2d.b2Profile.prototype.solveVelocity = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solveVelocity", box2d.b2Profile.prototype.solveVelocity);
box2d.b2Profile.prototype.solvePosition = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solvePosition", box2d.b2Profile.prototype.solvePosition);
box2d.b2Profile.prototype.broadphase = 0;
goog.exportProperty(box2d.b2Profile.prototype, "broadphase", box2d.b2Profile.prototype.broadphase);
box2d.b2Profile.prototype.solveTOI = 0;
goog.exportProperty(box2d.b2Profile.prototype, "solveTOI", box2d.b2Profile.prototype.solveTOI);
box2d.b2Profile.prototype.Reset = function() {
    this.solveTOI = this.broadphase = this.solvePosition = this.solveVelocity = this.solveInit = this.solve = this.collide = this.step = 0;
    return this
};
goog.exportProperty(box2d.b2Profile.prototype, "Reset", box2d.b2Profile.prototype.Reset);
box2d.b2TimeStep = function() {
};
goog.exportSymbol("box2d.b2TimeStep", box2d.b2TimeStep);
box2d.b2TimeStep.prototype.dt = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "dt", box2d.b2TimeStep.prototype.dt);
box2d.b2TimeStep.prototype.inv_dt = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "inv_dt", box2d.b2TimeStep.prototype.inv_dt);
box2d.b2TimeStep.prototype.dtRatio = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "dtRatio", box2d.b2TimeStep.prototype.dtRatio);
box2d.b2TimeStep.prototype.velocityIterations = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "velocityIterations", box2d.b2TimeStep.prototype.velocityIterations);
box2d.b2TimeStep.prototype.positionIterations = 0;
goog.exportProperty(box2d.b2TimeStep.prototype, "positionIterations", box2d.b2TimeStep.prototype.positionIterations);
box2d.b2TimeStep.prototype.warmStarting = !1;
goog.exportProperty(box2d.b2TimeStep.prototype, "warmStarting", box2d.b2TimeStep.prototype.warmStarting);
box2d.b2TimeStep.prototype.Copy = function(a) {
    this.dt = a.dt;
    this.inv_dt = a.inv_dt;
    this.dtRatio = a.dtRatio;
    this.positionIterations = a.positionIterations;
    this.velocityIterations = a.velocityIterations;
    this.warmStarting = a.warmStarting;
    return this
};
goog.exportProperty(box2d.b2TimeStep.prototype, "Copy", box2d.b2TimeStep.prototype.Copy);
box2d.b2Position = function() {
    this.c = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Position", box2d.b2Position);
box2d.b2Position.prototype.c = null;
goog.exportProperty(box2d.b2Position.prototype, "c", box2d.b2Position.prototype.c);
box2d.b2Position.prototype.a = 0;
goog.exportProperty(box2d.b2Position.prototype, "a", box2d.b2Position.prototype.a);
box2d.b2Position.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2Position
    })
};
goog.exportProperty(box2d.b2Position, "MakeArray", box2d.b2Position.MakeArray);
box2d.b2Velocity = function() {
    this.v = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Velocity", box2d.b2Velocity);
box2d.b2Velocity.prototype.v = null;
goog.exportProperty(box2d.b2Velocity.prototype, "v", box2d.b2Velocity.prototype.v);
box2d.b2Velocity.prototype.w = 0;
goog.exportProperty(box2d.b2Velocity.prototype, "w", box2d.b2Velocity.prototype.w);
box2d.b2Velocity.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2Velocity
    })
};
goog.exportProperty(box2d.b2Velocity, "MakeArray", box2d.b2Velocity.MakeArray);
box2d.b2SolverData = function() {
    this.step = new box2d.b2TimeStep
};
goog.exportSymbol("box2d.b2SolverData", box2d.b2SolverData);
box2d.b2SolverData.prototype.step = null;
goog.exportProperty(box2d.b2SolverData.prototype, "step", box2d.b2SolverData.prototype.step);
box2d.b2SolverData.prototype.positions = null;
goog.exportProperty(box2d.b2SolverData.prototype, "positions", box2d.b2SolverData.prototype.positions);
box2d.b2SolverData.prototype.velocities = null;
goog.exportProperty(box2d.b2SolverData.prototype, "velocities", box2d.b2SolverData.prototype.velocities);
box2d.b2Collision = {};
box2d.b2ContactFeatureType = {e_vertex: 0, e_face: 1};
goog.exportSymbol("box2d.b2ContactFeatureType", box2d.b2ContactFeatureType);
goog.exportProperty(box2d.b2ContactFeatureType, "e_vertex", box2d.b2ContactFeatureType.e_vertex);
goog.exportProperty(box2d.b2ContactFeatureType, "e_face", box2d.b2ContactFeatureType.e_face);
box2d.b2ContactFeature = function(a) {
    this._id = a
};
goog.exportSymbol("box2d.b2ContactFeature", box2d.b2ContactFeature);
box2d.b2ContactFeature.prototype._id = null;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_id", box2d.b2ContactFeature.prototype._id);
box2d.b2ContactFeature.prototype._indexA = 0;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_indexA", box2d.b2ContactFeature.prototype._indexA);
box2d.b2ContactFeature.prototype._indexB = 0;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_indexB", box2d.b2ContactFeature.prototype._indexB);
box2d.b2ContactFeature.prototype._typeA = 0;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_typeA", box2d.b2ContactFeature.prototype._typeA);
box2d.b2ContactFeature.prototype._typeB = 0;
goog.exportProperty(box2d.b2ContactFeature.prototype, "_typeB", box2d.b2ContactFeature.prototype._typeB);
Object.defineProperty(box2d.b2ContactFeature.prototype, "indexA", {enumerable: !1, configurable: !0, get: function() {
        return this._indexA
    }, set: function(a) {
        this._indexA = a;
        this._id._key = this._id._key & 4294967040 | this._indexA & 255
    }});
Object.defineProperty(box2d.b2ContactFeature.prototype, "indexB", {enumerable: !1, configurable: !0, get: function() {
        return this._indexB
    }, set: function(a) {
        this._indexB = a;
        this._id._key = this._id._key & 4294902015 | this._indexB << 8 & 65280
    }});
Object.defineProperty(box2d.b2ContactFeature.prototype, "typeA", {enumerable: !1, configurable: !0, get: function() {
        return this._typeA
    }, set: function(a) {
        this._typeA = a;
        this._id._key = this._id._key & 4278255615 | this._typeA << 16 & 16711680
    }});
Object.defineProperty(box2d.b2ContactFeature.prototype, "typeB", {enumerable: !1, configurable: !0, get: function() {
        return this._typeB
    }, set: function(a) {
        this._typeB = a;
        this._id._key = this._id._key & 16777215 | this._typeB << 24 & 4278190080
    }});
box2d.b2ContactID = function() {
    this.cf = new box2d.b2ContactFeature(this)
};
goog.exportSymbol("box2d.b2ContactID", box2d.b2ContactID);
box2d.b2ContactID.prototype.cf = null;
goog.exportProperty(box2d.b2ContactID.prototype, "cf", box2d.b2ContactID.prototype.cf);
box2d.b2ContactID.prototype.key = 0;
goog.exportProperty(box2d.b2ContactID.prototype, "key", box2d.b2ContactID.prototype.key);
box2d.b2ContactID.prototype.Copy = function(a) {
    this.key = a.key;
    return this
};
goog.exportProperty(box2d.b2ContactID.prototype, "Copy", box2d.b2ContactID.prototype.Copy);
box2d.b2ContactID.prototype.Clone = function() {
    return(new box2d.b2ContactID).Copy(this)
};
goog.exportProperty(box2d.b2ContactID.prototype, "Clone", box2d.b2ContactID.prototype.Clone);
Object.defineProperty(box2d.b2ContactID.prototype, "key", {enumerable: !1, configurable: !0, get: function() {
        return this._key
    }, set: function(a) {
        this._key = a;
        this.cf._indexA = this._key & 255;
        this.cf._indexB = this._key >> 8 & 255;
        this.cf._typeA = this._key >> 16 & 255;
        this.cf._typeB = this._key >> 24 & 255
    }});
box2d.b2ManifoldPoint = function() {
    this.localPoint = new box2d.b2Vec2;
    this.id = new box2d.b2ContactID
};
goog.exportSymbol("box2d.b2ManifoldPoint", box2d.b2ManifoldPoint);
box2d.b2ManifoldPoint.prototype.localPoint = null;
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "localPoint", box2d.b2ManifoldPoint.prototype.localPoint);
box2d.b2ManifoldPoint.prototype.normalImpulse = 0;
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "normalImpulse", box2d.b2ManifoldPoint.prototype.normalImpulse);
box2d.b2ManifoldPoint.prototype.tangentImpulse = 0;
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "tangentImpulse", box2d.b2ManifoldPoint.prototype.tangentImpulse);
box2d.b2ManifoldPoint.prototype.id = null;
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "id", box2d.b2ManifoldPoint.prototype.id);
box2d.b2ManifoldPoint.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2ManifoldPoint
    })
};
goog.exportProperty(box2d.b2ManifoldPoint, "MakeArray", box2d.b2ManifoldPoint.MakeArray);
box2d.b2ManifoldPoint.prototype.Reset = function() {
    this.localPoint.SetZero();
    this.tangentImpulse = this.normalImpulse = 0;
    this.id.key = 0
};
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "Reset", box2d.b2ManifoldPoint.prototype.Reset);
box2d.b2ManifoldPoint.prototype.Copy = function(a) {
    this.localPoint.Copy(a.localPoint);
    this.normalImpulse = a.normalImpulse;
    this.tangentImpulse = a.tangentImpulse;
    this.id.Copy(a.id);
    return this
};
goog.exportProperty(box2d.b2ManifoldPoint.prototype, "Copy", box2d.b2ManifoldPoint.prototype.Copy);
box2d.b2ManifoldType = {e_unknown: -1, e_circles: 0, e_faceA: 1, e_faceB: 2};
goog.exportSymbol("box2d.b2ManifoldType", box2d.b2ManifoldType);
goog.exportProperty(box2d.b2ManifoldType, "e_unknown", box2d.b2ManifoldType.e_unknown);
goog.exportProperty(box2d.b2ManifoldType, "e_circles", box2d.b2ManifoldType.e_circles);
goog.exportProperty(box2d.b2ManifoldType, "e_faceA", box2d.b2ManifoldType.e_faceA);
goog.exportProperty(box2d.b2ManifoldType, "e_faceB", box2d.b2ManifoldType.e_faceB);
box2d.b2Manifold = function() {
    this.points = box2d.b2ManifoldPoint.MakeArray(box2d.b2_maxManifoldPoints);
    this.localNormal = new box2d.b2Vec2;
    this.localPoint = new box2d.b2Vec2;
    this.type = box2d.b2ManifoldType.e_unknown;
    this.pointCount = 0
};
goog.exportSymbol("box2d.b2Manifold", box2d.b2Manifold);
box2d.b2Manifold.prototype.points = null;
goog.exportProperty(box2d.b2Manifold.prototype, "points", box2d.b2Manifold.prototype.points);
box2d.b2Manifold.prototype.localNormal = null;
goog.exportProperty(box2d.b2Manifold.prototype, "localNormal", box2d.b2Manifold.prototype.localNormal);
box2d.b2Manifold.prototype.localPoint = null;
goog.exportProperty(box2d.b2Manifold.prototype, "localPoint", box2d.b2Manifold.prototype.localPoint);
box2d.b2Manifold.prototype.type = box2d.b2ManifoldType.e_unknown;
goog.exportProperty(box2d.b2Manifold.prototype, "type", box2d.b2Manifold.prototype.type);
box2d.b2Manifold.prototype.pointCount = 0;
goog.exportProperty(box2d.b2Manifold.prototype, "pointCount", box2d.b2Manifold.prototype.pointCount);
box2d.b2Manifold.prototype.Reset = function() {
    for (var a = 0, b = box2d.b2_maxManifoldPoints; a < b; ++a)
        this.points[a].Reset();
    this.localNormal.SetZero();
    this.localPoint.SetZero();
    this.type = box2d.b2ManifoldType.e_unknown;
    this.pointCount = 0
};
goog.exportProperty(box2d.b2Manifold.prototype, "Reset", box2d.b2Manifold.prototype.Reset);
box2d.b2Manifold.prototype.Copy = function(a) {
    this.pointCount = a.pointCount;
    for (var b = 0, c = box2d.b2_maxManifoldPoints; b < c; ++b)
        this.points[b].Copy(a.points[b]);
    this.localNormal.Copy(a.localNormal);
    this.localPoint.Copy(a.localPoint);
    this.type = a.type;
    return this
};
goog.exportProperty(box2d.b2Manifold.prototype, "Copy", box2d.b2Manifold.prototype.Copy);
box2d.b2Manifold.prototype.Clone = function() {
    return(new box2d.b2Manifold).Copy(this)
};
goog.exportProperty(box2d.b2Manifold.prototype, "Clone", box2d.b2Manifold.prototype.Clone);
box2d.b2WorldManifold = function() {
    this.normal = new box2d.b2Vec2;
    this.points = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints)
};
goog.exportSymbol("box2d.b2WorldManifold", box2d.b2WorldManifold);
box2d.b2WorldManifold.prototype.normal = null;
goog.exportProperty(box2d.b2WorldManifold.prototype, "normal", box2d.b2WorldManifold.prototype.normal);
box2d.b2WorldManifold.prototype.points = null;
goog.exportProperty(box2d.b2WorldManifold.prototype, "points", box2d.b2WorldManifold.prototype.points);
box2d.b2WorldManifold.prototype.Initialize = function(a, b, c, e, d) {
    if (0 != a.pointCount)
        switch (a.type) {
            case box2d.b2ManifoldType.e_circles:
                this.normal.SetXY(1, 0);
                b = box2d.b2MulXV(b, a.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointA);
                a = box2d.b2MulXV(e, a.points[0].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointB);
                box2d.b2DistanceSquaredVV(b, a) > box2d.b2_epsilon_sq && box2d.b2SubVV(a, b, this.normal).SelfNormalize();
                var f = box2d.b2AddVMulSV(b, c, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA),
                        g = box2d.b2SubVMulSV(a, d, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
                box2d.b2MidVV(f, g, this.points[0]);
                break;
            case box2d.b2ManifoldType.e_faceA:
                box2d.b2MulRV(b.q, a.localNormal, this.normal);
                for (var h = box2d.b2MulXV(b, a.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint), l = 0, k = a.pointCount; l < k; ++l) {
                    var m = box2d.b2MulXV(e, a.points[l].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint), f = c - box2d.b2DotVV(box2d.b2SubVV(m, h, box2d.b2Vec2.s_t0), this.normal), f = box2d.b2AddVMulSV(m,
                            f, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA), g = box2d.b2SubVMulSV(m, d, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
                    box2d.b2MidVV(f, g, this.points[l])
                }
                break;
            case box2d.b2ManifoldType.e_faceB:
                box2d.b2MulRV(e.q, a.localNormal, this.normal);
                h = box2d.b2MulXV(e, a.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint);
                l = 0;
                for (k = a.pointCount; l < k; ++l)
                    m = box2d.b2MulXV(b, a.points[l].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint), f = d - box2d.b2DotVV(box2d.b2SubVV(m,
                            h, box2d.b2Vec2.s_t0), this.normal), g = box2d.b2AddVMulSV(m, f, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB), f = box2d.b2SubVMulSV(m, c, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA), box2d.b2MidVV(f, g, this.points[l]);
                this.normal.SelfNeg()
            }
};
goog.exportProperty(box2d.b2WorldManifold.prototype, "Initialize", box2d.b2WorldManifold.prototype.Initialize);
box2d.b2WorldManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_cA = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_cB = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2;
box2d.b2WorldManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2;
box2d.b2PointState = {b2_nullState: 0, b2_addState: 1, b2_persistState: 2, b2_removeState: 3};
goog.exportSymbol("box2d.b2PointState", box2d.b2PointState);
goog.exportProperty(box2d.b2PointState, "b2_nullState   ", box2d.b2PointState.b2_nullState);
goog.exportProperty(box2d.b2PointState, "b2_addState    ", box2d.b2PointState.b2_addState);
goog.exportProperty(box2d.b2PointState, "b2_persistState", box2d.b2PointState.b2_persistState);
goog.exportProperty(box2d.b2PointState, "b2_removeState ", box2d.b2PointState.b2_removeState);
box2d.b2GetPointStates = function(a, b, c, e) {
    for (var d = 0, f = c.pointCount; d < f; ++d) {
        var g = c.points[d].id, g = g.key;
        a[d] = box2d.b2PointState.b2_removeState;
        for (var h = 0, l = e.pointCount; h < l; ++h)
            if (e.points[h].id.key == g) {
                a[d] = box2d.b2PointState.b2_persistState;
                break
            }
    }
    for (f = box2d.b2_maxManifoldPoints; d < f; ++d)
        a[d] = box2d.b2PointState.b2_nullState;
    d = 0;
    for (f = e.pointCount; d < f; ++d)
        for (g = e.points[d].id, g = g.key, b[d] = box2d.b2PointState.b2_addState, h = 0, l = c.pointCount; h < l; ++h)
            if (c.points[h].id.key == g) {
                b[d] = box2d.b2PointState.b2_persistState;
                break
            }
    for (f = box2d.b2_maxManifoldPoints; d < f; ++d)
        b[d] = box2d.b2PointState.b2_nullState
};
goog.exportSymbol("box2d.b2GetPointStates", box2d.b2GetPointStates);
box2d.b2ClipVertex = function() {
    this.v = new box2d.b2Vec2;
    this.id = new box2d.b2ContactID
};
goog.exportSymbol("box2d.b2ClipVertex", box2d.b2ClipVertex);
box2d.b2ClipVertex.prototype.v = null;
goog.exportProperty(box2d.b2ClipVertex.prototype, "v", box2d.b2ClipVertex.prototype.v);
box2d.b2ClipVertex.prototype.id = null;
goog.exportProperty(box2d.b2ClipVertex.prototype, "id", box2d.b2ClipVertex.prototype.id);
box2d.b2ClipVertex.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2ClipVertex
    })
};
goog.exportProperty(box2d.b2ClipVertex, "MakeArray", box2d.b2ClipVertex.MakeArray);
box2d.b2ClipVertex.prototype.Copy = function(a) {
    this.v.Copy(a.v);
    this.id.Copy(a.id);
    return this
};
goog.exportProperty(box2d.b2ClipVertex.prototype, "Copy", box2d.b2ClipVertex.prototype.Copy);
box2d.b2RayCastInput = function() {
    this.p1 = new box2d.b2Vec2;
    this.p2 = new box2d.b2Vec2;
    this.maxFraction = 1
};
goog.exportSymbol("box2d.b2RayCastInput", box2d.b2RayCastInput);
box2d.b2RayCastInput.prototype.p1 = null;
goog.exportProperty(box2d.b2RayCastInput.prototype, "p1", box2d.b2RayCastInput.prototype.p1);
box2d.b2RayCastInput.prototype.p2 = null;
goog.exportProperty(box2d.b2RayCastInput.prototype, "p2", box2d.b2RayCastInput.prototype.p2);
box2d.b2RayCastInput.prototype.maxFraction = 1;
goog.exportProperty(box2d.b2RayCastInput.prototype, "maxFraction", box2d.b2RayCastInput.prototype.maxFraction);
box2d.b2RayCastInput.prototype.Copy = function(a) {
    this.p1.Copy(a.p1);
    this.p2.Copy(a.p2);
    this.maxFraction = a.maxFraction;
    return this
};
goog.exportProperty(box2d.b2RayCastInput.prototype, "Copy", box2d.b2RayCastInput.prototype.Copy);
box2d.b2RayCastOutput = function() {
    this.normal = new box2d.b2Vec2;
    this.fraction = 0
};
goog.exportSymbol("box2d.b2RayCastOutput", box2d.b2RayCastOutput);
box2d.b2RayCastOutput.prototype.normal = null;
goog.exportProperty(box2d.b2RayCastOutput.prototype, "normal", box2d.b2RayCastOutput.prototype.normal);
box2d.b2RayCastOutput.prototype.fraction = 0;
goog.exportProperty(box2d.b2RayCastOutput.prototype, "fraction", box2d.b2RayCastOutput.prototype.fraction);
box2d.b2RayCastOutput.prototype.Copy = function(a) {
    this.normal.Copy(a.normal);
    this.fraction = a.fraction;
    return this
};
goog.exportProperty(box2d.b2RayCastOutput.prototype, "Copy", box2d.b2RayCastOutput.prototype.Copy);
box2d.b2AABB = function() {
    this.lowerBound = new box2d.b2Vec2;
    this.upperBound = new box2d.b2Vec2;
    this.m_out_center = new box2d.b2Vec2;
    this.m_out_extent = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2AABB", box2d.b2AABB);
box2d.b2AABB.prototype.lowerBound = null;
goog.exportProperty(box2d.b2AABB.prototype, "lowerBound", box2d.b2AABB.prototype.lowerBound);
box2d.b2AABB.prototype.upperBound = null;
goog.exportProperty(box2d.b2AABB.prototype, "upperBound", box2d.b2AABB.prototype.upperBound);
box2d.b2AABB.prototype.m_out_center = null;
goog.exportProperty(box2d.b2AABB.prototype, "m_out_center", box2d.b2AABB.prototype.m_out_center);
box2d.b2AABB.prototype.m_out_extent = null;
goog.exportProperty(box2d.b2AABB.prototype, "m_out_extent", box2d.b2AABB.prototype.m_out_extent);
box2d.b2AABB.prototype.Copy = function(a) {
    this.lowerBound.Copy(a.lowerBound);
    this.upperBound.Copy(a.upperBound);
    return this
};
goog.exportProperty(box2d.b2AABB.prototype, "Copy", box2d.b2AABB.prototype.Copy);
box2d.b2AABB.prototype.IsValid = function() {
    var a = this.upperBound.y - this.lowerBound.y;
    return a = (a = 0 <= this.upperBound.x - this.lowerBound.x && 0 <= a) && this.lowerBound.IsValid() && this.upperBound.IsValid()
};
goog.exportProperty(box2d.b2AABB.prototype, "IsValid", box2d.b2AABB.prototype.IsValid);
box2d.b2AABB.prototype.GetCenter = function() {
    return box2d.b2MidVV(this.lowerBound, this.upperBound, this.m_out_center)
};
goog.exportProperty(box2d.b2AABB.prototype, "GetCenter", box2d.b2AABB.prototype.GetCenter);
box2d.b2AABB.prototype.GetExtents = function() {
    return box2d.b2ExtVV(this.lowerBound, this.upperBound, this.m_out_extent)
};
goog.exportProperty(box2d.b2AABB.prototype, "GetExtents", box2d.b2AABB.prototype.GetExtents);
box2d.b2AABB.prototype.GetPerimeter = function() {
    return 2 * (this.upperBound.x - this.lowerBound.x + (this.upperBound.y - this.lowerBound.y))
};
goog.exportProperty(box2d.b2AABB.prototype, "GetPerimeter", box2d.b2AABB.prototype.GetPerimeter);
box2d.b2AABB.prototype.Combine1 = function(a) {
    this.lowerBound.x = box2d.b2Min(this.lowerBound.x, a.lowerBound.x);
    this.lowerBound.y = box2d.b2Min(this.lowerBound.y, a.lowerBound.y);
    this.upperBound.x = box2d.b2Max(this.upperBound.x, a.upperBound.x);
    this.upperBound.y = box2d.b2Max(this.upperBound.y, a.upperBound.y);
    return this
};
goog.exportProperty(box2d.b2AABB.prototype, "Combine1", box2d.b2AABB.prototype.Combine1);
box2d.b2AABB.prototype.Combine2 = function(a, b) {
    this.lowerBound.x = box2d.b2Min(a.lowerBound.x, b.lowerBound.x);
    this.lowerBound.y = box2d.b2Min(a.lowerBound.y, b.lowerBound.y);
    this.upperBound.x = box2d.b2Max(a.upperBound.x, b.upperBound.x);
    this.upperBound.y = box2d.b2Max(a.upperBound.y, b.upperBound.y);
    return this
};
goog.exportProperty(box2d.b2AABB.prototype, "Combine2", box2d.b2AABB.prototype.Combine2);
box2d.b2AABB.Combine = function(a, b, c) {
    c.Combine2(a, b);
    return c
};
goog.exportProperty(box2d.b2AABB, "Combine", box2d.b2AABB.Combine);
box2d.b2AABB.prototype.Contains = function(a) {
    var b;
    return b = (b = (b = (b = this.lowerBound.x <= a.lowerBound.x) && this.lowerBound.y <= a.lowerBound.y) && a.upperBound.x <= this.upperBound.x) && a.upperBound.y <= this.upperBound.y
};
goog.exportProperty(box2d.b2AABB.prototype, "Contains", box2d.b2AABB.prototype.Contains);
box2d.b2AABB.prototype.RayCast = function(a, b) {
    var c = -box2d.b2_maxFloat, e = box2d.b2_maxFloat, d = b.p1.x, f = b.p1.y, g = b.p2.x - b.p1.x, h = b.p2.y - b.p1.y, l = box2d.b2Abs(g), k = box2d.b2Abs(h), m = a.normal;
    if (l < box2d.b2_epsilon) {
        if (d < this.lowerBound.x || this.upperBound.x < d)
            return!1
    } else if (l = 1 / g, g = (this.lowerBound.x - d) * l, d = (this.upperBound.x - d) * l, l = -1, g > d && (l = g, g = d, d = l, l = 1), g > c && (m.x = l, m.y = 0, c = g), e = box2d.b2Min(e, d), c > e)
        return!1;
    if (k < box2d.b2_epsilon) {
        if (f < this.lowerBound.y || this.upperBound.y < f)
            return!1
    } else if (l = 1 / h, g =
            (this.lowerBound.y - f) * l, d = (this.upperBound.y - f) * l, l = -1, g > d && (l = g, g = d, d = l, l = 1), g > c && (m.x = 0, m.y = l, c = g), e = box2d.b2Min(e, d), c > e)
        return!1;
    if (0 > c || b.maxFraction < c)
        return!1;
    a.fraction = c;
    return!0
};
goog.exportProperty(box2d.b2AABB.prototype, "RayCast", box2d.b2AABB.prototype.RayCast);
box2d.b2AABB.prototype.TestOverlap = function(a) {
    var b = a.lowerBound.y - this.upperBound.y, c = this.lowerBound.y - a.upperBound.y;
    return 0 < a.lowerBound.x - this.upperBound.x || 0 < b || 0 < this.lowerBound.x - a.upperBound.x || 0 < c ? !1 : !0
};
goog.exportProperty(box2d.b2AABB.prototype, "TestOverlap", box2d.b2AABB.prototype.TestOverlap);
box2d.b2TestOverlapAABB = function(a, b) {
    var c = b.lowerBound.y - a.upperBound.y, e = a.lowerBound.y - b.upperBound.y;
    return 0 < b.lowerBound.x - a.upperBound.x || 0 < c || 0 < a.lowerBound.x - b.upperBound.x || 0 < e ? !1 : !0
};
goog.exportSymbol("box2d.b2TestOverlapAABB", box2d.b2TestOverlapAABB);
box2d.b2ClipSegmentToLine = function(a, b, c, e, d) {
    var f = 0, g = b[0];
    b = b[1];
    var h = box2d.b2DotVV(c, g.v) - e;
    c = box2d.b2DotVV(c, b.v) - e;
    0 >= h && a[f++].Copy(g);
    0 >= c && a[f++].Copy(b);
    0 > h * c && (c = h / (h - c), e = a[f].v, e.x = g.v.x + c * (b.v.x - g.v.x), e.y = g.v.y + c * (b.v.y - g.v.y), a = a[f].id, a.cf.indexA = d, a.cf.indexB = g.id.cf.indexB, a.cf.typeA = box2d.b2ContactFeatureType.e_vertex, a.cf.typeB = box2d.b2ContactFeatureType.e_face, ++f);
    return f
};
goog.exportSymbol("box2d.b2ClipSegmentToLine", box2d.b2ClipSegmentToLine);
box2d.b2TestOverlapShape = function(a, b, c, e, d, f) {
    var g = box2d.b2TestOverlapShape.s_input.Reset();
    g.proxyA.SetShape(a, b);
    g.proxyB.SetShape(c, e);
    g.transformA.Copy(d);
    g.transformB.Copy(f);
    g.useRadii = !0;
    a = box2d.b2TestOverlapShape.s_simplexCache.Reset();
    a.count = 0;
    b = box2d.b2TestOverlapShape.s_output.Reset();
    box2d.b2Distance(b, a, g);
    return b.distance < 10 * box2d.b2_epsilon
};
goog.exportSymbol("box2d.b2TestOverlapShape", box2d.b2TestOverlapShape);
box2d.b2TestOverlapShape.s_input = new box2d.b2DistanceInput;
box2d.b2TestOverlapShape.s_simplexCache = new box2d.b2SimplexCache;
box2d.b2TestOverlapShape.s_output = new box2d.b2DistanceOutput;
box2d.b2Timer = function() {
    this.m_start = (new Date).getTime()
};
goog.exportSymbol("box2d.b2Timer", box2d.b2Timer);
box2d.b2Timer.prototype.m_start = 0;
goog.exportProperty(box2d.b2Timer.prototype, "m_start", box2d.b2Timer.prototype.m_start);
box2d.b2Timer.prototype.Reset = function() {
    this.m_start = (new Date).getTime();
    return this
};
goog.exportProperty(box2d.b2Timer.prototype, "Reset", box2d.b2Timer.prototype.Reset);
box2d.b2Timer.prototype.GetMilliseconds = function() {
    return(new Date).getTime() - this.m_start
};
goog.exportProperty(box2d.b2Timer.prototype, "GetMilliseconds", box2d.b2Timer.prototype.GetMilliseconds);
box2d.b2Counter = function() {
};
goog.exportSymbol("box2d.b2Counter", box2d.b2Counter);
box2d.b2Counter.prototype.m_count = 0;
goog.exportProperty(box2d.b2Counter.prototype, "m_count", box2d.b2Counter.prototype.m_count);
box2d.b2Counter.prototype.m_min_count = 0;
goog.exportProperty(box2d.b2Counter.prototype, "m_min_count", box2d.b2Counter.prototype.m_min_count);
box2d.b2Counter.prototype.m_max_count = 0;
goog.exportProperty(box2d.b2Counter.prototype, "m_max_count", box2d.b2Counter.prototype.m_max_count);
box2d.b2Counter.prototype.GetCount = function() {
    return this.m_count
};
goog.exportProperty(box2d.b2Counter.prototype, "GetCount", box2d.b2Counter.prototype.GetCount);
box2d.b2Counter.prototype.GetMinCount = function() {
    return this.m_min_count
};
goog.exportProperty(box2d.b2Counter.prototype, "GetMinCount", box2d.b2Counter.prototype.GetMinCount);
box2d.b2Counter.prototype.GetMaxCount = function() {
    return this.m_max_count
};
goog.exportProperty(box2d.b2Counter.prototype, "GetMaxCount", box2d.b2Counter.prototype.GetMaxCount);
box2d.b2Counter.prototype.ResetCount = function() {
    var a = this.m_count;
    this.m_count = 0;
    return a
};
goog.exportProperty(box2d.b2Counter.prototype, "ResetCount", box2d.b2Counter.prototype.ResetCount);
box2d.b2Counter.prototype.ResetMinCount = function() {
    this.m_min_count = 0
};
goog.exportProperty(box2d.b2Counter.prototype, "ResetMinCount", box2d.b2Counter.prototype.ResetMinCount);
box2d.b2Counter.prototype.ResetMaxCount = function() {
    this.m_max_count = 0
};
goog.exportProperty(box2d.b2Counter.prototype, "ResetMaxCount", box2d.b2Counter.prototype.ResetMaxCount);
box2d.b2Counter.prototype.Increment = function() {
    this.m_count++;
    this.m_max_count < this.m_count && (this.m_max_count = this.m_count)
};
goog.exportProperty(box2d.b2Counter.prototype, "Increment", box2d.b2Counter.prototype.Increment);
box2d.b2Counter.prototype.Decrement = function() {
    this.m_count--;
    this.m_min_count > this.m_count && (this.m_min_count = this.m_count)
};
goog.exportProperty(box2d.b2Counter.prototype, "Decrement", box2d.b2Counter.prototype.Decrement);
box2d.b2_toiTime = 0;
goog.exportSymbol("box2d.b2_toiTime", box2d.b2_toiTime);
box2d.b2_toiMaxTime = 0;
goog.exportSymbol("box2d.b2_toiMaxTime", box2d.b2_toiMaxTime);
box2d.b2_toiCalls = 0;
goog.exportSymbol("box2d.b2_toiCalls", box2d.b2_toiCalls);
box2d.b2_toiIters = 0;
goog.exportSymbol("box2d.b2_toiIters", box2d.b2_toiIters);
box2d.b2_toiMaxIters = 0;
goog.exportSymbol("box2d.b2_toiMaxIters", box2d.b2_toiMaxIters);
box2d.b2_toiRootIters = 0;
goog.exportSymbol("box2d.b2_toiRootIters", box2d.b2_toiRootIters);
box2d.b2_toiMaxRootIters = 0;
goog.exportSymbol("box2d.b2_toiMaxRootIters", box2d.b2_toiMaxRootIters);
box2d.b2TOIInput = function() {
    this.proxyA = new box2d.b2DistanceProxy;
    this.proxyB = new box2d.b2DistanceProxy;
    this.sweepA = new box2d.b2Sweep;
    this.sweepB = new box2d.b2Sweep
};
goog.exportSymbol("box2d.b2TOIInput", box2d.b2TOIInput);
box2d.b2TOIInput.prototype.proxyA = null;
goog.exportProperty(box2d.b2TOIInput.prototype, "proxyA", box2d.b2TOIInput.prototype.proxyA);
box2d.b2TOIInput.prototype.proxyB = null;
goog.exportProperty(box2d.b2TOIInput.prototype, "proxyB", box2d.b2TOIInput.prototype.proxyB);
box2d.b2TOIInput.prototype.sweepA = null;
goog.exportProperty(box2d.b2TOIInput.prototype, "sweepA", box2d.b2TOIInput.prototype.sweepA);
box2d.b2TOIInput.prototype.sweepB = null;
goog.exportProperty(box2d.b2TOIInput.prototype, "sweepB", box2d.b2TOIInput.prototype.sweepB);
box2d.b2TOIInput.prototype.tMax = 0;
goog.exportProperty(box2d.b2TOIInput.prototype, "tMax", box2d.b2TOIInput.prototype.tMax);
box2d.b2TOIOutputState = {e_unknown: 0, e_failed: 1, e_overlapped: 2, e_touching: 3, e_separated: 4};
goog.exportSymbol("box2d.b2TOIOutputState", box2d.b2TOIOutputState);
goog.exportProperty(box2d.b2TOIOutputState, "e_unknown", box2d.b2TOIOutputState.e_unknown);
goog.exportProperty(box2d.b2TOIOutputState, "e_failed", box2d.b2TOIOutputState.e_failed);
goog.exportProperty(box2d.b2TOIOutputState, "e_overlapped", box2d.b2TOIOutputState.e_overlapped);
goog.exportProperty(box2d.b2TOIOutputState, "e_touching", box2d.b2TOIOutputState.e_touching);
goog.exportProperty(box2d.b2TOIOutputState, "e_separated", box2d.b2TOIOutputState.e_separated);
box2d.b2TOIOutput = function() {
};
goog.exportSymbol("box2d.b2TOIOutput", box2d.b2TOIOutput);
box2d.b2TOIOutput.prototype.state = box2d.b2TOIOutputState.e_unknown;
goog.exportProperty(box2d.b2TOIOutput.prototype, "state", box2d.b2TOIOutput.prototype.state);
box2d.b2TOIOutput.prototype.t = 0;
goog.exportProperty(box2d.b2TOIOutput.prototype, "t", box2d.b2TOIOutput.prototype.t);
box2d.b2SeparationFunctionType = {e_unknown: -1, e_points: 0, e_faceA: 1, e_faceB: 2};
goog.exportSymbol("box2d.b2SeparationFunctionType", box2d.b2SeparationFunctionType);
goog.exportProperty(box2d.b2SeparationFunctionType, "e_unknown", box2d.b2SeparationFunctionType.e_unknown);
goog.exportProperty(box2d.b2SeparationFunctionType, "e_points", box2d.b2SeparationFunctionType.e_points);
goog.exportProperty(box2d.b2SeparationFunctionType, "e_faceA", box2d.b2SeparationFunctionType.e_faceA);
goog.exportProperty(box2d.b2SeparationFunctionType, "e_faceB", box2d.b2SeparationFunctionType.e_faceB);
box2d.b2SeparationFunction = function() {
    this.m_sweepA = new box2d.b2Sweep;
    this.m_sweepB = new box2d.b2Sweep;
    this.m_localPoint = new box2d.b2Vec2;
    this.m_axis = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2SeparationFunction", box2d.b2SeparationFunction);
box2d.b2SeparationFunction.prototype.m_proxyA = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_proxyA", box2d.b2SeparationFunction.prototype.m_proxyA);
box2d.b2SeparationFunction.prototype.m_proxyB = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_proxyB", box2d.b2SeparationFunction.prototype.m_proxyB);
box2d.b2SeparationFunction.prototype.m_sweepA = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_sweepA", box2d.b2SeparationFunction.prototype.m_sweepA);
box2d.b2SeparationFunction.prototype.m_sweepB = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_sweepB", box2d.b2SeparationFunction.prototype.m_sweepB);
box2d.b2SeparationFunction.prototype.m_type = box2d.b2SeparationFunctionType.e_unknown;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_type", box2d.b2SeparationFunction.prototype.m_type);
box2d.b2SeparationFunction.prototype.m_localPoint = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_localPoint", box2d.b2SeparationFunction.prototype.m_localPoint);
box2d.b2SeparationFunction.prototype.m_axis = null;
goog.exportProperty(box2d.b2SeparationFunction.prototype, "m_axis", box2d.b2SeparationFunction.prototype.m_axis);
box2d.b2SeparationFunction.prototype.Initialize = function(a, b, c, e, d, f) {
    this.m_proxyA = b;
    this.m_proxyB = e;
    b = a.count;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < b && 3 > b);
    this.m_sweepA.Copy(c);
    this.m_sweepB.Copy(d);
    c = box2d.b2TimeOfImpact.s_xfA;
    d = box2d.b2TimeOfImpact.s_xfB;
    this.m_sweepA.GetTransform(c, f);
    this.m_sweepB.GetTransform(d, f);
    1 == b ? (this.m_type = box2d.b2SeparationFunctionType.e_points, b = this.m_proxyA.GetVertex(a.indexA[0]), a = this.m_proxyB.GetVertex(a.indexB[0]), c = box2d.b2MulXV(c, b, box2d.b2TimeOfImpact.s_pointA),
            d = box2d.b2MulXV(d, a, box2d.b2TimeOfImpact.s_pointB), box2d.b2SubVV(d, c, this.m_axis), a = this.m_axis.Normalize()) : (a.indexA[0] == a.indexA[1] ? (this.m_type = box2d.b2SeparationFunctionType.e_faceB, b = this.m_proxyB.GetVertex(a.indexB[0]), e = this.m_proxyB.GetVertex(a.indexB[1]), box2d.b2CrossVOne(box2d.b2SubVV(e, b, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize(), f = box2d.b2MulRV(d.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), box2d.b2MidVV(b, e, this.m_localPoint), d = box2d.b2MulXV(d, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB),
            b = this.m_proxyA.GetVertex(a.indexA[0]), c = box2d.b2MulXV(c, b, box2d.b2TimeOfImpact.s_pointA), a = box2d.b2DotVV(box2d.b2SubVV(c, d, box2d.b2Vec2.s_t0), f)) : (this.m_type = box2d.b2SeparationFunctionType.e_faceA, b = this.m_proxyA.GetVertex(a.indexA[0]), e = this.m_proxyA.GetVertex(a.indexA[1]), box2d.b2CrossVOne(box2d.b2SubVV(e, b, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize(), f = box2d.b2MulRV(c.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), box2d.b2MidVV(b, e, this.m_localPoint), c = box2d.b2MulXV(c, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA),
            a = this.m_proxyB.GetVertex(a.indexB[0]), d = box2d.b2MulXV(d, a, box2d.b2TimeOfImpact.s_pointB), a = box2d.b2DotVV(box2d.b2SubVV(d, c, box2d.b2Vec2.s_t0), f)), 0 > a && (this.m_axis.SelfNeg(), a = -a));
    return a
};
goog.exportProperty(box2d.b2SeparationFunction.prototype, "Initialize", box2d.b2SeparationFunction.prototype.Initialize);
box2d.b2SeparationFunction.prototype.FindMinSeparation = function(a, b, c) {
    var e = box2d.b2TimeOfImpact.s_xfA, d = box2d.b2TimeOfImpact.s_xfB;
    this.m_sweepA.GetTransform(e, c);
    this.m_sweepB.GetTransform(d, c);
    switch (this.m_type) {
        case box2d.b2SeparationFunctionType.e_points:
            var f = box2d.b2MulTRV(e.q, this.m_axis, box2d.b2TimeOfImpact.s_axisA), g = box2d.b2MulTRV(d.q, box2d.b2NegV(this.m_axis, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB);
            a[0] = this.m_proxyA.GetSupport(f);
            b[0] = this.m_proxyB.GetSupport(g);
            a = this.m_proxyA.GetVertex(a[0]);
            b = this.m_proxyB.GetVertex(b[0]);
            e = box2d.b2MulXV(e, a, box2d.b2TimeOfImpact.s_pointA);
            d = box2d.b2MulXV(d, b, box2d.b2TimeOfImpact.s_pointB);
            return b = box2d.b2DotVV(box2d.b2SubVV(d, e, box2d.b2Vec2.s_t0), this.m_axis);
        case box2d.b2SeparationFunctionType.e_faceA:
            return c = box2d.b2MulRV(e.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), e = box2d.b2MulXV(e, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA), g = box2d.b2MulTRV(d.q, box2d.b2NegV(c, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB), a[0] = -1, b[0] = this.m_proxyB.GetSupport(g),
                    b = this.m_proxyB.GetVertex(b[0]), d = box2d.b2MulXV(d, b, box2d.b2TimeOfImpact.s_pointB), b = box2d.b2DotVV(box2d.b2SubVV(d, e, box2d.b2Vec2.s_t0), c);
        case box2d.b2SeparationFunctionType.e_faceB:
            return c = box2d.b2MulRV(d.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), d = box2d.b2MulXV(d, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB), f = box2d.b2MulTRV(e.q, box2d.b2NegV(c, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisA), b[0] = -1, a[0] = this.m_proxyA.GetSupport(f), a = this.m_proxyA.GetVertex(a[0]), e = box2d.b2MulXV(e, a, box2d.b2TimeOfImpact.s_pointA),
                    b = box2d.b2DotVV(box2d.b2SubVV(e, d, box2d.b2Vec2.s_t0), c);
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), a[0] = -1, b[0] = -1, 0
        }
};
goog.exportProperty(box2d.b2SeparationFunction.prototype, "FindMinSeparation", box2d.b2SeparationFunction.prototype.FindMinSeparation);
box2d.b2SeparationFunction.prototype.Evaluate = function(a, b, c) {
    var e = box2d.b2TimeOfImpact.s_xfA, d = box2d.b2TimeOfImpact.s_xfB;
    this.m_sweepA.GetTransform(e, c);
    this.m_sweepB.GetTransform(d, c);
    switch (this.m_type) {
        case box2d.b2SeparationFunctionType.e_points:
            return a = this.m_proxyA.GetVertex(a), b = this.m_proxyB.GetVertex(b), e = box2d.b2MulXV(e, a, box2d.b2TimeOfImpact.s_pointA), d = box2d.b2MulXV(d, b, box2d.b2TimeOfImpact.s_pointB), e = box2d.b2DotVV(box2d.b2SubVV(d, e, box2d.b2Vec2.s_t0), this.m_axis);
        case box2d.b2SeparationFunctionType.e_faceA:
            return c =
                    box2d.b2MulRV(e.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), e = box2d.b2MulXV(e, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA), b = this.m_proxyB.GetVertex(b), d = box2d.b2MulXV(d, b, box2d.b2TimeOfImpact.s_pointB), e = box2d.b2DotVV(box2d.b2SubVV(d, e, box2d.b2Vec2.s_t0), c);
        case box2d.b2SeparationFunctionType.e_faceB:
            return c = box2d.b2MulRV(d.q, this.m_axis, box2d.b2TimeOfImpact.s_normal), d = box2d.b2MulXV(d, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB), a = this.m_proxyA.GetVertex(a), e = box2d.b2MulXV(e, a, box2d.b2TimeOfImpact.s_pointA),
                    e = box2d.b2DotVV(box2d.b2SubVV(e, d, box2d.b2Vec2.s_t0), c);
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0
        }
};
goog.exportProperty(box2d.b2SeparationFunction.prototype, "Evaluate", box2d.b2SeparationFunction.prototype.Evaluate);
box2d.b2TimeOfImpact = function(a, b) {
    var c = box2d.b2TimeOfImpact.s_timer.Reset();
    ++box2d.b2_toiCalls;
    a.state = box2d.b2TOIOutputState.e_unknown;
    a.t = b.tMax;
    var e = b.proxyA, d = b.proxyB, f = box2d.b2TimeOfImpact.s_sweepA.Copy(b.sweepA), g = box2d.b2TimeOfImpact.s_sweepB.Copy(b.sweepB);
    f.Normalize();
    g.Normalize();
    var h = b.tMax, l = box2d.b2Max(box2d.b2_linearSlop, e.m_radius + d.m_radius - 3 * box2d.b2_linearSlop), k = 0.25 * box2d.b2_linearSlop;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(l > k);
    var m = 0, n = 0, p = box2d.b2TimeOfImpact.s_cache;
    p.count = 0;
    var q = box2d.b2TimeOfImpact.s_distanceInput;
    q.proxyA = b.proxyA;
    q.proxyB = b.proxyB;
    for (q.useRadii = !1; ; ) {
        var r = box2d.b2TimeOfImpact.s_xfA, t = box2d.b2TimeOfImpact.s_xfB;
        f.GetTransform(r, m);
        g.GetTransform(t, m);
        q.transformA.Copy(r);
        q.transformB.Copy(t);
        r = box2d.b2TimeOfImpact.s_distanceOutput;
        box2d.b2Distance(r, p, q);
        if (0 >= r.distance) {
            a.state = box2d.b2TOIOutputState.e_overlapped;
            a.t = 0;
            break
        }
        if (r.distance < l + k) {
            a.state = box2d.b2TOIOutputState.e_touching;
            a.t = m;
            break
        }
        r = box2d.b2TimeOfImpact.s_fcn;
        r.Initialize(p,
                e, f, d, g, m);
        for (var t = !1, s = h, u = 0; ; ) {
            var v = box2d.b2TimeOfImpact.s_indexA, y = box2d.b2TimeOfImpact.s_indexB, D = r.FindMinSeparation(v, y, s);
            if (D > l + k) {
                a.state = box2d.b2TOIOutputState.e_separated;
                a.t = h;
                t = !0;
                break
            }
            if (D > l - k) {
                m = s;
                break
            }
            var x = r.Evaluate(v[0], y[0], m);
            if (x < l - k) {
                a.state = box2d.b2TOIOutputState.e_failed;
                a.t = m;
                t = !0;
                break
            }
            if (x <= l + k) {
                a.state = box2d.b2TOIOutputState.e_touching;
                a.t = m;
                t = !0;
                break
            }
            for (var w = 0, C = m, A = s; ; ) {
                var E = 0, E = w & 1 ? C + (l - x) * (A - C) / (D - x) : 0.5 * (C + A);
                ++w;
                ++box2d.b2_toiRootIters;
                var B = r.Evaluate(v[0],
                        y[0], E);
                if (box2d.b2Abs(B - l) < k) {
                    s = E;
                    break
                }
                B > l ? (C = E, x = B) : (A = E, D = B);
                if (50 == w)
                    break
            }
            box2d.b2_toiMaxRootIters = box2d.b2Max(box2d.b2_toiMaxRootIters, w);
            ++u;
            if (u == box2d.b2_maxPolygonVertices)
                break
        }
        ++n;
        ++box2d.b2_toiIters;
        if (t)
            break;
        if (20 == n) {
            a.state = box2d.b2TOIOutputState.e_failed;
            a.t = m;
            break
        }
    }
    box2d.b2_toiMaxIters = box2d.b2Max(box2d.b2_toiMaxIters, n);
    c = c.GetMilliseconds();
    box2d.b2_toiMaxTime = box2d.b2Max(box2d.b2_toiMaxTime, c);
    box2d.b2_toiTime += c
};
goog.exportSymbol("box2d.b2TimeOfImpact", box2d.b2TimeOfImpact);
box2d.b2TimeOfImpact.s_timer = new box2d.b2Timer;
box2d.b2TimeOfImpact.s_cache = new box2d.b2SimplexCache;
box2d.b2TimeOfImpact.s_distanceInput = new box2d.b2DistanceInput;
box2d.b2TimeOfImpact.s_distanceOutput = new box2d.b2DistanceOutput;
box2d.b2TimeOfImpact.s_xfA = new box2d.b2Transform;
box2d.b2TimeOfImpact.s_xfB = new box2d.b2Transform;
box2d.b2TimeOfImpact.s_indexA = box2d.b2MakeNumberArray(1);
box2d.b2TimeOfImpact.s_indexB = box2d.b2MakeNumberArray(1);
box2d.b2TimeOfImpact.s_fcn = new box2d.b2SeparationFunction;
box2d.b2TimeOfImpact.s_sweepA = new box2d.b2Sweep;
box2d.b2TimeOfImpact.s_sweepB = new box2d.b2Sweep;
box2d.b2TimeOfImpact.s_pointA = new box2d.b2Vec2;
box2d.b2TimeOfImpact.s_pointB = new box2d.b2Vec2;
box2d.b2TimeOfImpact.s_normal = new box2d.b2Vec2;
box2d.b2TimeOfImpact.s_axisA = new box2d.b2Vec2;
box2d.b2TimeOfImpact.s_axisB = new box2d.b2Vec2;
box2d.b2MixFriction = function(a, b) {
    return box2d.b2Sqrt(a * b)
};
goog.exportSymbol("box2d.b2MixFriction", box2d.b2MixFriction);
box2d.b2MixRestitution = function(a, b) {
    return a > b ? a : b
};
goog.exportSymbol("box2d.b2MixRestitution", box2d.b2MixRestitution);
box2d.b2ContactEdge = function() {
};
goog.exportSymbol("box2d.b2ContactEdge", box2d.b2ContactEdge);
box2d.b2ContactEdge.prototype.other = null;
goog.exportProperty(box2d.b2ContactEdge.prototype, "other", box2d.b2ContactEdge.prototype.other);
box2d.b2ContactEdge.prototype.contact = null;
goog.exportProperty(box2d.b2ContactEdge.prototype, "contact", box2d.b2ContactEdge.prototype.contact);
box2d.b2ContactEdge.prototype.prev = null;
goog.exportProperty(box2d.b2ContactEdge.prototype, "prev", box2d.b2ContactEdge.prototype.prev);
box2d.b2ContactEdge.prototype.next = null;
goog.exportProperty(box2d.b2ContactEdge.prototype, "next", box2d.b2ContactEdge.prototype.next);
box2d.b2ContactFlag = {e_none: 0, e_islandFlag: 1, e_touchingFlag: 2, e_enabledFlag: 4, e_filterFlag: 8, e_bulletHitFlag: 16, e_toiFlag: 32};
goog.exportProperty(box2d.b2ContactFlag, "e_none", box2d.b2ContactFlag.e_none);
goog.exportProperty(box2d.b2ContactFlag, "e_islandFlag", box2d.b2ContactFlag.e_islandFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_touchingFlag", box2d.b2ContactFlag.e_touchingFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_enabledFlag", box2d.b2ContactFlag.e_enabledFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_filterFlag", box2d.b2ContactFlag.e_filterFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_bulletHitFlag", box2d.b2ContactFlag.e_bulletHitFlag);
goog.exportProperty(box2d.b2ContactFlag, "e_toiFlag", box2d.b2ContactFlag.e_toiFlag);
box2d.b2Contact = function() {
    this.m_nodeA = new box2d.b2ContactEdge;
    this.m_nodeB = new box2d.b2ContactEdge;
    this.m_manifold = new box2d.b2Manifold;
    this.m_oldManifold = new box2d.b2Manifold
};
goog.exportSymbol("box2d.b2Contact", box2d.b2Contact);
box2d.b2Contact.prototype.m_flags = box2d.b2ContactFlag.e_none;
goog.exportProperty(box2d.b2Contact.prototype, "m_flags", box2d.b2Contact.prototype.m_flags);
box2d.b2Contact.prototype.m_prev = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_prev", box2d.b2Contact.prototype.m_prev);
box2d.b2Contact.prototype.m_next = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_next", box2d.b2Contact.prototype.m_next);
box2d.b2Contact.prototype.m_nodeA = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_nodeA", box2d.b2Contact.prototype.m_nodeA);
box2d.b2Contact.prototype.m_nodeB = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_nodeB", box2d.b2Contact.prototype.m_nodeB);
box2d.b2Contact.prototype.m_fixtureA = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_fixtureA", box2d.b2Contact.prototype.m_fixtureA);
box2d.b2Contact.prototype.m_fixtureB = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_fixtureB", box2d.b2Contact.prototype.m_fixtureB);
box2d.b2Contact.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_indexA", box2d.b2Contact.prototype.m_indexA);
box2d.b2Contact.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_indexB", box2d.b2Contact.prototype.m_indexB);
box2d.b2Contact.prototype.m_manifold = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_manifold", box2d.b2Contact.prototype.m_manifold);
box2d.b2Contact.prototype.m_toiCount = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_toiCount", box2d.b2Contact.prototype.m_toiCount);
box2d.b2Contact.prototype.m_toi = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_toi", box2d.b2Contact.prototype.m_toi);
box2d.b2Contact.prototype.m_friction = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_friction", box2d.b2Contact.prototype.m_friction);
box2d.b2Contact.prototype.m_restitution = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_restitution", box2d.b2Contact.prototype.m_restitution);
box2d.b2Contact.prototype.m_tangentSpeed = 0;
goog.exportProperty(box2d.b2Contact.prototype, "m_tangentSpeed", box2d.b2Contact.prototype.m_tangentSpeed);
box2d.b2Contact.prototype.m_oldManifold = null;
goog.exportProperty(box2d.b2Contact.prototype, "m_oldManifold", box2d.b2Contact.prototype.m_oldManifold);
box2d.b2Contact.prototype.GetManifold = function() {
    return this.m_manifold
};
goog.exportProperty(box2d.b2Contact.prototype, "GetManifold", box2d.b2Contact.prototype.GetManifold);
box2d.b2Contact.prototype.GetWorldManifold = function(a) {
    var b = this.m_fixtureA.GetBody(), c = this.m_fixtureB.GetBody(), e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    a.Initialize(this.m_manifold, b.GetTransform(), e.m_radius, c.GetTransform(), d.m_radius)
};
goog.exportProperty(box2d.b2Contact.prototype, "GetWorldManifold", box2d.b2Contact.prototype.GetWorldManifold);
box2d.b2Contact.prototype.IsTouching = function() {
    return(this.m_flags & box2d.b2ContactFlag.e_touchingFlag) == box2d.b2ContactFlag.e_touchingFlag
};
goog.exportProperty(box2d.b2Contact.prototype, "IsTouching", box2d.b2Contact.prototype.IsTouching);
box2d.b2Contact.prototype.SetEnabled = function(a) {
    this.m_flags = a ? this.m_flags | box2d.b2ContactFlag.e_enabledFlag : this.m_flags & ~box2d.b2ContactFlag.e_enabledFlag
};
goog.exportProperty(box2d.b2Contact.prototype, "SetEnabled", box2d.b2Contact.prototype.SetEnabled);
box2d.b2Contact.prototype.IsEnabled = function() {
    return(this.m_flags & box2d.b2ContactFlag.e_enabledFlag) == box2d.b2ContactFlag.e_enabledFlag
};
goog.exportProperty(box2d.b2Contact.prototype, "IsEnabled", box2d.b2Contact.prototype.IsEnabled);
box2d.b2Contact.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Contact.prototype, "GetNext", box2d.b2Contact.prototype.GetNext);
box2d.b2Contact.prototype.GetFixtureA = function() {
    return this.m_fixtureA
};
goog.exportProperty(box2d.b2Contact.prototype, "GetFixtureA", box2d.b2Contact.prototype.GetFixtureA);
box2d.b2Contact.prototype.GetChildIndexA = function() {
    return this.m_indexA
};
goog.exportProperty(box2d.b2Contact.prototype, "GetChildIndexA", box2d.b2Contact.prototype.GetChildIndexA);
box2d.b2Contact.prototype.GetFixtureB = function() {
    return this.m_fixtureB
};
goog.exportProperty(box2d.b2Contact.prototype, "GetFixtureB", box2d.b2Contact.prototype.GetFixtureB);
box2d.b2Contact.prototype.GetChildIndexB = function() {
    return this.m_indexB
};
goog.exportProperty(box2d.b2Contact.prototype, "GetChildIndexB", box2d.b2Contact.prototype.GetChildIndexB);
box2d.b2Contact.prototype.Evaluate = function(a, b, c) {
};
goog.exportProperty(box2d.b2Contact.prototype, "Evaluate", box2d.b2Contact.prototype.Evaluate);
box2d.b2Contact.prototype.FlagForFiltering = function() {
    this.m_flags |= box2d.b2ContactFlag.e_filterFlag
};
goog.exportProperty(box2d.b2Contact.prototype, "FlagForFiltering", box2d.b2Contact.prototype.FlagForFiltering);
box2d.b2Contact.prototype.SetFriction = function(a) {
    this.m_friction = a
};
goog.exportProperty(box2d.b2Contact.prototype, "SetFriction", box2d.b2Contact.prototype.SetFriction);
box2d.b2Contact.prototype.GetFriction = function() {
    return this.m_friction
};
goog.exportProperty(box2d.b2Contact.prototype, "GetFriction", box2d.b2Contact.prototype.GetFriction);
box2d.b2Contact.prototype.ResetFriction = function() {
    this.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction)
};
goog.exportProperty(box2d.b2Contact.prototype, "ResetFriction", box2d.b2Contact.prototype.ResetFriction);
box2d.b2Contact.prototype.SetRestitution = function(a) {
    this.m_restitution = a
};
goog.exportProperty(box2d.b2Contact.prototype, "SetRestitution", box2d.b2Contact.prototype.SetRestitution);
box2d.b2Contact.prototype.GetRestitution = function() {
    return this.m_restitution
};
goog.exportProperty(box2d.b2Contact.prototype, "GetRestitution", box2d.b2Contact.prototype.GetRestitution);
box2d.b2Contact.prototype.ResetRestitution = function() {
    this.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution)
};
goog.exportProperty(box2d.b2Contact.prototype, "ResetRestitution", box2d.b2Contact.prototype.ResetRestitution);
box2d.b2Contact.prototype.SetTangentSpeed = function(a) {
    this.m_tangentSpeed = a
};
goog.exportProperty(box2d.b2Contact.prototype, "SetTangentSpeed", box2d.b2Contact.prototype.SetTangentSpeed);
box2d.b2Contact.prototype.GetTangentSpeed = function() {
    return this.m_tangentSpeed
};
goog.exportProperty(box2d.b2Contact.prototype, "GetTangentSpeed", box2d.b2Contact.prototype.GetTangentSpeed);
box2d.b2Contact.prototype.Reset = function(a, b, c, e) {
    this.m_flags = box2d.b2ContactFlag.e_enabledFlag;
    this.m_fixtureA = a;
    this.m_fixtureB = c;
    this.m_indexA = b;
    this.m_indexB = e;
    this.m_manifold.pointCount = 0;
    this.m_next = this.m_prev = null;
    this.m_nodeA.contact = null;
    this.m_nodeA.prev = null;
    this.m_nodeA.next = null;
    this.m_nodeA.other = null;
    this.m_nodeB.contact = null;
    this.m_nodeB.prev = null;
    this.m_nodeB.next = null;
    this.m_nodeB.other = null;
    this.m_toiCount = 0;
    this.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
    this.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution)
};
goog.exportProperty(box2d.b2Contact.prototype, "Reset", box2d.b2Contact.prototype.Reset);
box2d.b2Contact.prototype.Update = function(a) {
    var b = this.m_oldManifold;
    this.m_oldManifold = this.m_manifold;
    this.m_manifold = b;
    this.m_flags |= box2d.b2ContactFlag.e_enabledFlag;
    var c = !1, b = (this.m_flags & box2d.b2ContactFlag.e_touchingFlag) == box2d.b2ContactFlag.e_touchingFlag, e = this.m_fixtureA.IsSensor(), d = this.m_fixtureB.IsSensor(), e = e || d, d = this.m_fixtureA.GetBody(), f = this.m_fixtureB.GetBody(), c = d.GetTransform(), g = f.GetTransform();
    if (e)
        d = this.m_fixtureA.GetShape(), f = this.m_fixtureB.GetShape(), c = box2d.b2TestOverlapShape(d,
                this.m_indexA, f, this.m_indexB, c, g), this.m_manifold.pointCount = 0;
    else {
        this.Evaluate(this.m_manifold, c, g);
        c = 0 < this.m_manifold.pointCount;
        for (g = 0; g < this.m_manifold.pointCount; ++g) {
            var h = this.m_manifold.points[g];
            h.normalImpulse = 0;
            h.tangentImpulse = 0;
            for (var l = h.id, k = 0; k < this.m_oldManifold.pointCount; ++k) {
                var m = this.m_oldManifold.points[k];
                if (m.id.key == l.key) {
                    h.normalImpulse = m.normalImpulse;
                    h.tangentImpulse = m.tangentImpulse;
                    break
                }
            }
        }
        c != b && (d.SetAwake(!0), f.SetAwake(!0))
    }
    this.m_flags = c ? this.m_flags | box2d.b2ContactFlag.e_touchingFlag :
            this.m_flags & ~box2d.b2ContactFlag.e_touchingFlag;
    !1 == b && (!0 == c && a) && a.BeginContact(this);
    !0 == b && (!1 == c && a) && a.EndContact(this);
    !1 == e && (c && a) && a.PreSolve(this, this.m_oldManifold)
};
goog.exportProperty(box2d.b2Contact.prototype, "Update", box2d.b2Contact.prototype.Update);
box2d.b2Contact.prototype.ComputeTOI = function(a, b) {
    var c = box2d.b2Contact.prototype.ComputeTOI.s_input;
    c.proxyA.SetShape(this.m_fixtureA.GetShape(), this.m_indexA);
    c.proxyB.SetShape(this.m_fixtureB.GetShape(), this.m_indexB);
    c.sweepA.Copy(a);
    c.sweepB.Copy(b);
    c.tMax = box2d.b2_linearSlop;
    var e = box2d.b2Contact.prototype.ComputeTOI.s_output;
    box2d.b2TimeOfImpact(e, c);
    return e.t
};
goog.exportProperty(box2d.b2Contact.prototype, "ComputeTOI", box2d.b2Contact.prototype.ComputeTOI);
box2d.b2Contact.prototype.ComputeTOI.s_input = new box2d.b2TOIInput;
box2d.b2Contact.prototype.ComputeTOI.s_output = new box2d.b2TOIOutput;
box2d.b2PolygonAndCircleContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2PolygonAndCircleContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2PolygonAndCircleContact", box2d.b2PolygonAndCircleContact);
box2d.b2PolygonAndCircleContact.Create = function(a) {
    return new box2d.b2PolygonAndCircleContact
};
goog.exportProperty(box2d.b2PolygonAndCircleContact, "Create", box2d.b2PolygonAndCircleContact.Create);
box2d.b2PolygonAndCircleContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2PolygonAndCircleContact, "Destroy", box2d.b2PolygonAndCircleContact.Destroy);
box2d.b2PolygonAndCircleContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2PolygonAndCircleContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_polygonShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_circleShape)
};
goog.exportProperty(box2d.b2PolygonAndCircleContact.prototype, "Reset", box2d.b2PolygonAndCircleContact.prototype.Reset);
box2d.b2PolygonAndCircleContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2PolygonShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2CircleShape);
    box2d.b2CollidePolygonAndCircle(a, e instanceof box2d.b2PolygonShape ? e : null, b, d instanceof box2d.b2CircleShape ? d : null, c)
};
goog.exportProperty(box2d.b2PolygonAndCircleContact.prototype, "Evaluate", box2d.b2PolygonAndCircleContact.prototype.Evaluate);
box2d.b2EdgeAndPolygonContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2EdgeAndPolygonContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2EdgeAndPolygonContact", box2d.b2EdgeAndPolygonContact);
box2d.b2EdgeAndPolygonContact.Create = function(a) {
    return new box2d.b2EdgeAndPolygonContact
};
goog.exportProperty(box2d.b2EdgeAndPolygonContact, "Create", box2d.b2EdgeAndPolygonContact.Create);
box2d.b2EdgeAndPolygonContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2EdgeAndPolygonContact, "Destroy", box2d.b2EdgeAndPolygonContact.Destroy);
box2d.b2EdgeAndPolygonContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2EdgeAndPolygonContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_edgeShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_polygonShape)
};
goog.exportProperty(box2d.b2EdgeAndPolygonContact.prototype, "Reset", box2d.b2EdgeAndPolygonContact.prototype.Reset);
box2d.b2EdgeAndPolygonContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2EdgeShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2PolygonShape);
    box2d.b2CollideEdgeAndPolygon(a, e instanceof box2d.b2EdgeShape ? e : null, b, d instanceof box2d.b2PolygonShape ? d : null, c)
};
goog.exportProperty(box2d.b2EdgeAndPolygonContact.prototype, "Evaluate", box2d.b2EdgeAndPolygonContact.prototype.Evaluate);
box2d.b2MassData = function() {
    this.center = new box2d.b2Vec2(0, 0)
};
goog.exportSymbol("box2d.b2MassData", box2d.b2MassData);
box2d.b2MassData.prototype.mass = 0;
goog.exportProperty(box2d.b2MassData.prototype, "mass", box2d.b2MassData.prototype.mass);
box2d.b2MassData.prototype.center = null;
goog.exportProperty(box2d.b2MassData.prototype, "center", box2d.b2MassData.prototype.center);
box2d.b2MassData.prototype.I = 0;
goog.exportProperty(box2d.b2MassData.prototype, "I", box2d.b2MassData.prototype.I);
box2d.b2ShapeType = {e_unknown: -1, e_circleShape: 0, e_edgeShape: 1, e_polygonShape: 2, e_chainShape: 3, e_shapeTypeCount: 4};
goog.exportSymbol("box2d.b2ShapeType", box2d.b2ShapeType);
goog.exportProperty(box2d.b2ShapeType, "e_unknown", box2d.b2ShapeType.e_unknown);
goog.exportProperty(box2d.b2ShapeType, "e_circleShape", box2d.b2ShapeType.e_circleShape);
goog.exportProperty(box2d.b2ShapeType, "e_edgeShape", box2d.b2ShapeType.e_edgeShape);
goog.exportProperty(box2d.b2ShapeType, "e_polygonShape", box2d.b2ShapeType.e_polygonShape);
goog.exportProperty(box2d.b2ShapeType, "e_chainShape", box2d.b2ShapeType.e_chainShape);
goog.exportProperty(box2d.b2ShapeType, "e_shapeTypeCount", box2d.b2ShapeType.e_shapeTypeCount);
box2d.b2Shape = function(a, b) {
    this.m_type = a;
    this.m_radius = b
};
goog.exportSymbol("box2d.b2Shape", box2d.b2Shape);
box2d.b2Shape.prototype.m_type = box2d.b2ShapeType.e_unknown;
goog.exportProperty(box2d.b2Shape.prototype, "m_type", box2d.b2Shape.prototype.m_type);
box2d.b2Shape.prototype.m_radius = 0;
goog.exportProperty(box2d.b2Shape.prototype, "m_radius", box2d.b2Shape.prototype.m_radius);
box2d.b2Shape.prototype.Clone = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1);
    return null
};
goog.exportProperty(box2d.b2Shape.prototype, "Clone", box2d.b2Shape.prototype.Clone);
box2d.b2Shape.prototype.Copy = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_type == a.m_type);
    this.m_radius = a.m_radius;
    return this
};
goog.exportProperty(box2d.b2Shape.prototype, "Copy", box2d.b2Shape.prototype.Copy);
box2d.b2Shape.prototype.GetType = function() {
    return this.m_type
};
goog.exportProperty(box2d.b2Shape.prototype, "GetType", box2d.b2Shape.prototype.GetType);
box2d.b2Shape.prototype.GetChildCount = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual");
    return 0
};
goog.exportProperty(box2d.b2Shape.prototype, "GetChildCount", box2d.b2Shape.prototype.GetChildCount);
box2d.b2Shape.prototype.TestPoint = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual");
    return!1
};
goog.exportProperty(box2d.b2Shape.prototype, "TestPoint", box2d.b2Shape.prototype.TestPoint);
box2d.b2Shape.prototype.RayCast = function(a, b, c, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual");
    return!1
};
goog.exportProperty(box2d.b2Shape.prototype, "RayCast", box2d.b2Shape.prototype.RayCast);
box2d.b2Shape.prototype.ComputeAABB = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
};
goog.exportProperty(box2d.b2Shape.prototype, "ComputeAABB", box2d.b2Shape.prototype.ComputeAABB);
box2d.b2Shape.prototype.ComputeMass = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
};
goog.exportProperty(box2d.b2Shape.prototype, "ComputeMass", box2d.b2Shape.prototype.ComputeMass);
box2d.b2Shape.prototype.SetupDistanceProxy = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
};
box2d.b2Shape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual");
    return 0
};
goog.exportProperty(box2d.b2Shape.prototype, "ComputeSubmergedArea", box2d.b2Shape.prototype.ComputeSubmergedArea);
box2d.b2Shape.prototype.Dump = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual")
};
goog.exportProperty(box2d.b2Shape.prototype, "Dump", box2d.b2Shape.prototype.Dump);
box2d.b2PolygonShape = function() {
    box2d.b2Shape.call(this, box2d.b2ShapeType.e_polygonShape, box2d.b2_polygonRadius);
    this.m_centroid = new box2d.b2Vec2(0, 0);
    this.m_vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
    this.m_normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices)
};
goog.inherits(box2d.b2PolygonShape, box2d.b2Shape);
goog.exportSymbol("box2d.b2PolygonShape", box2d.b2PolygonShape);
box2d.b2PolygonShape.prototype.m_centroid = null;
goog.exportProperty(box2d.b2PolygonShape.prototype, "m_centroid", box2d.b2PolygonShape.prototype.m_centroid);
box2d.b2PolygonShape.prototype.m_vertices = null;
goog.exportProperty(box2d.b2PolygonShape.prototype, "m_vertices", box2d.b2PolygonShape.prototype.m_vertices);
box2d.b2PolygonShape.prototype.m_normals = null;
goog.exportProperty(box2d.b2PolygonShape.prototype, "m_normals", box2d.b2PolygonShape.prototype.m_normals);
box2d.b2PolygonShape.prototype.m_count = 0;
goog.exportProperty(box2d.b2PolygonShape.prototype, "m_count", box2d.b2PolygonShape.prototype.m_count);
box2d.b2PolygonShape.prototype.Clone = function() {
    return(new box2d.b2PolygonShape).Copy(this)
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Clone", box2d.b2PolygonShape.prototype.Clone);
box2d.b2PolygonShape.prototype.Copy = function(a) {
    box2d.b2PolygonShape.superClass_.Copy.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2PolygonShape);
    this.m_centroid.Copy(a.m_centroid);
    this.m_count = a.m_count;
    for (var b = 0, c = this.m_count; b < c; ++b)
        this.m_vertices[b].Copy(a.m_vertices[b]), this.m_normals[b].Copy(a.m_normals[b]);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Copy", box2d.b2PolygonShape.prototype.Copy);
box2d.b2PolygonShape.prototype.SetAsBox = function(a, b) {
    this.m_count = 4;
    this.m_vertices[0].SetXY(-a, -b);
    this.m_vertices[1].SetXY(a, -b);
    this.m_vertices[2].SetXY(a, b);
    this.m_vertices[3].SetXY(-a, b);
    this.m_normals[0].SetXY(0, -1);
    this.m_normals[1].SetXY(1, 0);
    this.m_normals[2].SetXY(0, 1);
    this.m_normals[3].SetXY(-1, 0);
    this.m_centroid.SetZero();
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "SetAsBox", box2d.b2PolygonShape.prototype.SetAsBox);
box2d.b2PolygonShape.prototype.SetAsOrientedBox = function(a, b, c, e) {
    this.m_count = 4;
    this.m_vertices[0].SetXY(-a, -b);
    this.m_vertices[1].SetXY(a, -b);
    this.m_vertices[2].SetXY(a, b);
    this.m_vertices[3].SetXY(-a, b);
    this.m_normals[0].SetXY(0, -1);
    this.m_normals[1].SetXY(1, 0);
    this.m_normals[2].SetXY(0, 1);
    this.m_normals[3].SetXY(-1, 0);
    this.m_centroid.Copy(c);
    a = new box2d.b2Transform;
    a.SetPosition(c);
    a.SetRotationAngleRadians(e);
    c = 0;
    for (e = this.m_count; c < e; ++c)
        box2d.b2MulXV(a, this.m_vertices[c], this.m_vertices[c]),
                box2d.b2MulRV(a.q, this.m_normals[c], this.m_normals[c]);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "SetAsOrientedBox", box2d.b2PolygonShape.prototype.SetAsOrientedBox);
box2d.b2PolygonShape.prototype.Set = function(a, b) {
    void 0 === b && (b = a.length);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= b && b <= box2d.b2_maxPolygonVertices);
    if (3 > b)
        return this.SetAsBox(1, 1);
    for (var c = box2d.b2Min(b, box2d.b2_maxPolygonVertices), e = box2d.b2PolygonShape.prototype.Set.s_ps, d = 0; d < c; ++d)
        e[d].Copy(a[d]);
    for (var f = 0, g = e[0].x, d = 1; d < b; ++d) {
        var h = e[d].x;
        if (h > g || h == g && e[d].y < e[f].y)
            f = d, g = h
    }
    h = box2d.b2PolygonShape.prototype.Set.s_hull;
    g = 0;
    for (d = f; ; ) {
        h[g] = d;
        for (var l = 0, k = 1; k < c; ++k)
            if (l == d)
                l = k;
            else {
                var m =
                        box2d.b2SubVV(e[l], e[h[g]], box2d.b2PolygonShape.prototype.Set.s_r), n = box2d.b2SubVV(e[k], e[h[g]], box2d.b2PolygonShape.prototype.Set.s_v), p = box2d.b2CrossVV(m, n);
                0 > p && (l = k);
                0 == p && n.GetLengthSquared() > m.GetLengthSquared() && (l = k)
            }
        ++g;
        d = l;
        if (l == f)
            break
    }
    this.m_count = g;
    for (d = 0; d < g; ++d)
        this.m_vertices[d].Copy(e[h[d]]);
    d = 0;
    for (c = g; d < c; ++d)
        e = box2d.b2SubVV(this.m_vertices[(d + 1) % c], this.m_vertices[d], box2d.b2Vec2.s_t0), box2d.ENABLE_ASSERTS && box2d.b2Assert(e.GetLengthSquared() > box2d.b2_epsilon_sq), box2d.b2CrossVOne(e,
                this.m_normals[d]).SelfNormalize();
    box2d.b2PolygonShape.ComputeCentroid(this.m_vertices, g, this.m_centroid);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Set", box2d.b2PolygonShape.prototype.Set);
box2d.b2PolygonShape.prototype.Set.s_ps = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
box2d.b2PolygonShape.prototype.Set.s_hull = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices);
box2d.b2PolygonShape.prototype.Set.s_r = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.Set.s_v = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.SetAsVector = function(a, b) {
    this.Set(a, b);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "SetAsVector", box2d.b2PolygonShape.prototype.SetAsVector);
box2d.b2PolygonShape.prototype.SetAsArray = function(a, b) {
    this.Set(a, b);
    return this
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "SetAsArray", box2d.b2PolygonShape.prototype.SetAsArray);
box2d.b2PolygonShape.prototype.GetChildCount = function() {
    return 1
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "GetChildCount", box2d.b2PolygonShape.prototype.GetChildCount);
box2d.b2PolygonShape.prototype.TestPoint = function(a, b) {
    for (var c = box2d.b2MulTXV(a, b, box2d.b2PolygonShape.prototype.TestPoint.s_pLocal), e = 0, d = this.m_count; e < d; ++e)
        if (0 < box2d.b2DotVV(this.m_normals[e], box2d.b2SubVV(c, this.m_vertices[e], box2d.b2Vec2.s_t0)))
            return!1;
    return!0
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "TestPoint", box2d.b2PolygonShape.prototype.TestPoint);
box2d.b2PolygonShape.prototype.TestPoint.s_pLocal = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.RayCast = function(a, b, c, e) {
    e = box2d.b2MulTXV(c, b.p1, box2d.b2PolygonShape.prototype.RayCast.s_p1);
    for (var d = box2d.b2MulTXV(c, b.p2, box2d.b2PolygonShape.prototype.RayCast.s_p2), d = box2d.b2SubVV(d, e, box2d.b2PolygonShape.prototype.RayCast.s_d), f = 0, g = b.maxFraction, h = -1, l = 0, k = this.m_count; l < k; ++l) {
        var m = box2d.b2DotVV(this.m_normals[l], box2d.b2SubVV(this.m_vertices[l], e, box2d.b2Vec2.s_t0)), n = box2d.b2DotVV(this.m_normals[l], d);
        if (0 == n) {
            if (0 > m)
                return!1
        } else
            0 > n && m < f * n ? (f = m / n, h = l) :
                    0 < n && m < g * n && (g = m / n);
        if (g < f)
            return!1
    }
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= f && f <= b.maxFraction);
    return 0 <= h ? (a.fraction = f, box2d.b2MulRV(c.q, this.m_normals[h], a.normal), !0) : !1
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "RayCast", box2d.b2PolygonShape.prototype.RayCast);
box2d.b2PolygonShape.prototype.RayCast.s_p1 = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.RayCast.s_p2 = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.RayCast.s_d = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeAABB = function(a, b, c) {
    c = box2d.b2MulXV(b, this.m_vertices[0], a.lowerBound);
    a = a.upperBound.Copy(c);
    for (var e = 0, d = this.m_count; e < d; ++e) {
        var f = box2d.b2MulXV(b, this.m_vertices[e], box2d.b2PolygonShape.prototype.ComputeAABB.s_v);
        box2d.b2MinV(f, c, c);
        box2d.b2MaxV(f, a, a)
    }
    b = this.m_radius;
    c.SelfSubXY(b, b);
    a.SelfAddXY(b, b)
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "ComputeAABB", box2d.b2PolygonShape.prototype.ComputeAABB);
box2d.b2PolygonShape.prototype.ComputeAABB.s_v = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeMass = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= this.m_count);
    for (var c = box2d.b2PolygonShape.prototype.ComputeMass.s_center.SetZero(), e = 0, d = 0, f = box2d.b2PolygonShape.prototype.ComputeMass.s_s.SetZero(), g = 0, h = this.m_count; g < h; ++g)
        f.SelfAdd(this.m_vertices[g]);
    f.SelfMul(1 / this.m_count);
    for (var l = 1 / 3, g = 0, h = this.m_count; g < h; ++g) {
        var k = box2d.b2SubVV(this.m_vertices[g], f, box2d.b2PolygonShape.prototype.ComputeMass.s_e1), m = box2d.b2SubVV(this.m_vertices[(g + 1) %
        h], f, box2d.b2PolygonShape.prototype.ComputeMass.s_e2), n = box2d.b2CrossVV(k, m), p = 0.5 * n, e = e + p;
        c.SelfAdd(box2d.b2MulSV(p * l, box2d.b2AddVV(k, m, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1));
        var p = k.x, k = k.y, q = m.x, m = m.y, d = d + 0.25 * l * n * (p * p + q * p + q * q + (k * k + m * k + m * m))
    }
    a.mass = b * e;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e > box2d.b2_epsilon);
    c.SelfMul(1 / e);
    box2d.b2AddVV(c, f, a.center);
    a.I = b * d;
    a.I += a.mass * (box2d.b2DotVV(a.center, a.center) - box2d.b2DotVV(c, c))
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "ComputeMass", box2d.b2PolygonShape.prototype.ComputeMass);
box2d.b2PolygonShape.prototype.ComputeMass.s_center = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeMass.s_s = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeMass.s_e1 = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeMass.s_e2 = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.Validate = function() {
    for (var a = 0; a < this.m_count; ++a)
        for (var b = a, c = (a + 1) % this.m_count, e = this.m_vertices[b], d = box2d.b2SubVV(this.m_vertices[c], e, box2d.b2PolygonShape.prototype.Validate.s_e), f = 0; f < this.m_count; ++f)
            if (f != b && f != c) {
                var g = box2d.b2SubVV(this.m_vertices[f], e, box2d.b2PolygonShape.prototype.Validate.s_v);
                if (0 > box2d.b2CrossVV(d, g))
                    return!1
            }
    return!0
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Validate", box2d.b2PolygonShape.prototype.Validate);
box2d.b2PolygonShape.prototype.Validate.s_e = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.Validate.s_v = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.SetupDistanceProxy = function(a, b) {
    a.m_vertices = this.m_vertices;
    a.m_count = this.m_count;
    a.m_radius = this.m_radius
};
box2d.b2PolygonShape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    var d = box2d.b2MulTRV(c.q, a, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL), f = b - box2d.b2DotVV(a, c.p), g = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths, h = 0, l = -1;
    b = -1;
    var k = !1;
    a = 0;
    for (var m = this.m_count; a < m; ++a) {
        g[a] = box2d.b2DotVV(d, this.m_vertices[a]) - f;
        var n = g[a] < -box2d.b2_epsilon;
        0 < a && (n ? k || (l = a - 1, h++) : k && (b = a - 1, h++));
        k = n
    }
    switch (h) {
        case 0:
            return k ? (a = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md,
                    this.ComputeMass(a, 1), box2d.b2MulXV(c, a.center, e), a.mass) : 0;
        case 1:
            -1 == l ? l = this.m_count - 1 : b = this.m_count - 1
    }
    a = (l + 1) % this.m_count;
    d = (b + 1) % this.m_count;
    f = (0 - g[l]) / (g[a] - g[l]);
    g = (0 - g[b]) / (g[d] - g[b]);
    l = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec.SetXY(this.m_vertices[l].x * (1 - f) + this.m_vertices[a].x * f, this.m_vertices[l].y * (1 - f) + this.m_vertices[a].y * f);
    b = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec.SetXY(this.m_vertices[b].x * (1 - g) + this.m_vertices[d].x * g, this.m_vertices[b].y *
            (1 - g) + this.m_vertices[d].y * g);
    g = 0;
    f = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center.SetZero();
    h = this.m_vertices[a];
    for (k = null; a != d; )
        a = (a + 1) % this.m_count, k = a == d ? b : this.m_vertices[a], m = 0.5 * ((h.x - l.x) * (k.y - l.y) - (h.y - l.y) * (k.x - l.x)), g += m, f.x += m * (l.x + h.x + k.x) / 3, f.y += m * (l.y + h.y + k.y) / 3, h = k;
    f.SelfMul(1 / g);
    box2d.b2MulXV(c, f, e);
    return g
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "ComputeSubmergedArea", box2d.b2PolygonShape.prototype.ComputeSubmergedArea);
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices);
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md = new box2d.b2MassData;
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center = new box2d.b2Vec2;
box2d.b2PolygonShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2PolygonShape*/ var shape = new box2d.b2PolygonShape();\n");
    box2d.b2Log("    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\n", box2d.b2_maxPolygonVertices);
    for (var a = 0; a < this.m_count; ++a)
        box2d.b2Log("    vs[%d].SetXY(%.15f, %.15f);\n", a, this.m_vertices[a].x, this.m_vertices[a].y);
    box2d.b2Log("    shape.Set(vs, %d);\n", this.m_count)
};
goog.exportProperty(box2d.b2PolygonShape.prototype, "Dump", box2d.b2PolygonShape.prototype.Dump);
box2d.b2PolygonShape.ComputeCentroid = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= b);
    c.SetZero();
    for (var e = 0, d = box2d.b2PolygonShape.ComputeCentroid.s_pRef.SetZero(), f = 1 / 3, g = 0; g < b; ++g) {
        var h = d, l = a[g], k = a[(g + 1) % b], m = box2d.b2SubVV(l, h, box2d.b2PolygonShape.ComputeCentroid.s_e1), n = box2d.b2SubVV(k, h, box2d.b2PolygonShape.ComputeCentroid.s_e2), m = 0.5 * box2d.b2CrossVV(m, n), e = e + m;
        c.x += m * f * (h.x + l.x + k.x);
        c.y += m * f * (h.y + l.y + k.y)
    }
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e > box2d.b2_epsilon);
    c.SelfMul(1 / e);
    return c
};
goog.exportProperty(box2d.b2PolygonShape, "ComputeCentroid", box2d.b2PolygonShape.ComputeCentroid);
box2d.b2PolygonShape.ComputeCentroid.s_pRef = new box2d.b2Vec2;
box2d.b2PolygonShape.ComputeCentroid.s_e1 = new box2d.b2Vec2;
box2d.b2PolygonShape.ComputeCentroid.s_e2 = new box2d.b2Vec2;
box2d.b2CollideEdge = {};
box2d.b2CollideEdgeAndCircle = function(a, b, c, e, d) {
    a.pointCount = 0;
    c = box2d.b2MulTXV(c, box2d.b2MulXV(d, e.m_p, box2d.b2Vec2.s_t0), box2d.b2CollideEdgeAndCircle.s_Q);
    var f = b.m_vertex1, g = b.m_vertex2, h = box2d.b2SubVV(g, f, box2d.b2CollideEdgeAndCircle.s_e), l = box2d.b2DotVV(h, box2d.b2SubVV(g, c, box2d.b2Vec2.s_t0)), k = box2d.b2DotVV(h, box2d.b2SubVV(c, f, box2d.b2Vec2.s_t0)), m = b.m_radius + e.m_radius;
    d = box2d.b2CollideEdgeAndCircle.s_id;
    d.cf.indexB = 0;
    d.cf.typeB = box2d.b2ContactFeatureType.e_vertex;
    if (0 >= k) {
        var n = f, l = box2d.b2SubVV(c,
                n, box2d.b2CollideEdgeAndCircle.s_d), l = box2d.b2DotVV(l, l);
        if (!(l > m * m)) {
            if (b.m_hasVertex0 && (b = box2d.b2SubVV(f, b.m_vertex0, box2d.b2CollideEdgeAndCircle.s_e1), 0 < box2d.b2DotVV(b, box2d.b2SubVV(f, c, box2d.b2Vec2.s_t0))))
                return;
            d.cf.indexA = 0;
            d.cf.typeA = box2d.b2ContactFeatureType.e_vertex;
            a.pointCount = 1;
            a.type = box2d.b2ManifoldType.e_circles;
            a.localNormal.SetZero();
            a.localPoint.Copy(n);
            a.points[0].id.Copy(d);
            a.points[0].localPoint.Copy(e.m_p)
        }
    } else if (0 >= l) {
        if (n = g, l = box2d.b2SubVV(c, n, box2d.b2CollideEdgeAndCircle.s_d),
                l = box2d.b2DotVV(l, l), !(l > m * m)) {
            if (b.m_hasVertex3 && (f = box2d.b2SubVV(b.m_vertex3, g, box2d.b2CollideEdgeAndCircle.s_e2), 0 < box2d.b2DotVV(f, box2d.b2SubVV(c, g, box2d.b2Vec2.s_t0))))
                return;
            d.cf.indexA = 1;
            d.cf.typeA = box2d.b2ContactFeatureType.e_vertex;
            a.pointCount = 1;
            a.type = box2d.b2ManifoldType.e_circles;
            a.localNormal.SetZero();
            a.localPoint.Copy(n);
            a.points[0].id.Copy(d);
            a.points[0].localPoint.Copy(e.m_p)
        }
    } else
        b = box2d.b2DotVV(h, h), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < b), n = box2d.b2CollideEdgeAndCircle.s_P,
                n.x = 1 / b * (l * f.x + k * g.x), n.y = 1 / b * (l * f.y + k * g.y), l = box2d.b2SubVV(c, n, box2d.b2CollideEdgeAndCircle.s_d), l = box2d.b2DotVV(l, l), l > m * m || (n = box2d.b2CollideEdgeAndCircle.s_n.SetXY(-h.y, h.x), 0 > box2d.b2DotVV(n, box2d.b2SubVV(c, f, box2d.b2Vec2.s_t0)) && n.SetXY(-n.x, -n.y), n.Normalize(), d.cf.indexA = 0, d.cf.typeA = box2d.b2ContactFeatureType.e_face, a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, a.localNormal.Copy(n), a.localPoint.Copy(f), a.points[0].id.Copy(d), a.points[0].localPoint.Copy(e.m_p))
};
goog.exportSymbol("box2d.b2CollideEdgeAndCircle", box2d.b2CollideEdgeAndCircle);
box2d.b2CollideEdgeAndCircle.s_Q = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_e = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_d = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_e1 = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_e2 = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_P = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_n = new box2d.b2Vec2;
box2d.b2CollideEdgeAndCircle.s_id = new box2d.b2ContactID;
box2d.b2EPAxisType = {e_unknown: 0, e_edgeA: 1, e_edgeB: 2};
goog.exportSymbol("box2d.b2EPAxisType", box2d.b2EPAxisType);
goog.exportProperty(box2d.b2EPAxisType, "e_unknown", box2d.b2EPAxisType.e_unknown);
goog.exportProperty(box2d.b2EPAxisType, "e_edgeA", box2d.b2EPAxisType.e_edgeA);
goog.exportProperty(box2d.b2EPAxisType, "e_edgeB", box2d.b2EPAxisType.e_edgeB);
box2d.b2EPAxis = function() {
};
goog.exportSymbol("box2d.b2EPAxis", box2d.b2EPAxis);
box2d.b2EPAxis.prototype.type = box2d.b2EPAxisType.e_unknown;
goog.exportProperty(box2d.b2EPAxis.prototype, "type", box2d.b2EPAxis.prototype.type);
box2d.b2EPAxis.prototype.index = 0;
goog.exportProperty(box2d.b2EPAxis.prototype, "index", box2d.b2EPAxis.prototype.index);
box2d.b2EPAxis.prototype.separation = 0;
goog.exportProperty(box2d.b2EPAxis.prototype, "separation", box2d.b2EPAxis.prototype.separation);
box2d.b2TempPolygon = function() {
    this.vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
    this.normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices);
    this.count = 0
};
goog.exportSymbol("box2d.b2TempPolygon", box2d.b2TempPolygon);
box2d.b2TempPolygon.prototype.vertices = null;
goog.exportProperty(box2d.b2TempPolygon.prototype, "vertices", box2d.b2TempPolygon.prototype.vertices);
box2d.b2TempPolygon.prototype.normals = null;
goog.exportProperty(box2d.b2TempPolygon.prototype, "normals", box2d.b2TempPolygon.prototype.normals);
box2d.b2TempPolygon.prototype.count = 0;
goog.exportProperty(box2d.b2TempPolygon.prototype, "count", box2d.b2TempPolygon.prototype.count);
box2d.b2ReferenceFace = function() {
    this.i2 = this.i1 = 0;
    this.v1 = new box2d.b2Vec2;
    this.v2 = new box2d.b2Vec2;
    this.normal = new box2d.b2Vec2;
    this.sideNormal1 = new box2d.b2Vec2;
    this.sideOffset1 = 0;
    this.sideNormal2 = new box2d.b2Vec2;
    this.sideOffset2 = 0
};
goog.exportSymbol("box2d.b2ReferenceFace", box2d.b2ReferenceFace);
box2d.b2ReferenceFace.prototype.i1 = 0;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "i1", box2d.b2ReferenceFace.prototype.i1);
box2d.b2ReferenceFace.prototype.i2 = 0;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "i2", box2d.b2ReferenceFace.prototype.i2);
box2d.b2ReferenceFace.prototype.v1 = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "v1", box2d.b2ReferenceFace.prototype.v1);
box2d.b2ReferenceFace.prototype.v2 = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "v2", box2d.b2ReferenceFace.prototype.v2);
box2d.b2ReferenceFace.prototype.normal = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "normal", box2d.b2ReferenceFace.prototype.normal);
box2d.b2ReferenceFace.prototype.sideNormal1 = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "sideNormal1", box2d.b2ReferenceFace.prototype.sideNormal1);
box2d.b2ReferenceFace.prototype.sideOffset1 = 0;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "sideOffset1", box2d.b2ReferenceFace.prototype.sideOffset1);
box2d.b2ReferenceFace.prototype.sideNormal2 = null;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "sideNormal2", box2d.b2ReferenceFace.prototype.sideNormal2);
box2d.b2ReferenceFace.prototype.sideOffset2 = 0;
goog.exportProperty(box2d.b2ReferenceFace.prototype, "sideOffset2", box2d.b2ReferenceFace.prototype.sideOffset2);
box2d.b2EPColliderVertexType = {e_isolated: 0, e_concave: 1, e_convex: 2};
goog.exportSymbol("box2d.b2EPColliderVertexType", box2d.b2EPColliderVertexType);
goog.exportProperty(box2d.b2EPColliderVertexType, "e_isolated", box2d.b2EPColliderVertexType.e_isolated);
goog.exportProperty(box2d.b2EPColliderVertexType, "e_concave", box2d.b2EPColliderVertexType.e_concave);
goog.exportProperty(box2d.b2EPColliderVertexType, "e_convex", box2d.b2EPColliderVertexType.e_convex);
box2d.b2EPCollider = function() {
    this.m_polygonB = new box2d.b2TempPolygon;
    this.m_xf = new box2d.b2Transform;
    this.m_centroidB = new box2d.b2Vec2;
    this.m_v0 = new box2d.b2Vec2;
    this.m_v1 = new box2d.b2Vec2;
    this.m_v2 = new box2d.b2Vec2;
    this.m_v3 = new box2d.b2Vec2;
    this.m_normal0 = new box2d.b2Vec2;
    this.m_normal1 = new box2d.b2Vec2;
    this.m_normal2 = new box2d.b2Vec2;
    this.m_normal = new box2d.b2Vec2;
    this.m_type2 = this.m_type1 = box2d.b2EPColliderVertexType.e_isolated;
    this.m_lowerLimit = new box2d.b2Vec2;
    this.m_upperLimit = new box2d.b2Vec2;
    this.m_radius = 0;
    this.m_front = !1
};
goog.exportSymbol("box2d.b2EPCollider", box2d.b2EPCollider);
box2d.b2EPCollider.prototype.m_polygonB = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_polygonB", box2d.b2EPCollider.prototype.m_polygonB);
box2d.b2EPCollider.prototype.m_xf = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_xf", box2d.b2EPCollider.prototype.m_xf);
box2d.b2EPCollider.prototype.m_centroidB = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_centroidB", box2d.b2EPCollider.prototype.m_centroidB);
box2d.b2EPCollider.prototype.m_v0 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_v0", box2d.b2EPCollider.prototype.m_v0);
box2d.b2EPCollider.prototype.m_v1 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_v1", box2d.b2EPCollider.prototype.m_v1);
box2d.b2EPCollider.prototype.m_v2 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_v2", box2d.b2EPCollider.prototype.m_v2);
box2d.b2EPCollider.prototype.m_v3 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_v3", box2d.b2EPCollider.prototype.m_v3);
box2d.b2EPCollider.prototype.m_normal0 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_normal0", box2d.b2EPCollider.prototype.m_normal0);
box2d.b2EPCollider.prototype.m_normal1 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_normal1", box2d.b2EPCollider.prototype.m_normal1);
box2d.b2EPCollider.prototype.m_normal2 = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_normal2", box2d.b2EPCollider.prototype.m_normal2);
box2d.b2EPCollider.prototype.m_normal = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_normal", box2d.b2EPCollider.prototype.m_normal);
box2d.b2EPCollider.prototype.m_type1 = box2d.b2EPColliderVertexType.e_isolated;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_type1", box2d.b2EPCollider.prototype.m_type1);
box2d.b2EPCollider.prototype.m_type2 = box2d.b2EPColliderVertexType.e_isolated;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_type2", box2d.b2EPCollider.prototype.m_type2);
box2d.b2EPCollider.prototype.m_lowerLimit = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_lowerLimit", box2d.b2EPCollider.prototype.m_lowerLimit);
box2d.b2EPCollider.prototype.m_upperLimit = null;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_upperLimit", box2d.b2EPCollider.prototype.m_upperLimit);
box2d.b2EPCollider.prototype.m_radius = 0;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_radius", box2d.b2EPCollider.prototype.m_radius);
box2d.b2EPCollider.prototype.m_front = !1;
goog.exportProperty(box2d.b2EPCollider.prototype, "m_front", box2d.b2EPCollider.prototype.m_front);
box2d.b2EPCollider.prototype.Collide = function(a, b, c, e, d) {
    box2d.b2MulTXX(c, d, this.m_xf);
    box2d.b2MulXV(this.m_xf, e.m_centroid, this.m_centroidB);
    this.m_v0.Copy(b.m_vertex0);
    this.m_v1.Copy(b.m_vertex1);
    this.m_v2.Copy(b.m_vertex2);
    this.m_v3.Copy(b.m_vertex3);
    c = b.m_hasVertex0;
    b = b.m_hasVertex3;
    d = box2d.b2SubVV(this.m_v2, this.m_v1, box2d.b2EPCollider.s_edge1);
    d.Normalize();
    this.m_normal1.SetXY(d.y, -d.x);
    var f = box2d.b2DotVV(this.m_normal1, box2d.b2SubVV(this.m_centroidB, this.m_v1, box2d.b2Vec2.s_t0)), g = 0, h = 0,
            l = !1, k = !1;
    c && (g = box2d.b2SubVV(this.m_v1, this.m_v0, box2d.b2EPCollider.s_edge0), g.Normalize(), this.m_normal0.SetXY(g.y, -g.x), l = 0 <= box2d.b2CrossVV(g, d), g = box2d.b2DotVV(this.m_normal0, box2d.b2SubVV(this.m_centroidB, this.m_v0, box2d.b2Vec2.s_t0)));
    b && (h = box2d.b2SubVV(this.m_v3, this.m_v2, box2d.b2EPCollider.s_edge2), h.Normalize(), this.m_normal2.SetXY(h.y, -h.x), k = 0 < box2d.b2CrossVV(d, h), h = box2d.b2DotVV(this.m_normal2, box2d.b2SubVV(this.m_centroidB, this.m_v2, box2d.b2Vec2.s_t0)));
    c && b ? l && k ? (this.m_front = 0 <= g ||
            0 <= f || 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : l ? (this.m_front = 0 <= g || 0 <= f && 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal2).SelfNeg(),
            this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : k ? (this.m_front = 0 <= h || 0 <= g && 0 <= f) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal0).SelfNeg()) : (this.m_front = 0 <= g && 0 <= f && 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(),
            this.m_lowerLimit.Copy(this.m_normal2).SelfNeg(), this.m_upperLimit.Copy(this.m_normal0).SelfNeg()) : c ? l ? ((this.m_front = 0 <= g || 0 <= f) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1)), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_front = 0 <= g && 0 <= f) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(),
            this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal0).SelfNeg()) : b ? k ? (this.m_front = 0 <= f || 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1)) : ((this.m_front = 0 <= f && 0 <= h) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(),
            this.m_lowerLimit.Copy(this.m_normal2).SelfNeg()), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_front = 0 <= f) ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1));
    this.m_polygonB.count = e.m_count;
    f = 0;
    for (g = e.m_count; f < g; ++f)
        box2d.b2MulXV(this.m_xf, e.m_vertices[f], this.m_polygonB.vertices[f]), box2d.b2MulRV(this.m_xf.q,
                e.m_normals[f], this.m_polygonB.normals[f]);
    this.m_radius = 2 * box2d.b2_polygonRadius;
    a.pointCount = 0;
    c = this.ComputeEdgeSeparation(box2d.b2EPCollider.s_edgeAxis);
    if (!(c.type == box2d.b2EPAxisType.e_unknown || c.separation > this.m_radius || (b = this.ComputePolygonSeparation(box2d.b2EPCollider.s_polygonAxis), b.type != box2d.b2EPAxisType.e_unknown && b.separation > this.m_radius))) {
        c = b.type == box2d.b2EPAxisType.e_unknown ? c : b.separation > 0.98 * c.separation + 0.001 ? b : c;
        d = box2d.b2EPCollider.s_ie;
        b = box2d.b2EPCollider.s_rf;
        if (c.type ==
                box2d.b2EPAxisType.e_edgeA) {
            a.type = box2d.b2ManifoldType.e_faceA;
            h = 0;
            l = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[0]);
            f = 1;
            for (g = this.m_polygonB.count; f < g; ++f)
                k = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[f]), k < l && (l = k, h = f);
            g = h;
            f = (g + 1) % this.m_polygonB.count;
            h = d[0];
            h.v.Copy(this.m_polygonB.vertices[g]);
            h.id.cf.indexA = 0;
            h.id.cf.indexB = g;
            h.id.cf.typeA = box2d.b2ContactFeatureType.e_face;
            h.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex;
            g = d[1];
            g.v.Copy(this.m_polygonB.vertices[f]);
            g.id.cf.indexA =
                    0;
            g.id.cf.indexB = f;
            g.id.cf.typeA = box2d.b2ContactFeatureType.e_face;
            g.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex;
            this.m_front ? (b.i1 = 0, b.i2 = 1, b.v1.Copy(this.m_v1), b.v2.Copy(this.m_v2), b.normal.Copy(this.m_normal1)) : (b.i1 = 1, b.i2 = 0, b.v1.Copy(this.m_v2), b.v2.Copy(this.m_v1), b.normal.Copy(this.m_normal1).SelfNeg())
        } else
            a.type = box2d.b2ManifoldType.e_faceB, h = d[0], h.v.Copy(this.m_v1), h.id.cf.indexA = 0, h.id.cf.indexB = c.index, h.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex, h.id.cf.typeB = box2d.b2ContactFeatureType.e_face,
                    g = d[1], g.v.Copy(this.m_v2), g.id.cf.indexA = 0, g.id.cf.indexB = c.index, g.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex, g.id.cf.typeB = box2d.b2ContactFeatureType.e_face, b.i1 = c.index, b.i2 = (b.i1 + 1) % this.m_polygonB.count, b.v1.Copy(this.m_polygonB.vertices[b.i1]), b.v2.Copy(this.m_polygonB.vertices[b.i2]), b.normal.Copy(this.m_polygonB.normals[b.i1]);
        b.sideNormal1.SetXY(b.normal.y, -b.normal.x);
        b.sideNormal2.Copy(b.sideNormal1).SelfNeg();
        b.sideOffset1 = box2d.b2DotVV(b.sideNormal1, b.v1);
        b.sideOffset2 = box2d.b2DotVV(b.sideNormal2,
                b.v2);
        f = box2d.b2EPCollider.s_clipPoints1;
        h = box2d.b2EPCollider.s_clipPoints2;
        g = 0;
        g = box2d.b2ClipSegmentToLine(f, d, b.sideNormal1, b.sideOffset1, b.i1);
        if (!(g < box2d.b2_maxManifoldPoints || (g = box2d.b2ClipSegmentToLine(h, f, b.sideNormal2, b.sideOffset2, b.i2), g < box2d.b2_maxManifoldPoints))) {
            c.type == box2d.b2EPAxisType.e_edgeA ? (a.localNormal.Copy(b.normal), a.localPoint.Copy(b.v1)) : (a.localNormal.Copy(e.m_normals[b.i1]), a.localPoint.Copy(e.m_vertices[b.i1]));
            f = e = 0;
            for (g = box2d.b2_maxManifoldPoints; f < g; ++f)
                box2d.b2DotVV(b.normal,
                        box2d.b2SubVV(h[f].v, b.v1, box2d.b2Vec2.s_t0)) <= this.m_radius && (d = a.points[e], c.type == box2d.b2EPAxisType.e_edgeA ? (box2d.b2MulTXV(this.m_xf, h[f].v, d.localPoint), d.id = h[f].id) : (d.localPoint.Copy(h[f].v), d.id.cf.typeA = h[f].id.cf.typeB, d.id.cf.typeB = h[f].id.cf.typeA, d.id.cf.indexA = h[f].id.cf.indexB, d.id.cf.indexB = h[f].id.cf.indexA), ++e);
            a.pointCount = e
        }
    }
};
goog.exportProperty(box2d.b2EPCollider.prototype, "Collide", box2d.b2EPCollider.prototype.Collide);
box2d.b2EPCollider.s_edge1 = new box2d.b2Vec2;
box2d.b2EPCollider.s_edge0 = new box2d.b2Vec2;
box2d.b2EPCollider.s_edge2 = new box2d.b2Vec2;
box2d.b2EPCollider.s_ie = box2d.b2ClipVertex.MakeArray(2);
box2d.b2EPCollider.s_rf = new box2d.b2ReferenceFace;
box2d.b2EPCollider.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2EPCollider.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2EPCollider.s_edgeAxis = new box2d.b2EPAxis;
box2d.b2EPCollider.s_polygonAxis = new box2d.b2EPAxis;
box2d.b2EPCollider.prototype.ComputeEdgeSeparation = function(a) {
    a.type = box2d.b2EPAxisType.e_edgeA;
    a.index = this.m_front ? 0 : 1;
    a.separation = box2d.b2_maxFloat;
    for (var b = 0, c = this.m_polygonB.count; b < c; ++b) {
        var e = box2d.b2DotVV(this.m_normal, box2d.b2SubVV(this.m_polygonB.vertices[b], this.m_v1, box2d.b2Vec2.s_t0));
        e < a.separation && (a.separation = e)
    }
    return a
};
goog.exportProperty(box2d.b2EPCollider.prototype, "ComputeEdgeSeparation", box2d.b2EPCollider.prototype.ComputeEdgeSeparation);
box2d.b2EPCollider.prototype.ComputePolygonSeparation = function(a) {
    a.type = box2d.b2EPAxisType.e_unknown;
    a.index = -1;
    a.separation = -box2d.b2_maxFloat;
    for (var b = box2d.b2EPCollider.s_perp.SetXY(-this.m_normal.y, this.m_normal.x), c = 0, e = this.m_polygonB.count; c < e; ++c) {
        var d = box2d.b2NegV(this.m_polygonB.normals[c], box2d.b2EPCollider.s_n), f = box2d.b2DotVV(d, box2d.b2SubVV(this.m_polygonB.vertices[c], this.m_v1, box2d.b2Vec2.s_t0)), g = box2d.b2DotVV(d, box2d.b2SubVV(this.m_polygonB.vertices[c], this.m_v2, box2d.b2Vec2.s_t0)),
                f = box2d.b2Min(f, g);
        if (f > this.m_radius) {
            a.type = box2d.b2EPAxisType.e_edgeB;
            a.index = c;
            a.separation = f;
            break
        }
        if (0 <= box2d.b2DotVV(d, b)) {
            if (box2d.b2DotVV(box2d.b2SubVV(d, this.m_upperLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop)
                continue
        } else if (box2d.b2DotVV(box2d.b2SubVV(d, this.m_lowerLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop)
            continue;
        f > a.separation && (a.type = box2d.b2EPAxisType.e_edgeB, a.index = c, a.separation = f)
    }
    return a
};
goog.exportProperty(box2d.b2EPCollider.prototype, "ComputePolygonSeparation", box2d.b2EPCollider.prototype.ComputePolygonSeparation);
box2d.b2EPCollider.s_n = new box2d.b2Vec2;
box2d.b2EPCollider.s_perp = new box2d.b2Vec2;
box2d.b2CollideEdgeAndPolygon = function(a, b, c, e, d) {
    box2d.b2CollideEdgeAndPolygon.s_collider.Collide(a, b, c, e, d)
};
goog.exportSymbol("box2d.b2CollideEdgeAndPolygon", box2d.b2CollideEdgeAndPolygon);
box2d.b2CollideEdgeAndPolygon.s_collider = new box2d.b2EPCollider;
box2d.b2EdgeShape = function() {
    box2d.b2Shape.call(this, box2d.b2ShapeType.e_edgeShape, box2d.b2_polygonRadius);
    this.m_vertex1 = new box2d.b2Vec2;
    this.m_vertex2 = new box2d.b2Vec2;
    this.m_vertex0 = new box2d.b2Vec2;
    this.m_vertex3 = new box2d.b2Vec2
};
goog.inherits(box2d.b2EdgeShape, box2d.b2Shape);
goog.exportSymbol("box2d.b2EdgeShape", box2d.b2EdgeShape);
box2d.b2EdgeShape.prototype.m_vertex1 = null;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_vertex1", box2d.b2EdgeShape.prototype.m_vertex1);
box2d.b2EdgeShape.prototype.m_vertex2 = null;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_vertex2", box2d.b2EdgeShape.prototype.m_vertex2);
box2d.b2EdgeShape.prototype.m_vertex0 = null;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_vertex0", box2d.b2EdgeShape.prototype.m_vertex0);
box2d.b2EdgeShape.prototype.m_vertex3 = null;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_vertex3", box2d.b2EdgeShape.prototype.m_vertex3);
box2d.b2EdgeShape.prototype.m_hasVertex0 = !1;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_hasVertex0", box2d.b2EdgeShape.prototype.m_hasVertex0);
box2d.b2EdgeShape.prototype.m_hasVertex3 = !1;
goog.exportProperty(box2d.b2EdgeShape.prototype, "m_hasVertex3", box2d.b2EdgeShape.prototype.m_hasVertex3);
box2d.b2EdgeShape.prototype.Set = function(a, b) {
    this.m_vertex1.Copy(a);
    this.m_vertex2.Copy(b);
    this.m_hasVertex3 = this.m_hasVertex0 = !1;
    return this
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "Set", box2d.b2EdgeShape.prototype.Set);
box2d.b2EdgeShape.prototype.SetAsEdge = box2d.b2EdgeShape.prototype.Set;
box2d.b2EdgeShape.prototype.Clone = function() {
    return(new box2d.b2EdgeShape).Copy(this)
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "Clone", box2d.b2EdgeShape.prototype.Clone);
box2d.b2EdgeShape.prototype.Copy = function(a) {
    box2d.b2EdgeShape.superClass_.Copy.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2EdgeShape);
    this.m_vertex1.Copy(a.m_vertex1);
    this.m_vertex2.Copy(a.m_vertex2);
    this.m_vertex0.Copy(a.m_vertex0);
    this.m_vertex3.Copy(a.m_vertex3);
    this.m_hasVertex0 = a.m_hasVertex0;
    this.m_hasVertex3 = a.m_hasVertex3;
    return this
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "Copy", box2d.b2EdgeShape.prototype.Copy);
box2d.b2EdgeShape.prototype.GetChildCount = function() {
    return 1
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "GetChildCount", box2d.b2EdgeShape.prototype.GetChildCount);
box2d.b2EdgeShape.prototype.TestPoint = function(a, b) {
    return!1
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "TestPoint", box2d.b2EdgeShape.prototype.TestPoint);
box2d.b2EdgeShape.prototype.RayCast = function(a, b, c, e) {
    var d = box2d.b2MulTXV(c, b.p1, box2d.b2EdgeShape.prototype.RayCast.s_p1);
    e = box2d.b2MulTXV(c, b.p2, box2d.b2EdgeShape.prototype.RayCast.s_p2);
    var f = box2d.b2SubVV(e, d, box2d.b2EdgeShape.prototype.RayCast.s_d);
    e = this.m_vertex1;
    var g = this.m_vertex2, h = box2d.b2SubVV(g, e, box2d.b2EdgeShape.prototype.RayCast.s_e), l = a.normal.SetXY(h.y, -h.x).SelfNormalize(), h = box2d.b2DotVV(l, box2d.b2SubVV(e, d, box2d.b2Vec2.s_t0)), l = box2d.b2DotVV(l, f);
    if (0 == l)
        return!1;
    l = h / l;
    if (0 >
            l || b.maxFraction < l)
        return!1;
    b = box2d.b2AddVMulSV(d, l, f, box2d.b2EdgeShape.prototype.RayCast.s_q);
    d = box2d.b2SubVV(g, e, box2d.b2EdgeShape.prototype.RayCast.s_r);
    g = box2d.b2DotVV(d, d);
    if (0 == g)
        return!1;
    e = box2d.b2DotVV(box2d.b2SubVV(b, e, box2d.b2Vec2.s_t0), d) / g;
    if (0 > e || 1 < e)
        return!1;
    a.fraction = l;
    box2d.b2MulRV(c.q, a.normal, a.normal);
    0 < h && a.normal.SelfNeg();
    return!0
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "RayCast", box2d.b2EdgeShape.prototype.RayCast);
box2d.b2EdgeShape.prototype.RayCast.s_p1 = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_p2 = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_d = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_e = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_q = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.RayCast.s_r = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.ComputeAABB = function(a, b, c) {
    c = box2d.b2MulXV(b, this.m_vertex1, box2d.b2EdgeShape.prototype.ComputeAABB.s_v1);
    b = box2d.b2MulXV(b, this.m_vertex2, box2d.b2EdgeShape.prototype.ComputeAABB.s_v2);
    box2d.b2MinV(c, b, a.lowerBound);
    box2d.b2MaxV(c, b, a.upperBound);
    b = this.m_radius;
    a.lowerBound.SelfSubXY(b, b);
    a.upperBound.SelfAddXY(b, b)
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "ComputeAABB", box2d.b2EdgeShape.prototype.ComputeAABB);
box2d.b2EdgeShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2;
box2d.b2EdgeShape.prototype.ComputeMass = function(a, b) {
    a.mass = 0;
    box2d.b2MidVV(this.m_vertex1, this.m_vertex2, a.center);
    a.I = 0
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "ComputeMass", box2d.b2EdgeShape.prototype.ComputeMass);
box2d.b2EdgeShape.prototype.SetupDistanceProxy = function(a, b) {
    a.m_vertices = Array(2);
    a.m_vertices[0] = this.m_vertex1;
    a.m_vertices[1] = this.m_vertex2;
    a.m_count = 2;
    a.m_radius = this.m_radius
};
box2d.b2EdgeShape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    e.SetZero();
    return 0
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "ComputeSubmergedArea", box2d.b2EdgeShape.prototype.ComputeSubmergedArea);
box2d.b2EdgeShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2EdgeShape*/ var shape = new box2d.b2EdgeShape();\n");
    box2d.b2Log("    shape.m_radius = %.15f;\n", this.m_radius);
    box2d.b2Log("    shape.m_vertex0.SetXY(%.15f, %.15f);\n", this.m_vertex0.x, this.m_vertex0.y);
    box2d.b2Log("    shape.m_vertex1.SetXY(%.15f, %.15f);\n", this.m_vertex1.x, this.m_vertex1.y);
    box2d.b2Log("    shape.m_vertex2.SetXY(%.15f, %.15f);\n", this.m_vertex2.x, this.m_vertex2.y);
    box2d.b2Log("    shape.m_vertex3.SetXY(%.15f, %.15f);\n",
            this.m_vertex3.x, this.m_vertex3.y);
    box2d.b2Log("    shape.m_hasVertex0 = %s;\n", this.m_hasVertex0);
    box2d.b2Log("    shape.m_hasVertex3 = %s;\n", this.m_hasVertex3)
};
goog.exportProperty(box2d.b2EdgeShape.prototype, "Dump", box2d.b2EdgeShape.prototype.Dump);
box2d.b2ChainShape = function() {
    box2d.b2Shape.call(this, box2d.b2ShapeType.e_chainShape, box2d.b2_polygonRadius);
    this.m_prevVertex = new box2d.b2Vec2;
    this.m_nextVertex = new box2d.b2Vec2
};
goog.inherits(box2d.b2ChainShape, box2d.b2Shape);
goog.exportSymbol("box2d.b2ChainShape", box2d.b2ChainShape);
box2d.b2ChainShape.prototype.m_vertices = null;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_vertices", box2d.b2ChainShape.prototype.m_vertices);
box2d.b2ChainShape.prototype.m_count = 0;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_count", box2d.b2ChainShape.prototype.m_count);
box2d.b2ChainShape.prototype.m_prevVertex = null;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_prevVertex", box2d.b2ChainShape.prototype.m_prevVertex);
box2d.b2ChainShape.prototype.m_nextVertex = null;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_nextVertex", box2d.b2ChainShape.prototype.m_nextVertex);
box2d.b2ChainShape.prototype.m_hasPrevVertex = !1;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_hasPrevVertex", box2d.b2ChainShape.prototype.m_hasPrevVertex);
box2d.b2ChainShape.prototype.m_hasNextVertex = !1;
goog.exportProperty(box2d.b2ChainShape.prototype, "m_hasNextVertex", box2d.b2ChainShape.prototype.m_hasNextVertex);
box2d.b2ChainShape.prototype.CreateLoop = function(a, b) {
    b = b || a.length;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null == this.m_vertices && 0 == this.m_count);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= b);
    if (box2d.ENABLE_ASSERTS)
        for (var c = 1; c < b; ++c)
            box2d.b2Assert(box2d.b2DistanceSquaredVV(a[c - 1], a[c]) > box2d.b2_linearSlop * box2d.b2_linearSlop);
    this.m_count = b + 1;
    this.m_vertices = box2d.b2Vec2.MakeArray(this.m_count);
    for (c = 0; c < b; ++c)
        this.m_vertices[c].Copy(a[c]);
    this.m_vertices[b].Copy(this.m_vertices[0]);
    this.m_prevVertex.Copy(this.m_vertices[this.m_count -
    2]);
    this.m_nextVertex.Copy(this.m_vertices[1]);
    this.m_hasNextVertex = this.m_hasPrevVertex = !0;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "CreateLoop", box2d.b2ChainShape.prototype.CreateLoop);
box2d.b2ChainShape.prototype.CreateChain = function(a, b) {
    b = b || a.length;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null == this.m_vertices && 0 == this.m_count);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(2 <= b);
    if (box2d.ENABLE_ASSERTS)
        for (var c = 1; c < b; ++c)
            box2d.b2Assert(box2d.b2DistanceSquaredVV(a[c - 1], a[c]) > box2d.b2_linearSlop * box2d.b2_linearSlop);
    this.m_count = b;
    this.m_vertices = box2d.b2Vec2.MakeArray(b);
    for (c = 0; c < b; ++c)
        this.m_vertices[c].Copy(a[c]);
    this.m_hasNextVertex = this.m_hasPrevVertex = !1;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "CreateChain", box2d.b2ChainShape.prototype.CreateChain);
box2d.b2ChainShape.prototype.SetPrevVertex = function(a) {
    this.m_prevVertex.Copy(a);
    this.m_hasPrevVertex = !0;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "SetPrevVertex", box2d.b2ChainShape.prototype.SetPrevVertex);
box2d.b2ChainShape.prototype.SetNextVertex = function(a) {
    this.m_nextVertex.Copy(a);
    this.m_hasNextVertex = !0;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "SetNextVertex", box2d.b2ChainShape.prototype.SetNextVertex);
box2d.b2ChainShape.prototype.Clone = function() {
    return(new box2d.b2ChainShape).Copy(this)
};
goog.exportProperty(box2d.b2ChainShape.prototype, "Clone", box2d.b2ChainShape.prototype.Clone);
box2d.b2ChainShape.prototype.Copy = function(a) {
    box2d.b2ChainShape.superClass_.Copy.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2ChainShape);
    this.CreateChain(a.m_vertices, a.m_count);
    this.m_prevVertex.Copy(a.m_prevVertex);
    this.m_nextVertex.Copy(a.m_nextVertex);
    this.m_hasPrevVertex = a.m_hasPrevVertex;
    this.m_hasNextVertex = a.m_hasNextVertex;
    return this
};
goog.exportProperty(box2d.b2ChainShape.prototype, "Copy", box2d.b2ChainShape.prototype.Copy);
box2d.b2ChainShape.prototype.GetChildCount = function() {
    return this.m_count - 1
};
goog.exportProperty(box2d.b2ChainShape.prototype, "GetChildCount", box2d.b2ChainShape.prototype.GetChildCount);
box2d.b2ChainShape.prototype.GetChildEdge = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= b && b < this.m_count - 1);
    a.m_type = box2d.b2ShapeType.e_edgeShape;
    a.m_radius = this.m_radius;
    a.m_vertex1.Copy(this.m_vertices[b]);
    a.m_vertex2.Copy(this.m_vertices[b + 1]);
    0 < b ? (a.m_vertex0.Copy(this.m_vertices[b - 1]), a.m_hasVertex0 = !0) : (a.m_vertex0.Copy(this.m_prevVertex), a.m_hasVertex0 = this.m_hasPrevVertex);
    b < this.m_count - 2 ? (a.m_vertex3.Copy(this.m_vertices[b + 2]), a.m_hasVertex3 = !0) : (a.m_vertex3.Copy(this.m_nextVertex),
            a.m_hasVertex3 = this.m_hasNextVertex)
};
goog.exportProperty(box2d.b2ChainShape.prototype, "GetChildEdge", box2d.b2ChainShape.prototype.GetChildEdge);
box2d.b2ChainShape.prototype.TestPoint = function(a, b) {
    return!1
};
goog.exportProperty(box2d.b2ChainShape.prototype, "TestPoint", box2d.b2ChainShape.prototype.TestPoint);
box2d.b2ChainShape.prototype.RayCast = function(a, b, c, e) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e < this.m_count);
    var d = box2d.b2ChainShape.s_edgeShape;
    d.m_vertex1.Copy(this.m_vertices[e]);
    d.m_vertex2.Copy(this.m_vertices[(e + 1) % this.m_count]);
    return d.RayCast(a, b, c, 0)
};
goog.exportProperty(box2d.b2ChainShape.prototype, "RayCast", box2d.b2ChainShape.prototype.RayCast);
box2d.b2ChainShape.s_edgeShape = new box2d.b2EdgeShape;
goog.exportProperty(box2d.b2ChainShape, "s_edgeShape", box2d.b2ChainShape.s_edgeShape);
box2d.b2ChainShape.prototype.ComputeAABB = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c < this.m_count);
    var e = this.m_vertices[(c + 1) % this.m_count];
    c = box2d.b2MulXV(b, this.m_vertices[c], box2d.b2ChainShape.prototype.ComputeAABB.s_v1);
    b = box2d.b2MulXV(b, e, box2d.b2ChainShape.prototype.ComputeAABB.s_v2);
    box2d.b2MinV(c, b, a.lowerBound);
    box2d.b2MaxV(c, b, a.upperBound)
};
goog.exportProperty(box2d.b2ChainShape.prototype, "ComputeAABB", box2d.b2ChainShape.prototype.ComputeAABB);
box2d.b2ChainShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2ChainShape.prototype.ComputeAABB, "s_v1", box2d.b2ChainShape.prototype.ComputeAABB.s_v1);
box2d.b2ChainShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2;
goog.exportProperty(box2d.b2ChainShape.prototype.ComputeAABB, "s_v2", box2d.b2ChainShape.prototype.ComputeAABB.s_v2);
box2d.b2ChainShape.prototype.ComputeMass = function(a, b) {
    a.mass = 0;
    a.center.SetZero();
    a.I = 0
};
goog.exportProperty(box2d.b2ChainShape.prototype, "ComputeMass", box2d.b2ChainShape.prototype.ComputeMass);
box2d.b2ChainShape.prototype.SetupDistanceProxy = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= b && b < this.m_count);
    a.m_buffer[0].Copy(this.m_vertices[b]);
    b + 1 < this.m_count ? a.m_buffer[1].Copy(this.m_vertices[b + 1]) : a.m_buffer[1].Copy(this.m_vertices[0]);
    a.m_vertices = a.m_buffer;
    a.m_count = 2;
    a.m_radius = this.m_radius
};
box2d.b2ChainShape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    e.SetZero();
    return 0
};
goog.exportProperty(box2d.b2ChainShape.prototype, "ComputeSubmergedArea", box2d.b2ChainShape.prototype.ComputeSubmergedArea);
box2d.b2ChainShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2ChainShape*/ var shape = new box2d.b2ChainShape();\n");
    box2d.b2Log("    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\n", box2d.b2_maxPolygonVertices);
    for (var a = 0; a < this.m_count; ++a)
        box2d.b2Log("    vs[%d].SetXY(%.15f, %.15f);\n", a, this.m_vertices[a].x, this.m_vertices[a].y);
    box2d.b2Log("    shape.CreateChain(vs, %d);\n", this.m_count);
    box2d.b2Log("    shape.m_prevVertex.SetXY(%.15f, %.15f);\n", this.m_prevVertex.x, this.m_prevVertex.y);
    box2d.b2Log("    shape.m_nextVertex.SetXY(%.15f, %.15f);\n", this.m_nextVertex.x, this.m_nextVertex.y);
    box2d.b2Log("    shape.m_hasPrevVertex = %s;\n", this.m_hasPrevVertex ? "true" : "false");
    box2d.b2Log("    shape.m_hasNextVertex = %s;\n", this.m_hasNextVertex ? "true" : "false")
};
goog.exportProperty(box2d.b2ChainShape.prototype, "Dump", box2d.b2ChainShape.prototype.Dump);
box2d.b2ChainAndPolygonContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2ChainAndPolygonContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2ChainAndPolygonContact", box2d.b2ChainAndPolygonContact);
box2d.b2ChainAndPolygonContact.Create = function(a) {
    return new box2d.b2ChainAndPolygonContact
};
goog.exportProperty(box2d.b2ChainAndPolygonContact, "Create", box2d.b2ChainAndPolygonContact.Create);
box2d.b2ChainAndPolygonContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2ChainAndPolygonContact, "Destroy", box2d.b2ChainAndPolygonContact.Destroy);
box2d.b2ChainAndPolygonContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2ChainAndPolygonContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_chainShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_polygonShape)
};
goog.exportProperty(box2d.b2ChainAndPolygonContact.prototype, "Reset", box2d.b2ChainAndPolygonContact.prototype.Reset);
box2d.b2ChainAndPolygonContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2ChainShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2PolygonShape);
    var f = box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge;
    (e instanceof box2d.b2ChainShape ? e : null).GetChildEdge(f, this.m_indexA);
    box2d.b2CollideEdgeAndPolygon(a, f, b, d instanceof box2d.b2PolygonShape ? d : null, c)
};
goog.exportProperty(box2d.b2ChainAndPolygonContact.prototype, "Evaluate", box2d.b2ChainAndPolygonContact.prototype.Evaluate);
box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape;
box2d.b2CollidePolygon = {};
box2d.b2EdgeSeparation = function(a, b, c, e, d) {
    var f = a.m_count, g = a.m_vertices, h = a.m_normals;
    a = e.m_count;
    e = e.m_vertices;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= c && c < f);
    for (var f = box2d.b2MulRV(b.q, h[c], box2d.b2EdgeSeparation.s_normal1World), l = box2d.b2MulTRV(d.q, f, box2d.b2EdgeSeparation.s_normal1), h = 0, k = box2d.b2_maxFloat, m = 0; m < a; ++m) {
        var n = box2d.b2DotVV(e[m], l);
        n < k && (k = n, h = m)
    }
    b = box2d.b2MulXV(b, g[c], box2d.b2EdgeSeparation.s_v1);
    d = box2d.b2MulXV(d, e[h], box2d.b2EdgeSeparation.s_v2);
    return box2d.b2DotVV(box2d.b2SubVV(d,
            b, box2d.b2Vec2.s_t0), f)
};
goog.exportSymbol("box2d.b2EdgeSeparation", box2d.b2EdgeSeparation);
box2d.b2EdgeSeparation.s_normal1World = new box2d.b2Vec2;
box2d.b2EdgeSeparation.s_normal1 = new box2d.b2Vec2;
box2d.b2EdgeSeparation.s_v1 = new box2d.b2Vec2;
box2d.b2EdgeSeparation.s_v2 = new box2d.b2Vec2;
box2d.b2FindMaxSeparation = function(a, b, c, e, d) {
    for (var f = b.m_count, g = b.m_normals, h = box2d.b2SubVV(box2d.b2MulXV(d, e.m_centroid, box2d.b2Vec2.s_t0), box2d.b2MulXV(c, b.m_centroid, box2d.b2Vec2.s_t1), box2d.b2FindMaxSeparation.s_d), l = box2d.b2MulTRV(c.q, h, box2d.b2FindMaxSeparation.s_dLocal1), h = 0, k = -box2d.b2_maxFloat, m = 0; m < f; ++m) {
        var n = box2d.b2DotVV(g[m], l);
        n > k && (k = n, h = m)
    }
    var g = box2d.b2EdgeSeparation(b, c, h, e, d), l = (h + f - 1) % f, k = box2d.b2EdgeSeparation(b, c, l, e, d), m = (h + 1) % f, n = box2d.b2EdgeSeparation(b, c, m, e, d), p = 0,
            q = 0, r = 0;
    if (k > g && k > n)
        r = -1, p = l, q = k;
    else if (n > g)
        r = 1, p = m, q = n;
    else
        return a[0] = h, g;
    for (; ; )
        if (h = -1 == r ? (p + f - 1) % f : (p + 1) % f, g = box2d.b2EdgeSeparation(b, c, h, e, d), g > q)
            p = h, q = g;
        else
            break;
    a[0] = p;
    return q
};
goog.exportSymbol("box2d.b2FindMaxSeparation", box2d.b2FindMaxSeparation);
box2d.b2FindMaxSeparation.s_d = new box2d.b2Vec2;
box2d.b2FindMaxSeparation.s_dLocal1 = new box2d.b2Vec2;
box2d.b2FindIncidentEdge = function(a, b, c, e, d, f) {
    var g = b.m_count, h = b.m_normals, l = d.m_count;
    b = d.m_vertices;
    d = d.m_normals;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= e && e < g);
    c = box2d.b2MulTRV(f.q, box2d.b2MulRV(c.q, h[e], box2d.b2Vec2.s_t0), box2d.b2FindIncidentEdge.s_normal1);
    for (var g = 0, h = box2d.b2_maxFloat, k = 0; k < l; ++k) {
        var m = box2d.b2DotVV(c, d[k]);
        m < h && (h = m, g = k)
    }
    d = g;
    l = (d + 1) % l;
    c = a[0];
    box2d.b2MulXV(f, b[d], c.v);
    c = c.id.cf;
    c.indexA = e;
    c.indexB = d;
    c.typeA = box2d.b2ContactFeatureType.e_face;
    c.typeB = box2d.b2ContactFeatureType.e_vertex;
    a = a[1];
    box2d.b2MulXV(f, b[l], a.v);
    f = a.id.cf;
    f.indexA = e;
    f.indexB = l;
    f.typeA = box2d.b2ContactFeatureType.e_face;
    f.typeB = box2d.b2ContactFeatureType.e_vertex
};
goog.exportSymbol("box2d.b2FindIncidentEdge", box2d.b2FindIncidentEdge);
box2d.b2FindIncidentEdge.s_normal1 = new box2d.b2Vec2;
box2d.b2CollidePolygons = function(a, b, c, e, d) {
    a.pointCount = 0;
    var f = b.m_radius + e.m_radius, g = box2d.b2CollidePolygons.s_edgeA;
    g[0] = 0;
    var h = box2d.b2FindMaxSeparation(g, b, c, e, d);
    if (!(h > f)) {
        var l = box2d.b2CollidePolygons.s_edgeB;
        l[0] = 0;
        var k = box2d.b2FindMaxSeparation(l, e, d, b, c);
        if (!(k > f)) {
            var m = 0, n = 0;
            k > 0.98 * h + 0.001 ? (h = e, e = b, b = d, m = l[0], a.type = box2d.b2ManifoldType.e_faceB, n = 1) : (h = b, b = c, c = d, m = g[0], a.type = box2d.b2ManifoldType.e_faceA, n = 0);
            g = box2d.b2CollidePolygons.s_incidentEdge;
            box2d.b2FindIncidentEdge(g, h, b,
                    m, e, c);
            d = h.m_vertices;
            var l = m, h = (m + 1) % h.m_count, p = d[l], q = d[h], m = box2d.b2SubVV(q, p, box2d.b2CollidePolygons.s_localTangent);
            m.Normalize();
            d = box2d.b2CrossVOne(m, box2d.b2CollidePolygons.s_localNormal);
            e = box2d.b2MidVV(p, q, box2d.b2CollidePolygons.s_planePoint);
            var k = box2d.b2MulRV(b.q, m, box2d.b2CollidePolygons.s_tangent), m = box2d.b2CrossVOne(k, box2d.b2CollidePolygons.s_normal), p = box2d.b2MulXV(b, p, box2d.b2CollidePolygons.s_v11), r = box2d.b2MulXV(b, q, box2d.b2CollidePolygons.s_v12);
            b = box2d.b2DotVV(m, p);
            var q =
                    -box2d.b2DotVV(k, p) + f, r = box2d.b2DotVV(k, r) + f, t = box2d.b2CollidePolygons.s_clipPoints1, p = box2d.b2CollidePolygons.s_clipPoints2, s = box2d.b2NegV(k, box2d.b2CollidePolygons.s_ntangent), g = box2d.b2ClipSegmentToLine(t, g, s, q, l);
            if (!(2 > g || (g = box2d.b2ClipSegmentToLine(p, t, k, r, h), 2 > g))) {
                a.localNormal.Copy(d);
                a.localPoint.Copy(e);
                for (l = g = 0; l < box2d.b2_maxManifoldPoints; ++l)
                    d = p[l], box2d.b2DotVV(m, d.v) - b <= f && (h = a.points[g], box2d.b2MulTXV(c, d.v, h.localPoint), h.id.Copy(d.id), n && (d = h.id.cf, h.id.cf.indexA = d.indexB, h.id.cf.indexB =
                            d.indexA, h.id.cf.typeA = d.typeB, h.id.cf.typeB = d.typeA), ++g);
                a.pointCount = g
            }
        }
    }
};
goog.exportSymbol("box2d.b2CollidePolygons", box2d.b2CollidePolygons);
box2d.b2CollidePolygons.s_incidentEdge = box2d.b2ClipVertex.MakeArray(2);
box2d.b2CollidePolygons.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2CollidePolygons.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2);
box2d.b2CollidePolygons.s_edgeA = box2d.b2MakeNumberArray(1);
box2d.b2CollidePolygons.s_edgeB = box2d.b2MakeNumberArray(1);
box2d.b2CollidePolygons.s_localTangent = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_localNormal = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_planePoint = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_normal = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_tangent = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_ntangent = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_v11 = new box2d.b2Vec2;
box2d.b2CollidePolygons.s_v12 = new box2d.b2Vec2;
box2d.b2PolygonContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2PolygonContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2PolygonContact", box2d.b2PolygonContact);
box2d.b2PolygonContact.Create = function(a) {
    return new box2d.b2PolygonContact
};
goog.exportProperty(box2d.b2PolygonContact, "Create", box2d.b2PolygonContact.Create);
box2d.b2PolygonContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2PolygonContact, "Destroy", box2d.b2PolygonContact.Destroy);
box2d.b2PolygonContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2PolygonContact.superClass_.Reset.call(this, a, b, c, e)
};
goog.exportProperty(box2d.b2PolygonContact.prototype, "Reset", box2d.b2PolygonContact.prototype.Reset);
box2d.b2PolygonContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2PolygonShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2PolygonShape);
    box2d.b2CollidePolygons(a, e instanceof box2d.b2PolygonShape ? e : null, b, d instanceof box2d.b2PolygonShape ? d : null, c)
};
goog.exportProperty(box2d.b2PolygonContact.prototype, "Evaluate", box2d.b2PolygonContact.prototype.Evaluate);
box2d.b2CollideCircle = {};
box2d.b2CollideCircles = function(a, b, c, e, d) {
    a.pointCount = 0;
    c = box2d.b2MulXV(c, b.m_p, box2d.b2CollideCircles.s_pA);
    d = box2d.b2MulXV(d, e.m_p, box2d.b2CollideCircles.s_pB);
    d = box2d.b2DistanceSquaredVV(c, d);
    c = b.m_radius + e.m_radius;
    d > c * c || (a.type = box2d.b2ManifoldType.e_circles, a.localPoint.Copy(b.m_p), a.localNormal.SetZero(), a.pointCount = 1, a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0)
};
goog.exportSymbol("box2d.b2CollideCircles", box2d.b2CollideCircles);
box2d.b2CollideCircles.s_pA = new box2d.b2Vec2;
box2d.b2CollideCircles.s_pB = new box2d.b2Vec2;
box2d.b2CollidePolygonAndCircle = function(a, b, c, e, d) {
    a.pointCount = 0;
    d = box2d.b2MulXV(d, e.m_p, box2d.b2CollidePolygonAndCircle.s_c);
    c = box2d.b2MulTXV(c, d, box2d.b2CollidePolygonAndCircle.s_cLocal);
    var f = 0, g = -box2d.b2_maxFloat;
    d = b.m_radius + e.m_radius;
    var h = b.m_count, l = b.m_vertices;
    b = b.m_normals;
    for (var k = 0; k < h; ++k) {
        var m = box2d.b2DotVV(b[k], box2d.b2SubVV(c, l[k], box2d.b2Vec2.s_t0));
        if (m > d)
            return;
        m > g && (g = m, f = k)
    }
    k = f;
    m = l[k];
    h = l[(k + 1) % h];
    g < box2d.b2_epsilon ? (a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, a.localNormal.Copy(b[f]),
            box2d.b2MidVV(m, h, a.localPoint), a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0) : (g = box2d.b2DotVV(box2d.b2SubVV(c, m, box2d.b2Vec2.s_t0), box2d.b2SubVV(h, m, box2d.b2Vec2.s_t1)), f = box2d.b2DotVV(box2d.b2SubVV(c, h, box2d.b2Vec2.s_t0), box2d.b2SubVV(m, h, box2d.b2Vec2.s_t1)), 0 >= g ? box2d.b2DistanceSquaredVV(c, m) > d * d || (a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, box2d.b2SubVV(c, m, a.localNormal).SelfNormalize(), a.localPoint.Copy(m), a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0) : 0 >= f ? box2d.b2DistanceSquaredVV(c,
            h) > d * d || (a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, box2d.b2SubVV(c, h, a.localNormal).SelfNormalize(), a.localPoint.Copy(h), a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0) : (f = box2d.b2MidVV(m, h, box2d.b2CollidePolygonAndCircle.s_faceCenter), g = box2d.b2DotVV(box2d.b2SubVV(c, f, box2d.b2Vec2.s_t1), b[k]), g > d || (a.pointCount = 1, a.type = box2d.b2ManifoldType.e_faceA, a.localNormal.Copy(b[k]).SelfNormalize(), a.localPoint.Copy(f), a.points[0].localPoint.Copy(e.m_p), a.points[0].id.key = 0)))
};
goog.exportSymbol("box2d.b2CollidePolygonAndCircle", box2d.b2CollidePolygonAndCircle);
box2d.b2CollidePolygonAndCircle.s_c = new box2d.b2Vec2;
box2d.b2CollidePolygonAndCircle.s_cLocal = new box2d.b2Vec2;
box2d.b2CollidePolygonAndCircle.s_faceCenter = new box2d.b2Vec2;
box2d.b2CircleContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2CircleContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2CircleContact", box2d.b2CircleContact);
box2d.b2CircleContact.Create = function(a) {
    return new box2d.b2CircleContact
};
goog.exportProperty(box2d.b2CircleContact, "Create", box2d.b2CircleContact.Create);
box2d.b2CircleContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2CircleContact, "Destroy", box2d.b2CircleContact.Destroy);
box2d.b2CircleContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2CircleContact.superClass_.Reset.call(this, a, b, c, e)
};
goog.exportProperty(box2d.b2CircleContact.prototype, "Reset", box2d.b2CircleContact.prototype.Reset);
box2d.b2CircleContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2CircleShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2CircleShape);
    box2d.b2CollideCircles(a, e instanceof box2d.b2CircleShape ? e : null, b, d instanceof box2d.b2CircleShape ? d : null, c)
};
goog.exportProperty(box2d.b2CircleContact.prototype, "Evaluate", box2d.b2CircleContact.prototype.Evaluate);
box2d.b2ChainAndCircleContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2ChainAndCircleContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2ChainAndCircleContact", box2d.b2ChainAndCircleContact);
box2d.b2ChainAndCircleContact.Create = function(a) {
    return new box2d.b2ChainAndCircleContact
};
goog.exportProperty(box2d.b2ChainAndCircleContact, "Create", box2d.b2ChainAndCircleContact.Create);
box2d.b2ChainAndCircleContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2ChainAndCircleContact, "Destroy", box2d.b2ChainAndCircleContact.Destroy);
box2d.b2ChainAndCircleContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2ChainAndCircleContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_chainShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_circleShape)
};
goog.exportProperty(box2d.b2ChainAndCircleContact.prototype, "Reset", box2d.b2ChainAndCircleContact.prototype.Reset);
box2d.b2ChainAndCircleContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2ChainShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2CircleShape);
    var f = box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge;
    (e instanceof box2d.b2ChainShape ? e : null).GetChildEdge(f, this.m_indexA);
    box2d.b2CollideEdgeAndCircle(a, f, b, d instanceof box2d.b2CircleShape ? d : null, c)
};
goog.exportProperty(box2d.b2ChainAndCircleContact.prototype, "Evaluate", box2d.b2ChainAndCircleContact.prototype.Evaluate);
box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape;
box2d.b2EdgeAndCircleContact = function() {
    box2d.b2Contact.call(this)
};
goog.inherits(box2d.b2EdgeAndCircleContact, box2d.b2Contact);
goog.exportSymbol("box2d.b2EdgeAndCircleContact", box2d.b2EdgeAndCircleContact);
box2d.b2EdgeAndCircleContact.Create = function(a) {
    return new box2d.b2EdgeAndCircleContact
};
goog.exportProperty(box2d.b2EdgeAndCircleContact, "Create", box2d.b2EdgeAndCircleContact.Create);
box2d.b2EdgeAndCircleContact.Destroy = function(a, b) {
};
goog.exportProperty(box2d.b2EdgeAndCircleContact, "Destroy", box2d.b2EdgeAndCircleContact.Destroy);
box2d.b2EdgeAndCircleContact.prototype.Reset = function(a, b, c, e) {
    box2d.b2EdgeAndCircleContact.superClass_.Reset.call(this, a, b, c, e);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.GetType() == box2d.b2ShapeType.e_edgeShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c.GetType() == box2d.b2ShapeType.e_circleShape)
};
goog.exportProperty(box2d.b2EdgeAndCircleContact.prototype, "Reset", box2d.b2EdgeAndCircleContact.prototype.Reset);
box2d.b2EdgeAndCircleContact.prototype.Evaluate = function(a, b, c) {
    var e = this.m_fixtureA.GetShape(), d = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2EdgeShape);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2CircleShape);
    box2d.b2CollideEdgeAndCircle(a, e instanceof box2d.b2EdgeShape ? e : null, b, d instanceof box2d.b2CircleShape ? d : null, c)
};
goog.exportProperty(box2d.b2EdgeAndCircleContact.prototype, "Evaluate", box2d.b2EdgeAndCircleContact.prototype.Evaluate);
box2d.b2VelocityConstraintPoint = function() {
    this.rA = new box2d.b2Vec2;
    this.rB = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2VelocityConstraintPoint", box2d.b2VelocityConstraintPoint);
box2d.b2VelocityConstraintPoint.prototype.rA = null;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "rA", box2d.b2VelocityConstraintPoint.prototype.rA);
box2d.b2VelocityConstraintPoint.prototype.rB = null;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "rB", box2d.b2VelocityConstraintPoint.prototype.rB);
box2d.b2VelocityConstraintPoint.prototype.normalImpulse = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "normalImpulse", box2d.b2VelocityConstraintPoint.prototype.normalImpulse);
box2d.b2VelocityConstraintPoint.prototype.tangentImpulse = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "tangentImpulse", box2d.b2VelocityConstraintPoint.prototype.tangentImpulse);
box2d.b2VelocityConstraintPoint.prototype.normalMass = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "normalMass", box2d.b2VelocityConstraintPoint.prototype.normalMass);
box2d.b2VelocityConstraintPoint.prototype.tangentMass = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "tangentMass", box2d.b2VelocityConstraintPoint.prototype.tangentMass);
box2d.b2VelocityConstraintPoint.prototype.velocityBias = 0;
goog.exportProperty(box2d.b2VelocityConstraintPoint.prototype, "velocityBias", box2d.b2VelocityConstraintPoint.prototype.velocityBias);
box2d.b2VelocityConstraintPoint.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2VelocityConstraintPoint
    })
};
goog.exportProperty(box2d.b2VelocityConstraintPoint, "MakeArray", box2d.b2VelocityConstraintPoint.MakeArray);
box2d.b2ContactVelocityConstraint = function() {
    this.points = box2d.b2VelocityConstraintPoint.MakeArray(box2d.b2_maxManifoldPoints);
    this.normal = new box2d.b2Vec2;
    this.tangent = new box2d.b2Vec2;
    this.normalMass = new box2d.b2Mat22;
    this.K = new box2d.b2Mat22
};
goog.exportSymbol("box2d.b2ContactVelocityConstraint", box2d.b2ContactVelocityConstraint);
box2d.b2ContactVelocityConstraint.prototype.points = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "points", box2d.b2ContactVelocityConstraint.prototype.points);
box2d.b2ContactVelocityConstraint.prototype.normal = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "normal", box2d.b2ContactVelocityConstraint.prototype.normal);
box2d.b2ContactVelocityConstraint.prototype.tangent = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "tangent", box2d.b2ContactVelocityConstraint.prototype.tangent);
box2d.b2ContactVelocityConstraint.prototype.normalMass = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "normalMass", box2d.b2ContactVelocityConstraint.prototype.normalMass);
box2d.b2ContactVelocityConstraint.prototype.K = null;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "K", box2d.b2ContactVelocityConstraint.prototype.K);
box2d.b2ContactVelocityConstraint.prototype.indexA = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "indexA", box2d.b2ContactVelocityConstraint.prototype.indexA);
box2d.b2ContactVelocityConstraint.prototype.indexB = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "indexB", box2d.b2ContactVelocityConstraint.prototype.indexB);
box2d.b2ContactVelocityConstraint.prototype.invMassA = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "invMassA", box2d.b2ContactVelocityConstraint.prototype.invMassA);
box2d.b2ContactVelocityConstraint.prototype.invMassB = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "invMassB", box2d.b2ContactVelocityConstraint.prototype.invMassB);
box2d.b2ContactVelocityConstraint.prototype.invIA = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "invIA", box2d.b2ContactVelocityConstraint.prototype.invIA);
box2d.b2ContactVelocityConstraint.prototype.invIB = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "invIB", box2d.b2ContactVelocityConstraint.prototype.invIB);
box2d.b2ContactVelocityConstraint.prototype.friction = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "friction", box2d.b2ContactVelocityConstraint.prototype.friction);
box2d.b2ContactVelocityConstraint.prototype.restitution = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "restitution", box2d.b2ContactVelocityConstraint.prototype.restitution);
box2d.b2ContactVelocityConstraint.prototype.tangentSpeed = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "tangentSpeed", box2d.b2ContactVelocityConstraint.prototype.tangentSpeed);
box2d.b2ContactVelocityConstraint.prototype.pointCount = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "pointCount", box2d.b2ContactVelocityConstraint.prototype.pointCount);
box2d.b2ContactVelocityConstraint.prototype.contactIndex = 0;
goog.exportProperty(box2d.b2ContactVelocityConstraint.prototype, "contactIndex", box2d.b2ContactVelocityConstraint.prototype.contactIndex);
box2d.b2ContactVelocityConstraint.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2ContactVelocityConstraint
    })
};
goog.exportProperty(box2d.b2ContactVelocityConstraint, "MakeArray", box2d.b2ContactVelocityConstraint.MakeArray);
box2d.b2ContactPositionConstraint = function() {
    this.localPoints = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints);
    this.localNormal = new box2d.b2Vec2;
    this.localPoint = new box2d.b2Vec2;
    this.localCenterA = new box2d.b2Vec2;
    this.localCenterB = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2ContactPositionConstraint", box2d.b2ContactPositionConstraint);
box2d.b2ContactPositionConstraint.prototype.localPoints = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localPoints", box2d.b2ContactPositionConstraint.prototype.localPoints);
box2d.b2ContactPositionConstraint.prototype.localNormal = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localNormal", box2d.b2ContactPositionConstraint.prototype.localNormal);
box2d.b2ContactPositionConstraint.prototype.localPoint = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localPoint", box2d.b2ContactPositionConstraint.prototype.localPoint);
box2d.b2ContactPositionConstraint.prototype.indexA = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "indexA", box2d.b2ContactPositionConstraint.prototype.indexA);
box2d.b2ContactPositionConstraint.prototype.indexB = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "indexB", box2d.b2ContactPositionConstraint.prototype.indexB);
box2d.b2ContactPositionConstraint.prototype.invMassA = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "invMassA", box2d.b2ContactPositionConstraint.prototype.invMassA);
box2d.b2ContactPositionConstraint.prototype.invMassB = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "invMassB", box2d.b2ContactPositionConstraint.prototype.invMassB);
box2d.b2ContactPositionConstraint.prototype.localCenterA = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localCenterA", box2d.b2ContactPositionConstraint.prototype.localCenterA);
box2d.b2ContactPositionConstraint.prototype.localCenterB = null;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "localCenterB", box2d.b2ContactPositionConstraint.prototype.localCenterB);
box2d.b2ContactPositionConstraint.prototype.invIA = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "invIA", box2d.b2ContactPositionConstraint.prototype.invIA);
box2d.b2ContactPositionConstraint.prototype.invIB = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "invIB", box2d.b2ContactPositionConstraint.prototype.invIB);
box2d.b2ContactPositionConstraint.prototype.type = box2d.b2ManifoldType.e_unknown;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "type", box2d.b2ContactPositionConstraint.prototype.type);
box2d.b2ContactPositionConstraint.prototype.radiusA = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "radiusA", box2d.b2ContactPositionConstraint.prototype.radiusA);
box2d.b2ContactPositionConstraint.prototype.radiusB = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "radiusB", box2d.b2ContactPositionConstraint.prototype.radiusB);
box2d.b2ContactPositionConstraint.prototype.pointCount = 0;
goog.exportProperty(box2d.b2ContactPositionConstraint.prototype, "pointCount", box2d.b2ContactPositionConstraint.prototype.pointCount);
box2d.b2ContactPositionConstraint.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2ContactPositionConstraint
    })
};
goog.exportProperty(box2d.b2ContactPositionConstraint, "MakeArray", box2d.b2ContactPositionConstraint.MakeArray);
box2d.b2ContactSolverDef = function() {
    this.step = new box2d.b2TimeStep
};
goog.exportSymbol("box2d.b2ContactSolverDef", box2d.b2ContactSolverDef);
box2d.b2ContactSolverDef.prototype.step = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "step", box2d.b2ContactSolverDef.prototype.step);
box2d.b2ContactSolverDef.prototype.contacts = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "contacts", box2d.b2ContactSolverDef.prototype.contacts);
box2d.b2ContactSolverDef.prototype.count = 0;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "count", box2d.b2ContactSolverDef.prototype.count);
box2d.b2ContactSolverDef.prototype.positions = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "positions", box2d.b2ContactSolverDef.prototype.positions);
box2d.b2ContactSolverDef.prototype.velocities = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "velocities", box2d.b2ContactSolverDef.prototype.velocities);
box2d.b2ContactSolverDef.prototype.allocator = null;
goog.exportProperty(box2d.b2ContactSolverDef.prototype, "allocator", box2d.b2ContactSolverDef.prototype.allocator);
box2d.b2ContactSolver = function() {
    this.m_step = new box2d.b2TimeStep;
    this.m_positionConstraints = box2d.b2ContactPositionConstraint.MakeArray(1024);
    this.m_velocityConstraints = box2d.b2ContactVelocityConstraint.MakeArray(1024)
};
goog.exportSymbol("box2d.b2ContactSolver", box2d.b2ContactSolver);
box2d.b2ContactSolver.prototype.m_step = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_step", box2d.b2ContactSolver.prototype.m_step);
box2d.b2ContactSolver.prototype.m_positions = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_positions", box2d.b2ContactSolver.prototype.m_positions);
box2d.b2ContactSolver.prototype.m_velocities = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_velocities", box2d.b2ContactSolver.prototype.m_velocities);
box2d.b2ContactSolver.prototype.m_allocator = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_allocator", box2d.b2ContactSolver.prototype.m_allocator);
box2d.b2ContactSolver.prototype.m_positionConstraints = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_positionConstraints", box2d.b2ContactSolver.prototype.m_positionConstraints);
box2d.b2ContactSolver.prototype.m_velocityConstraints = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_velocityConstraints", box2d.b2ContactSolver.prototype.m_velocityConstraints);
box2d.b2ContactSolver.prototype.m_contacts = null;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_contacts", box2d.b2ContactSolver.prototype.m_contacts);
box2d.b2ContactSolver.prototype.m_count = 0;
goog.exportProperty(box2d.b2ContactSolver.prototype, "m_count", box2d.b2ContactSolver.prototype.m_count);
box2d.b2ContactSolver.prototype.Initialize = function(a) {
    this.m_step.Copy(a.step);
    this.m_allocator = a.allocator;
    this.m_count = a.count;
    if (this.m_positionConstraints.length < this.m_count) {
        var b = box2d.b2Max(2 * this.m_positionConstraints.length, this.m_count);
        for (box2d.DEBUG && window.console.log("box2d.b2ContactSolver.m_positionConstraints: " + b); this.m_positionConstraints.length < b; )
            this.m_positionConstraints[this.m_positionConstraints.length] = new box2d.b2ContactPositionConstraint
    }
    if (this.m_velocityConstraints.length <
            this.m_count)
        for (b = box2d.b2Max(2 * this.m_velocityConstraints.length, this.m_count), box2d.DEBUG && window.console.log("box2d.b2ContactSolver.m_velocityConstraints: " + b); this.m_velocityConstraints.length < b; )
            this.m_velocityConstraints[this.m_velocityConstraints.length] = new box2d.b2ContactVelocityConstraint;
    this.m_positions = a.positions;
    this.m_velocities = a.velocities;
    this.m_contacts = a.contacts;
    var c, e, d, f, g, h, l, k;
    a = 0;
    for (b = this.m_count; a < b; ++a)
        for (d = this.m_contacts[a], f = d.m_fixtureA, g = d.m_fixtureB, c = f.GetShape(),
                e = g.GetShape(), c = c.m_radius, e = e.m_radius, h = f.GetBody(), l = g.GetBody(), g = d.GetManifold(), k = g.pointCount, box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < k), f = this.m_velocityConstraints[a], f.friction = d.m_friction, f.restitution = d.m_restitution, f.tangentSpeed = d.m_tangentSpeed, f.indexA = h.m_islandIndex, f.indexB = l.m_islandIndex, f.invMassA = h.m_invMass, f.invMassB = l.m_invMass, f.invIA = h.m_invI, f.invIB = l.m_invI, f.contactIndex = a, f.pointCount = k, f.K.SetZero(), f.normalMass.SetZero(), d = this.m_positionConstraints[a], d.indexA =
                h.m_islandIndex, d.indexB = l.m_islandIndex, d.invMassA = h.m_invMass, d.invMassB = l.m_invMass, d.localCenterA.Copy(h.m_sweep.localCenter), d.localCenterB.Copy(l.m_sweep.localCenter), d.invIA = h.m_invI, d.invIB = l.m_invI, d.localNormal.Copy(g.localNormal), d.localPoint.Copy(g.localPoint), d.pointCount = k, d.radiusA = c, d.radiusB = e, d.type = g.type, c = 0, e = k; c < e; ++c)
            h = g.points[c], k = f.points[c], this.m_step.warmStarting ? (k.normalImpulse = this.m_step.dtRatio * h.normalImpulse, k.tangentImpulse = this.m_step.dtRatio * h.tangentImpulse) :
                    (k.normalImpulse = 0, k.tangentImpulse = 0), k.rA.SetZero(), k.rB.SetZero(), k.normalMass = 0, k.tangentMass = 0, k.velocityBias = 0, d.localPoints[c].Copy(h.localPoint);
    return this
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "Initialize", box2d.b2ContactSolver.prototype.Initialize);
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints = function() {
    var a, b, c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u, v, y, D = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA, x = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB, w = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold;
    a = 0;
    for (b = this.m_count; a < b; ++a) {
        d = this.m_velocityConstraints[a];
        f = this.m_positionConstraints[a];
        c = f.radiusA;
        e = f.radiusB;
        g = this.m_contacts[d.contactIndex].GetManifold();
        h = d.indexA;
        l = d.indexB;
        k = d.invMassA;
        m = d.invMassB;
        n = d.invIA;
        p = d.invIB;
        q = f.localCenterA;
        r = f.localCenterB;
        f = this.m_positions[h].c;
        t = this.m_positions[h].a;
        s = this.m_velocities[h].v;
        h = this.m_velocities[h].w;
        u = this.m_positions[l].c;
        v = this.m_positions[l].a;
        y = this.m_velocities[l].v;
        l = this.m_velocities[l].w;
        box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < g.pointCount);
        D.q.SetAngleRadians(t);
        x.q.SetAngleRadians(v);
        box2d.b2SubVV(f, box2d.b2MulRV(D.q, q, box2d.b2Vec2.s_t0), D.p);
        box2d.b2SubVV(u, box2d.b2MulRV(x.q, r, box2d.b2Vec2.s_t0),
                x.p);
        w.Initialize(g, D, c, x, e);
        d.normal.Copy(w.normal);
        box2d.b2CrossVOne(d.normal, d.tangent);
        e = d.pointCount;
        for (c = 0; c < e; ++c)
            g = d.points[c], box2d.b2SubVV(w.points[c], f, g.rA), box2d.b2SubVV(w.points[c], u, g.rB), q = box2d.b2CrossVV(g.rA, d.normal), r = box2d.b2CrossVV(g.rB, d.normal), q = k + m + n * q * q + p * r * r, g.normalMass = 0 < q ? 1 / q : 0, r = d.tangent, q = box2d.b2CrossVV(g.rA, r), r = box2d.b2CrossVV(g.rB, r), q = k + m + n * q * q + p * r * r, g.tangentMass = 0 < q ? 1 / q : 0, g.velocityBias = 0, q = box2d.b2DotVV(d.normal, box2d.b2SubVV(box2d.b2AddVCrossSV(y, l, g.rB,
                    box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(s, h, g.rA, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0)), q < -box2d.b2_velocityThreshold && (g.velocityBias += -d.restitution * q);
        2 == d.pointCount && (s = d.points[0], u = d.points[1], f = box2d.b2CrossVV(s.rA, d.normal), s = box2d.b2CrossVV(s.rB, d.normal), h = box2d.b2CrossVV(u.rA, d.normal), l = box2d.b2CrossVV(u.rB, d.normal), u = k + m + n * f * f + p * s * s, y = k + m + n * h * h + p * l * l, k = k + m + n * f * h + p * s * l, u * u < 1E3 * (u * y - k * k) ? (d.K.ex.SetXY(u, k), d.K.ey.SetXY(k, y), d.K.GetInverse(d.normalMass)) : d.pointCount = 1)
    }
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "InitializeVelocityConstraints", box2d.b2ContactSolver.prototype.InitializeVelocityConstraints);
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold = new box2d.b2WorldManifold;
box2d.b2ContactSolver.prototype.WarmStart = function() {
    var a, b, c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u, v = box2d.b2ContactSolver.prototype.WarmStart.s_P;
    a = 0;
    for (b = this.m_count; a < b; ++a) {
        d = this.m_velocityConstraints[a];
        f = d.indexA;
        g = d.indexB;
        h = d.invMassA;
        l = d.invIA;
        k = d.invMassB;
        m = d.invIB;
        e = d.pointCount;
        n = this.m_velocities[f].v;
        p = this.m_velocities[f].w;
        q = this.m_velocities[g].v;
        r = this.m_velocities[g].w;
        t = d.normal;
        s = d.tangent;
        for (c = 0; c < e; ++c)
            u = d.points[c], box2d.b2AddVV(box2d.b2MulSV(u.normalImpulse, t, box2d.b2Vec2.s_t0),
                    box2d.b2MulSV(u.tangentImpulse, s, box2d.b2Vec2.s_t1), v), p -= l * box2d.b2CrossVV(u.rA, v), n.SelfMulSub(h, v), r += m * box2d.b2CrossVV(u.rB, v), q.SelfMulAdd(k, v);
        this.m_velocities[f].w = p;
        this.m_velocities[g].w = r
    }
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "WarmStart", box2d.b2ContactSolver.prototype.WarmStart);
box2d.b2ContactSolver.prototype.WarmStart.s_P = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints = function() {
    var a, b, c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u, v, y = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv, D = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1, x = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2, w, C, A = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P, E = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a, B = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b, z = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x,
            G = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d, F = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1, H = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2, I = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2;
    a = 0;
    for (b = this.m_count; a < b; ++a) {
        d = this.m_velocityConstraints[a];
        f = d.indexA;
        g = d.indexB;
        h = d.invMassA;
        l = d.invIA;
        k = d.invMassB;
        m = d.invIB;
        n = d.pointCount;
        p = this.m_velocities[f].v;
        q = this.m_velocities[f].w;
        r = this.m_velocities[g].v;
        t = this.m_velocities[g].w;
        s = d.normal;
        u = d.tangent;
        v = d.friction;
        box2d.ENABLE_ASSERTS && box2d.b2Assert(1 == n || 2 == n);
        c = 0;
        for (e = n; c < e; ++c)
            n = d.points[c], box2d.b2SubVV(box2d.b2AddVCrossSV(r, t, n.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, q, n.rA, box2d.b2Vec2.s_t1), y), w = box2d.b2DotVV(y, u) - d.tangentSpeed, w = n.tangentMass * -w, C = v * n.normalImpulse, C = box2d.b2Clamp(n.tangentImpulse + w, -C, C), w = C - n.tangentImpulse, n.tangentImpulse = C, box2d.b2MulSV(w, u, A), p.SelfMulSub(h, A), q -= l * box2d.b2CrossVV(n.rA, A), r.SelfMulAdd(k, A), t += m * box2d.b2CrossVV(n.rB, A);
        if (1 == d.pointCount)
            n = d.points[0], box2d.b2SubVV(box2d.b2AddVCrossSV(r, t, n.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, q, n.rA, box2d.b2Vec2.s_t1), y), d = box2d.b2DotVV(y, s), w = -n.normalMass * (d - n.velocityBias), C = box2d.b2Max(n.normalImpulse + w, 0), w = C - n.normalImpulse, n.normalImpulse = C, box2d.b2MulSV(w, s, A), p.SelfMulSub(h, A), q -= l * box2d.b2CrossVV(n.rA, A), r.SelfMulAdd(k, A), t += m * box2d.b2CrossVV(n.rB, A);
        else
            for (c = d.points[0], u = d.points[1], E.SetXY(c.normalImpulse, u.normalImpulse), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <=
                    E.x && 0 <= E.y), box2d.b2SubVV(box2d.b2AddVCrossSV(r, t, c.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, q, c.rA, box2d.b2Vec2.s_t1), D), box2d.b2SubVV(box2d.b2AddVCrossSV(r, t, u.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(p, q, u.rA, box2d.b2Vec2.s_t1), x), v = box2d.b2DotVV(D, s), n = box2d.b2DotVV(x, s), B.x = v - c.velocityBias, B.y = n - u.velocityBias, B.SelfSub(box2d.b2MulMV(d.K, E, box2d.b2Vec2.s_t0)); ; ) {
                box2d.b2MulMV(d.normalMass, B, z).SelfNeg();
                if (0 <= z.x && 0 <= z.y) {
                    box2d.b2SubVV(z, E, G);
                    box2d.b2MulSV(G.x, s, F);
                    box2d.b2MulSV(G.y, s,
                            H);
                    box2d.b2AddVV(F, H, I);
                    p.SelfMulSub(h, I);
                    q -= l * (box2d.b2CrossVV(c.rA, F) + box2d.b2CrossVV(u.rA, H));
                    r.SelfMulAdd(k, I);
                    t += m * (box2d.b2CrossVV(c.rB, F) + box2d.b2CrossVV(u.rB, H));
                    c.normalImpulse = z.x;
                    u.normalImpulse = z.y;
                    break
                }
                z.x = -c.normalMass * B.x;
                z.y = 0;
                n = d.K.ex.y * z.x + B.y;
                if (0 <= z.x && 0 <= n) {
                    box2d.b2SubVV(z, E, G);
                    box2d.b2MulSV(G.x, s, F);
                    box2d.b2MulSV(G.y, s, H);
                    box2d.b2AddVV(F, H, I);
                    p.SelfMulSub(h, I);
                    q -= l * (box2d.b2CrossVV(c.rA, F) + box2d.b2CrossVV(u.rA, H));
                    r.SelfMulAdd(k, I);
                    t += m * (box2d.b2CrossVV(c.rB, F) + box2d.b2CrossVV(u.rB,
                            H));
                    c.normalImpulse = z.x;
                    u.normalImpulse = z.y;
                    break
                }
                z.x = 0;
                z.y = -u.normalMass * B.y;
                v = d.K.ey.x * z.y + B.x;
                if (0 <= z.y && 0 <= v) {
                    box2d.b2SubVV(z, E, G);
                    box2d.b2MulSV(G.x, s, F);
                    box2d.b2MulSV(G.y, s, H);
                    box2d.b2AddVV(F, H, I);
                    p.SelfMulSub(h, I);
                    q -= l * (box2d.b2CrossVV(c.rA, F) + box2d.b2CrossVV(u.rA, H));
                    r.SelfMulAdd(k, I);
                    t += m * (box2d.b2CrossVV(c.rB, F) + box2d.b2CrossVV(u.rB, H));
                    c.normalImpulse = z.x;
                    u.normalImpulse = z.y;
                    break
                }
                z.x = 0;
                z.y = 0;
                v = B.x;
                n = B.y;
                if (0 <= v && 0 <= n) {
                    box2d.b2SubVV(z, E, G);
                    box2d.b2MulSV(G.x, s, F);
                    box2d.b2MulSV(G.y, s, H);
                    box2d.b2AddVV(F,
                            H, I);
                    p.SelfMulSub(h, I);
                    q -= l * (box2d.b2CrossVV(c.rA, F) + box2d.b2CrossVV(u.rA, H));
                    r.SelfMulAdd(k, I);
                    t += m * (box2d.b2CrossVV(c.rB, F) + box2d.b2CrossVV(u.rB, H));
                    c.normalImpulse = z.x;
                    u.normalImpulse = z.y;
                    break
                }
                break
            }
        this.m_velocities[f].w = q;
        this.m_velocities[g].w = t
    }
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "SolveVelocityConstraints", box2d.b2ContactSolver.prototype.SolveVelocityConstraints);
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2 = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.StoreImpulses = function() {
    var a, b, c, e, d, f;
    a = 0;
    for (b = this.m_count; a < b; ++a)
        for (d = this.m_velocityConstraints[a], f = this.m_contacts[d.contactIndex].GetManifold(), c = 0, e = d.pointCount; c < e; ++c)
            f.points[c].normalImpulse = d.points[c].normalImpulse, f.points[c].tangentImpulse = d.points[c].tangentImpulse
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "StoreImpulses", box2d.b2ContactSolver.prototype.StoreImpulses);
box2d.b2PositionSolverManifold = function() {
    this.normal = new box2d.b2Vec2;
    this.point = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2PositionSolverManifold", box2d.b2PositionSolverManifold);
box2d.b2PositionSolverManifold.prototype.normal = null;
goog.exportProperty(box2d.b2PositionSolverManifold.prototype, "normal", box2d.b2PositionSolverManifold.prototype.normal);
box2d.b2PositionSolverManifold.prototype.point = null;
goog.exportProperty(box2d.b2PositionSolverManifold.prototype, "point", box2d.b2PositionSolverManifold.prototype.point);
box2d.b2PositionSolverManifold.prototype.separation = 0;
goog.exportProperty(box2d.b2PositionSolverManifold.prototype, "separation", box2d.b2PositionSolverManifold.prototype.separation);
box2d.b2PositionSolverManifold.prototype.Initialize = function(a, b, c, e) {
    var d = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA, f = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB, g = box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint, h = box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < a.pointCount);
    switch (a.type) {
        case box2d.b2ManifoldType.e_circles:
            box2d.b2MulXV(b, a.localPoint, d);
            box2d.b2MulXV(c, a.localPoints[0],
                    f);
            box2d.b2SubVV(f, d, this.normal).SelfNormalize();
            box2d.b2MidVV(d, f, this.point);
            this.separation = box2d.b2DotVV(box2d.b2SubVV(f, d, box2d.b2Vec2.s_t0), this.normal) - a.radiusA - a.radiusB;
            break;
        case box2d.b2ManifoldType.e_faceA:
            box2d.b2MulRV(b.q, a.localNormal, this.normal);
            box2d.b2MulXV(b, a.localPoint, g);
            box2d.b2MulXV(c, a.localPoints[e], h);
            this.separation = box2d.b2DotVV(box2d.b2SubVV(h, g, box2d.b2Vec2.s_t0), this.normal) - a.radiusA - a.radiusB;
            this.point.Copy(h);
            break;
        case box2d.b2ManifoldType.e_faceB:
            box2d.b2MulRV(c.q,
                    a.localNormal, this.normal), box2d.b2MulXV(c, a.localPoint, g), box2d.b2MulXV(b, a.localPoints[e], h), this.separation = box2d.b2DotVV(box2d.b2SubVV(h, g, box2d.b2Vec2.s_t0), this.normal) - a.radiusA - a.radiusB, this.point.Copy(h), this.normal.SelfNeg()
        }
};
goog.exportProperty(box2d.b2PositionSolverManifold.prototype, "Initialize", box2d.b2PositionSolverManifold.prototype.Initialize);
box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2;
box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2;
box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2;
box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolvePositionConstraints = function() {
    var a, b, c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA, v = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB, y = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm, D, x, w, C = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA, A = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB, E, B = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P, z =
            0;
    a = 0;
    for (b = this.m_count; a < b; ++a) {
        d = this.m_positionConstraints[a];
        f = d.indexA;
        g = d.indexB;
        h = d.localCenterA;
        l = d.invMassA;
        k = d.invIA;
        m = d.localCenterB;
        n = d.invMassB;
        p = d.invIB;
        e = d.pointCount;
        q = this.m_positions[f].c;
        r = this.m_positions[f].a;
        t = this.m_positions[g].c;
        s = this.m_positions[g].a;
        for (c = 0; c < e; ++c)
            u.q.SetAngleRadians(r), v.q.SetAngleRadians(s), box2d.b2SubVV(q, box2d.b2MulRV(u.q, h, box2d.b2Vec2.s_t0), u.p), box2d.b2SubVV(t, box2d.b2MulRV(v.q, m, box2d.b2Vec2.s_t0), v.p), y.Initialize(d, u, v, c), D = y.normal, x = y.point,
                    w = y.separation, box2d.b2SubVV(x, q, C), box2d.b2SubVV(x, t, A), z = box2d.b2Min(z, w), x = box2d.b2Clamp(box2d.b2_baumgarte * (w + box2d.b2_linearSlop), -box2d.b2_maxLinearCorrection, 0), w = box2d.b2CrossVV(C, D), E = box2d.b2CrossVV(A, D), w = l + n + k * w * w + p * E * E, x = 0 < w ? -x / w : 0, box2d.b2MulSV(x, D, B), q.SelfMulSub(l, B), r -= k * box2d.b2CrossVV(C, B), t.SelfMulAdd(n, B), s += p * box2d.b2CrossVV(A, B);
        this.m_positions[f].a = r;
        this.m_positions[g].a = s
    }
    return z > -3 * box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "SolvePositionConstraints", box2d.b2ContactSolver.prototype.SolvePositionConstraints);
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm = new box2d.b2PositionSolverManifold;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints = function(a, b) {
    var c, e, d, f, g, h, l, k, m, n, p, q, r, t, s, u, v, y = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA, D = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB, x = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm, w, C, A, E = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA, B = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB, z, G = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P,
            F = 0;
    c = 0;
    for (e = this.m_count; c < e; ++c) {
        g = this.m_positionConstraints[c];
        h = g.indexA;
        l = g.indexB;
        k = g.localCenterA;
        m = g.localCenterB;
        f = g.pointCount;
        p = n = 0;
        if (h == a || h == b)
            n = g.invMassA, p = g.invIA;
        r = q = 0;
        if (l == a || l == b)
            q = g.invMassB, r = g.invIB;
        t = this.m_positions[h].c;
        s = this.m_positions[h].a;
        u = this.m_positions[l].c;
        v = this.m_positions[l].a;
        for (d = 0; d < f; ++d)
            y.q.SetAngleRadians(s), D.q.SetAngleRadians(v), box2d.b2SubVV(t, box2d.b2MulRV(y.q, k, box2d.b2Vec2.s_t0), y.p), box2d.b2SubVV(u, box2d.b2MulRV(D.q, m, box2d.b2Vec2.s_t0), D.p),
                    x.Initialize(g, y, D, d), w = x.normal, C = x.point, A = x.separation, box2d.b2SubVV(C, t, E), box2d.b2SubVV(C, u, B), F = box2d.b2Min(F, A), C = box2d.b2Clamp(box2d.b2_toiBaumgarte * (A + box2d.b2_linearSlop), -box2d.b2_maxLinearCorrection, 0), A = box2d.b2CrossVV(E, w), z = box2d.b2CrossVV(B, w), A = n + q + p * A * A + r * z * z, C = 0 < A ? -C / A : 0, box2d.b2MulSV(C, w, G), t.SelfMulSub(n, G), s -= p * box2d.b2CrossVV(E, G), u.SelfMulAdd(q, G), v += r * box2d.b2CrossVV(B, G);
        this.m_positions[h].a = s;
        this.m_positions[l].a = v
    }
    return F >= -1.5 * box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2ContactSolver.prototype, "SolveTOIPositionConstraints", box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints);
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB = new box2d.b2Transform;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm = new box2d.b2PositionSolverManifold;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB = new box2d.b2Vec2;
box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2WorldCallbacks = {};
box2d.b2DestructionListener = function() {
};
goog.exportSymbol("box2d.b2DestructionListener", box2d.b2DestructionListener);
box2d.b2DestructionListener.prototype.SayGoodbyeJoint = function(a) {
};
goog.exportProperty(box2d.b2DestructionListener.prototype, "SayGoodbyeJoint", box2d.b2DestructionListener.prototype.SayGoodbyeJoint);
box2d.b2DestructionListener.prototype.SayGoodbyeFixture = function(a) {
};
goog.exportProperty(box2d.b2DestructionListener.prototype, "SayGoodbyeFixture", box2d.b2DestructionListener.prototype.SayGoodbyeFixture);
box2d.b2ContactFilter = function() {
};
goog.exportSymbol("box2d.b2ContactFilter", box2d.b2ContactFilter);
box2d.b2ContactFilter.prototype.ShouldCollide = function(a, b) {
    var c = a.GetFilterData(), e = b.GetFilterData();
    return c.groupIndex == e.groupIndex && 0 != c.groupIndex ? 0 < c.groupIndex : 0 != (c.maskBits & e.categoryBits) && 0 != (c.categoryBits & e.maskBits)
};
goog.exportProperty(box2d.b2ContactFilter.prototype, "ShouldCollide", box2d.b2ContactFilter.prototype.ShouldCollide);
box2d.b2ContactFilter.b2_defaultFilter = new box2d.b2ContactFilter;
box2d.b2ContactImpulse = function() {
    this.normalImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints);
    this.tangentImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints)
};
goog.exportSymbol("box2d.b2ContactImpulse", box2d.b2ContactImpulse);
box2d.b2ContactImpulse.prototype.normalImpulses = null;
box2d.b2ContactImpulse.prototype.tangentImpulses = null;
box2d.b2ContactImpulse.prototype.count = 0;
box2d.b2ContactListener = function() {
};
goog.exportSymbol("box2d.b2ContactListener", box2d.b2ContactListener);
box2d.b2ContactListener.prototype.BeginContact = function(a) {
};
goog.exportProperty(box2d.b2ContactListener.prototype, "BeginContact", box2d.b2ContactListener.prototype.BeginContact);
box2d.b2ContactListener.prototype.EndContact = function(a) {
};
goog.exportProperty(box2d.b2ContactListener.prototype, "EndContact", box2d.b2ContactListener.prototype.EndContact);
box2d.b2ContactListener.prototype.PreSolve = function(a, b) {
};
goog.exportProperty(box2d.b2ContactListener.prototype, "PreSolve", box2d.b2ContactListener.prototype.PreSolve);
box2d.b2ContactListener.prototype.PostSolve = function(a, b) {
};
goog.exportProperty(box2d.b2ContactListener.prototype, "PostSolve", box2d.b2ContactListener.prototype.PostSolve);
box2d.b2ContactListener.b2_defaultListener = new box2d.b2ContactListener;
goog.exportProperty(box2d.b2ContactListener, "b2_defaultListener", box2d.b2ContactListener.b2_defaultListener);
box2d.b2QueryCallback = function() {
};
goog.exportSymbol("box2d.b2QueryCallback", box2d.b2QueryCallback);
box2d.b2QueryCallback.prototype.ReportFixture = function(a) {
    return!0
};
goog.exportProperty(box2d.b2QueryCallback.prototype, "ReportFixture", box2d.b2QueryCallback.prototype.ReportFixture);
box2d.b2RayCastCallback = function() {
};
goog.exportSymbol("box2d.b2RayCastCallback", box2d.b2RayCastCallback);
box2d.b2RayCastCallback.prototype.ReportFixture = function(a, b, c, e) {
    return e
};
goog.exportProperty(box2d.b2RayCastCallback.prototype, "ReportFixture", box2d.b2RayCastCallback.prototype.ReportFixture);
box2d.b2Island = function() {
    this.m_bodies = Array(1024);
    this.m_contacts = Array(1024);
    this.m_joints = Array(1024);
    this.m_positions = box2d.b2Position.MakeArray(1024);
    this.m_velocities = box2d.b2Velocity.MakeArray(1024)
};
goog.exportSymbol("box2d.b2Island", box2d.b2Island);
box2d.b2Island.prototype.m_allocator = null;
goog.exportProperty(box2d.b2Island.prototype, "m_allocator", box2d.b2Island.prototype.m_allocator);
box2d.b2Island.prototype.m_listener = null;
goog.exportProperty(box2d.b2Island.prototype, "m_listener", box2d.b2Island.prototype.m_listener);
box2d.b2Island.prototype.m_bodies = null;
goog.exportProperty(box2d.b2Island.prototype, "m_bodies", box2d.b2Island.prototype.m_bodies);
box2d.b2Island.prototype.m_contacts = null;
goog.exportProperty(box2d.b2Island.prototype, "m_contacts", box2d.b2Island.prototype.m_contacts);
box2d.b2Island.prototype.m_joints = null;
goog.exportProperty(box2d.b2Island.prototype, "m_joints", box2d.b2Island.prototype.m_joints);
box2d.b2Island.prototype.m_positions = null;
goog.exportProperty(box2d.b2Island.prototype, "m_positions", box2d.b2Island.prototype.m_positions);
box2d.b2Island.prototype.m_velocities = null;
goog.exportProperty(box2d.b2Island.prototype, "m_velocities", box2d.b2Island.prototype.m_velocities);
box2d.b2Island.prototype.m_bodyCount = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_bodyCount", box2d.b2Island.prototype.m_bodyCount);
box2d.b2Island.prototype.m_jointCount = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_jointCount", box2d.b2Island.prototype.m_jointCount);
box2d.b2Island.prototype.m_contactCount = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_contactCount", box2d.b2Island.prototype.m_contactCount);
box2d.b2Island.prototype.m_bodyCapacity = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_bodyCapacity", box2d.b2Island.prototype.m_bodyCapacity);
box2d.b2Island.prototype.m_contactCapacity = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_contactCapacity", box2d.b2Island.prototype.m_contactCapacity);
box2d.b2Island.prototype.m_jointCapacity = 0;
goog.exportProperty(box2d.b2Island.prototype, "m_jointCapacity", box2d.b2Island.prototype.m_jointCapacity);
box2d.b2Island.prototype.Initialize = function(a, b, c, e, d) {
    this.m_bodyCapacity = a;
    this.m_contactCapacity = b;
    this.m_jointCapacity = c;
    this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0;
    this.m_allocator = e;
    for (this.m_listener = d; this.m_bodies.length < a; )
        this.m_bodies[this.m_bodies.length] = null;
    for (; this.m_contacts.length < b; )
        this.m_contacts[this.m_contacts.length] = null;
    for (; this.m_joints.length < c; )
        this.m_joints[this.m_joints.length] = null;
    if (this.m_positions.length < a)
        for (b = box2d.b2Max(2 * this.m_positions.length,
                a), box2d.DEBUG && window.console.log("box2d.b2Island.m_positions: " + b); this.m_positions.length < b; )
            this.m_positions[this.m_positions.length] = new box2d.b2Position;
    if (this.m_velocities.length < a)
        for (b = box2d.b2Max(2 * this.m_velocities.length, a), box2d.DEBUG && window.console.log("box2d.b2Island.m_velocities: " + b); this.m_velocities.length < b; )
            this.m_velocities[this.m_velocities.length] = new box2d.b2Velocity
};
goog.exportProperty(box2d.b2Island.prototype, "Initialize", box2d.b2Island.prototype.Initialize);
box2d.b2Island.prototype.Clear = function() {
    this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0
};
goog.exportProperty(box2d.b2Island.prototype, "Clear", box2d.b2Island.prototype.Clear);
box2d.b2Island.prototype.AddBody = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_bodyCount < this.m_bodyCapacity);
    a.m_islandIndex = this.m_bodyCount;
    this.m_bodies[this.m_bodyCount++] = a
};
goog.exportProperty(box2d.b2Island.prototype, "AddBody", box2d.b2Island.prototype.AddBody);
box2d.b2Island.prototype.AddContact = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_contactCount < this.m_contactCapacity);
    this.m_contacts[this.m_contactCount++] = a
};
goog.exportProperty(box2d.b2Island.prototype, "AddContact", box2d.b2Island.prototype.AddContact);
box2d.b2Island.prototype.AddJoint = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_jointCount < this.m_jointCapacity);
    this.m_joints[this.m_jointCount++] = a
};
goog.exportProperty(box2d.b2Island.prototype, "AddJoint", box2d.b2Island.prototype.AddJoint);
box2d.b2Island.prototype.Solve = function(a, b, c, e) {
    for (var d = box2d.b2Island.s_timer.Reset(), f = b.dt, g = 0; g < this.m_bodyCount; ++g) {
        var h = this.m_bodies[g], l = this.m_positions[g].c.Copy(h.m_sweep.c), k = h.m_sweep.a, m = this.m_velocities[g].v.Copy(h.m_linearVelocity), n = h.m_angularVelocity;
        h.m_sweep.c0.Copy(h.m_sweep.c);
        h.m_sweep.a0 = h.m_sweep.a;
        h.m_type == box2d.b2BodyType.b2_dynamicBody && (m.x += f * (h.m_gravityScale * c.x + h.m_invMass * h.m_force.x), m.y += f * (h.m_gravityScale * c.y + h.m_invMass * h.m_force.y), n += f * h.m_invI * h.m_torque,
                m.SelfMul(box2d.b2Clamp(1 - f * h.m_linearDamping, 0, 1)), n *= box2d.b2Clamp(1 - f * h.m_angularDamping, 0, 1));
        this.m_positions[g].a = k;
        this.m_velocities[g].w = n
    }
    d.Reset();
    h = box2d.b2Island.s_solverData;
    h.step.Copy(b);
    h.positions = this.m_positions;
    h.velocities = this.m_velocities;
    g = box2d.b2Island.s_contactSolverDef;
    g.step.Copy(b);
    g.contacts = this.m_contacts;
    g.count = this.m_contactCount;
    g.positions = this.m_positions;
    g.velocities = this.m_velocities;
    g.allocator = this.m_allocator;
    c = box2d.b2Island.s_contactSolver.Initialize(g);
    c.InitializeVelocityConstraints();
    b.warmStarting && c.WarmStart();
    for (g = 0; g < this.m_jointCount; ++g)
        this.m_joints[g].InitVelocityConstraints(h);
    a.solveInit = d.GetMilliseconds();
    d.Reset();
    for (g = 0; g < b.velocityIterations; ++g) {
        for (k = 0; k < this.m_jointCount; ++k)
            this.m_joints[k].SolveVelocityConstraints(h);
        c.SolveVelocityConstraints()
    }
    c.StoreImpulses();
    a.solveVelocity = d.GetMilliseconds();
    for (g = 0; g < this.m_bodyCount; ++g) {
        var l = this.m_positions[g].c, k = this.m_positions[g].a, m = this.m_velocities[g].v, n = this.m_velocities[g].w,
                p = box2d.b2MulSV(f, m, box2d.b2Island.s_translation);
        box2d.b2DotVV(p, p) > box2d.b2_maxTranslationSquared && (p = box2d.b2_maxTranslation / p.GetLength(), m.SelfMul(p));
        p = f * n;
        p * p > box2d.b2_maxRotationSquared && (p = box2d.b2_maxRotation / box2d.b2Abs(p), n *= p);
        l.x += f * m.x;
        l.y += f * m.y;
        k += f * n;
        this.m_positions[g].a = k;
        this.m_velocities[g].w = n
    }
    d.Reset();
    l = !1;
    for (g = 0; g < b.positionIterations; ++g) {
        m = c.SolvePositionConstraints();
        n = !0;
        for (k = 0; k < this.m_jointCount; ++k)
            p = this.m_joints[k].SolvePositionConstraints(h), n = n && p;
        if (m && n) {
            l =
                    !0;
            break
        }
    }
    for (g = 0; g < this.m_bodyCount; ++g)
        b = this.m_bodies[g], b.m_sweep.c.Copy(this.m_positions[g].c), b.m_sweep.a = this.m_positions[g].a, b.m_linearVelocity.Copy(this.m_velocities[g].v), b.m_angularVelocity = this.m_velocities[g].w, b.SynchronizeTransform();
    a.solvePosition = d.GetMilliseconds();
    this.Report(c.m_velocityConstraints);
    if (e) {
        a = box2d.b2_maxFloat;
        e = box2d.b2_linearSleepTolerance * box2d.b2_linearSleepTolerance;
        d = box2d.b2_angularSleepTolerance * box2d.b2_angularSleepTolerance;
        for (g = 0; g < this.m_bodyCount; ++g)
            h =
                    this.m_bodies[g], h.GetType() != box2d.b2BodyType.b2_staticBody && (0 == (h.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) || h.m_angularVelocity * h.m_angularVelocity > d || box2d.b2DotVV(h.m_linearVelocity, h.m_linearVelocity) > e ? a = h.m_sleepTime = 0 : (h.m_sleepTime += f, a = box2d.b2Min(a, h.m_sleepTime)));
        if (a >= box2d.b2_timeToSleep && l)
            for (g = 0; g < this.m_bodyCount; ++g)
                h = this.m_bodies[g], h.SetAwake(!1)
    }
};
goog.exportProperty(box2d.b2Island.prototype, "Solve", box2d.b2Island.prototype.Solve);
box2d.b2Island.prototype.SolveTOI = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(b < this.m_bodyCount);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(c < this.m_bodyCount);
    for (var e = 0; e < this.m_bodyCount; ++e) {
        var d = this.m_bodies[e];
        this.m_positions[e].c.Copy(d.m_sweep.c);
        this.m_positions[e].a = d.m_sweep.a;
        this.m_velocities[e].v.Copy(d.m_linearVelocity);
        this.m_velocities[e].w = d.m_angularVelocity
    }
    e = box2d.b2Island.s_contactSolverDef;
    e.contacts = this.m_contacts;
    e.count = this.m_contactCount;
    e.allocator = this.m_allocator;
    e.step.Copy(a);
    e.positions = this.m_positions;
    e.velocities = this.m_velocities;
    d = box2d.b2Island.s_contactSolver.Initialize(e);
    for (e = 0; e < a.positionIterations && !d.SolveTOIPositionConstraints(b, c); ++e)
        ;
    this.m_bodies[b].m_sweep.c0.Copy(this.m_positions[b].c);
    this.m_bodies[b].m_sweep.a0 = this.m_positions[b].a;
    this.m_bodies[c].m_sweep.c0.Copy(this.m_positions[c].c);
    this.m_bodies[c].m_sweep.a0 = this.m_positions[c].a;
    d.InitializeVelocityConstraints();
    for (e = 0; e < a.velocityIterations; ++e)
        d.SolveVelocityConstraints();
    a = a.dt;
    for (e = 0; e < this.m_bodyCount; ++e) {
        b = this.m_positions[e].c;
        c = this.m_positions[e].a;
        var f = this.m_velocities[e].v, g = this.m_velocities[e].w, h = box2d.b2MulSV(a, f, box2d.b2Island.s_translation);
        box2d.b2DotVV(h, h) > box2d.b2_maxTranslationSquared && (h = box2d.b2_maxTranslation / h.GetLength(), f.SelfMul(h));
        h = a * g;
        h * h > box2d.b2_maxRotationSquared && (h = box2d.b2_maxRotation / box2d.b2Abs(h), g *= h);
        b.SelfMulAdd(a, f);
        c += a * g;
        this.m_positions[e].a = c;
        this.m_velocities[e].w = g;
        h = this.m_bodies[e];
        h.m_sweep.c.Copy(b);
        h.m_sweep.a =
                c;
        h.m_linearVelocity.Copy(f);
        h.m_angularVelocity = g;
        h.SynchronizeTransform()
    }
    this.Report(d.m_velocityConstraints)
};
goog.exportProperty(box2d.b2Island.prototype, "SolveTOI", box2d.b2Island.prototype.SolveTOI);
box2d.b2Island.prototype.Report = function(a) {
    if (null != this.m_listener)
        for (var b = 0; b < this.m_contactCount; ++b) {
            var c = this.m_contacts[b];
            if (c) {
                var e = a[b], d = box2d.b2Island.s_impulse;
                d.count = e.pointCount;
                for (var f = 0; f < e.pointCount; ++f)
                    d.normalImpulses[f] = e.points[f].normalImpulse, d.tangentImpulses[f] = e.points[f].tangentImpulse;
                this.m_listener.PostSolve(c, d)
            }
        }
};
goog.exportProperty(box2d.b2Island.prototype, "Report", box2d.b2Island.prototype.Report);
box2d.b2Island.s_timer = new box2d.b2Timer;
box2d.b2Island.s_solverData = new box2d.b2SolverData;
box2d.b2Island.s_contactSolverDef = new box2d.b2ContactSolverDef;
box2d.b2Island.s_contactSolver = new box2d.b2ContactSolver;
box2d.b2Island.s_translation = new box2d.b2Vec2;
box2d.b2Island.s_impulse = new box2d.b2ContactImpulse;
box2d.b2ContactRegister = function() {
};
goog.exportSymbol("box2d.b2ContactRegister", box2d.b2ContactRegister);
box2d.b2ContactRegister.prototype.createFcn = null;
box2d.b2ContactRegister.prototype.destroyFcn = null;
box2d.b2ContactRegister.prototype.primary = !1;
box2d.b2ContactFactory = function(a) {
    this.m_allocator = a;
    this.InitializeRegisters()
};
goog.exportSymbol("box2d.b2ContactFactory", box2d.b2ContactFactory);
box2d.b2ContactFactory.prototype.m_allocator = null;
box2d.b2ContactFactory.prototype.AddType = function(a, b, c, e) {
    var d = box2d.b2MakeArray(256, function(b) {
        return a()
    });
    b = function(b) {
        return 0 < d.length ? d.pop() : a(b)
    };
    var f = function(a, b) {
        d.push(a)
    };
    this.m_registers[c][e].pool = d;
    this.m_registers[c][e].createFcn = b;
    this.m_registers[c][e].destroyFcn = f;
    this.m_registers[c][e].primary = !0;
    c != e && (this.m_registers[e][c].pool = d, this.m_registers[e][c].createFcn = b, this.m_registers[e][c].destroyFcn = f, this.m_registers[e][c].primary = !1)
};
goog.exportProperty(box2d.b2ContactFactory.prototype, "AddType", box2d.b2ContactFactory.prototype.AddType);
box2d.b2ContactFactory.prototype.InitializeRegisters = function() {
    this.m_registers = Array(box2d.b2ShapeType.e_shapeTypeCount);
    for (var a = 0; a < box2d.b2ShapeType.e_shapeTypeCount; a++) {
        this.m_registers[a] = Array(box2d.b2ShapeType.e_shapeTypeCount);
        for (var b = 0; b < box2d.b2ShapeType.e_shapeTypeCount; b++)
            this.m_registers[a][b] = new box2d.b2ContactRegister
    }
    this.AddType(box2d.b2CircleContact.Create, box2d.b2CircleContact.Destroy, box2d.b2ShapeType.e_circleShape, box2d.b2ShapeType.e_circleShape);
    this.AddType(box2d.b2PolygonAndCircleContact.Create,
            box2d.b2PolygonAndCircleContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_circleShape);
    this.AddType(box2d.b2PolygonContact.Create, box2d.b2PolygonContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_polygonShape);
    this.AddType(box2d.b2EdgeAndCircleContact.Create, box2d.b2EdgeAndCircleContact.Destroy, box2d.b2ShapeType.e_edgeShape, box2d.b2ShapeType.e_circleShape);
    this.AddType(box2d.b2EdgeAndPolygonContact.Create, box2d.b2EdgeAndPolygonContact.Destroy, box2d.b2ShapeType.e_edgeShape,
            box2d.b2ShapeType.e_polygonShape);
    this.AddType(box2d.b2ChainAndCircleContact.Create, box2d.b2ChainAndCircleContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_circleShape);
    this.AddType(box2d.b2ChainAndPolygonContact.Create, box2d.b2ChainAndPolygonContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_polygonShape)
};
goog.exportProperty(box2d.b2ContactFactory.prototype, "InitializeRegisters", box2d.b2ContactFactory.prototype.InitializeRegisters);
box2d.b2ContactFactory.prototype.Create = function(a, b, c, e) {
    var d = a.GetType(), f = c.GetType();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= d && d < box2d.b2ShapeType.e_shapeTypeCount);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= f && f < box2d.b2ShapeType.e_shapeTypeCount);
    d = this.m_registers[d][f];
    f = d.createFcn;
    return null != f ? (d.primary ? (d = f(this.m_allocator), d.Reset(a, b, c, e)) : (d = f(this.m_allocator), d.Reset(c, e, a, b)), d) : null
};
goog.exportProperty(box2d.b2ContactFactory.prototype, "Create", box2d.b2ContactFactory.prototype.Create);
box2d.b2ContactFactory.prototype.Destroy = function(a) {
    var b = a.m_fixtureA, c = a.m_fixtureB;
    0 < a.m_manifold.pointCount && (!1 == b.IsSensor() && !1 == c.IsSensor()) && (b.GetBody().SetAwake(!0), c.GetBody().SetAwake(!0));
    b = b.GetType();
    c = c.GetType();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= b && c < box2d.b2ShapeType.e_shapeTypeCount);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= b && c < box2d.b2ShapeType.e_shapeTypeCount);
    c = this.m_registers[b][c].destroyFcn;
    c(a, this.m_allocator)
};
goog.exportProperty(box2d.b2ContactFactory.prototype, "Destroy", box2d.b2ContactFactory.prototype.Destroy);
box2d.b2GrowableStack = function(a) {
    this.m_stack = Array(a)
};
goog.exportSymbol("box2d.b2GrowableStack", box2d.b2GrowableStack);
box2d.b2GrowableStack.prototype.m_stack = null;
goog.exportProperty(box2d.b2GrowableStack.prototype, "m_stack", box2d.b2GrowableStack.prototype.m_stack);
box2d.b2GrowableStack.prototype.m_count = 0;
goog.exportProperty(box2d.b2GrowableStack.prototype, "m_count", box2d.b2GrowableStack.prototype.m_count);
box2d.b2GrowableStack.prototype.Reset = function() {
    this.m_count = 0;
    return this
};
goog.exportProperty(box2d.b2GrowableStack.prototype, "Reset", box2d.b2GrowableStack.prototype.Reset);
box2d.b2GrowableStack.prototype.Push = function(a) {
    this.m_stack[this.m_count] = a;
    ++this.m_count
};
goog.exportProperty(box2d.b2GrowableStack.prototype, "Push", box2d.b2GrowableStack.prototype.Push);
box2d.b2GrowableStack.prototype.Pop = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_count);
    --this.m_count;
    var a = this.m_stack[this.m_count];
    this.m_stack[this.m_count] = null;
    return a
};
goog.exportProperty(box2d.b2GrowableStack.prototype, "Pop", box2d.b2GrowableStack.prototype.Pop);
box2d.b2GrowableStack.prototype.GetCount = function() {
    return this.m_count
};
goog.exportProperty(box2d.b2GrowableStack.prototype, "GetCount", box2d.b2GrowableStack.prototype.GetCount);
box2d.b2TreeNode = function(a) {
    this.m_id = a || 0;
    this.aabb = new box2d.b2AABB
};
goog.exportSymbol("box2d.b2TreeNode", box2d.b2TreeNode);
box2d.b2TreeNode.prototype.m_id = 0;
goog.exportProperty(box2d.b2TreeNode.prototype, "m_id", box2d.b2TreeNode.prototype.m_id);
box2d.b2TreeNode.prototype.aabb = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "aabb", box2d.b2TreeNode.prototype.aabb);
box2d.b2TreeNode.prototype.userData = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "userData", box2d.b2TreeNode.prototype.userData);
box2d.b2TreeNode.prototype.parent = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "parent", box2d.b2TreeNode.prototype.parent);
box2d.b2TreeNode.prototype.child1 = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "child1", box2d.b2TreeNode.prototype.child1);
box2d.b2TreeNode.prototype.child2 = null;
goog.exportProperty(box2d.b2TreeNode.prototype, "child2", box2d.b2TreeNode.prototype.child2);
box2d.b2TreeNode.prototype.height = 0;
goog.exportProperty(box2d.b2TreeNode.prototype, "height", box2d.b2TreeNode.prototype.height);
box2d.b2TreeNode.prototype.IsLeaf = function() {
    return null == this.child1
};
goog.exportProperty(box2d.b2TreeNode.prototype, "IsLeaf", box2d.b2TreeNode.prototype.IsLeaf);
box2d.b2DynamicTree = function() {
};
goog.exportSymbol("box2d.b2DynamicTree", box2d.b2DynamicTree);
box2d.b2DynamicTree.prototype.m_root = null;
goog.exportProperty(box2d.b2DynamicTree.prototype, "m_root", box2d.b2DynamicTree.prototype.m_root);
box2d.b2DynamicTree.prototype.m_freeList = null;
goog.exportProperty(box2d.b2DynamicTree.prototype, "m_freeList", box2d.b2DynamicTree.prototype.m_freeList);
box2d.b2DynamicTree.prototype.m_path = 0;
goog.exportProperty(box2d.b2DynamicTree.prototype, "m_path", box2d.b2DynamicTree.prototype.m_path);
box2d.b2DynamicTree.prototype.m_insertionCount = 0;
goog.exportProperty(box2d.b2DynamicTree.prototype, "m_insertionCount", box2d.b2DynamicTree.prototype.m_insertionCount);
box2d.b2DynamicTree.s_stack = new box2d.b2GrowableStack(256);
box2d.b2DynamicTree.s_r = new box2d.b2Vec2;
box2d.b2DynamicTree.s_v = new box2d.b2Vec2;
box2d.b2DynamicTree.s_abs_v = new box2d.b2Vec2;
box2d.b2DynamicTree.s_segmentAABB = new box2d.b2AABB;
box2d.b2DynamicTree.s_subInput = new box2d.b2RayCastInput;
box2d.b2DynamicTree.s_combinedAABB = new box2d.b2AABB;
box2d.b2DynamicTree.s_aabb = new box2d.b2AABB;
box2d.b2DynamicTree.prototype.GetUserData = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null != a);
    return a.userData
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetUserData", box2d.b2DynamicTree.prototype.GetUserData);
box2d.b2DynamicTree.prototype.GetFatAABB = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null != a);
    return a.aabb
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetFatAABB", box2d.b2DynamicTree.prototype.GetFatAABB);
box2d.b2DynamicTree.prototype.Query = function(a, b) {
    if (null != this.m_root) {
        var c = box2d.b2DynamicTree.s_stack.Reset();
        for (c.Push(this.m_root); 0 < c.GetCount(); ) {
            var e = c.Pop();
            if (null != e && e.aabb.TestOverlap(b))
                if (e.IsLeaf()) {
                    if (!1 == a(e))
                        break
                } else
                    c.Push(e.child1), c.Push(e.child2)
        }
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "Query", box2d.b2DynamicTree.prototype.Query);
box2d.b2DynamicTree.prototype.RayCast = function(a, b) {
    if (null != this.m_root) {
        var c = b.p1, e = b.p2, d = box2d.b2SubVV(e, c, box2d.b2DynamicTree.s_r);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < d.GetLengthSquared());
        d.Normalize();
        var d = box2d.b2CrossOneV(d, box2d.b2DynamicTree.s_v), f = box2d.b2AbsV(d, box2d.b2DynamicTree.s_abs_v), g = b.maxFraction, h = box2d.b2DynamicTree.s_segmentAABB, l = c.x + g * (e.x - c.x), k = c.y + g * (e.y - c.y);
        h.lowerBound.x = box2d.b2Min(c.x, l);
        h.lowerBound.y = box2d.b2Min(c.y, k);
        h.upperBound.x = box2d.b2Max(c.x, l);
        h.upperBound.y =
                box2d.b2Max(c.y, k);
        var m = box2d.b2DynamicTree.s_stack.Reset();
        for (m.Push(this.m_root); 0 < m.GetCount(); )
            if (l = m.Pop(), null != l && !1 != box2d.b2TestOverlapAABB(l.aabb, h)) {
                var k = l.aabb.GetCenter(), n = l.aabb.GetExtents();
                if (!(0 < box2d.b2Abs(box2d.b2DotVV(d, box2d.b2SubVV(c, k, box2d.b2Vec2.s_t0))) - box2d.b2DotVV(f, n)))
                    if (l.IsLeaf()) {
                        k = box2d.b2DynamicTree.s_subInput;
                        k.p1.Copy(b.p1);
                        k.p2.Copy(b.p2);
                        k.maxFraction = g;
                        l = a(k, l);
                        if (0 == l)
                            break;
                        0 < l && (g = l, l = c.x + g * (e.x - c.x), k = c.y + g * (e.y - c.y), h.lowerBound.x = box2d.b2Min(c.x, l),
                                h.lowerBound.y = box2d.b2Min(c.y, k), h.upperBound.x = box2d.b2Max(c.x, l), h.upperBound.y = box2d.b2Max(c.y, k))
                    } else
                        m.Push(l.child1), m.Push(l.child2)
            }
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "RayCast", box2d.b2DynamicTree.prototype.RayCast);
box2d.b2DynamicTree.prototype.AllocateNode = function() {
    if (this.m_freeList) {
        var a = this.m_freeList;
        this.m_freeList = a.parent;
        a.parent = null;
        a.child1 = null;
        a.child2 = null;
        a.height = 0;
        a.userData = null;
        return a
    }
    return new box2d.b2TreeNode(box2d.b2DynamicTree.prototype.s_node_id++)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "AllocateNode", box2d.b2DynamicTree.prototype.AllocateNode);
box2d.b2DynamicTree.prototype.s_node_id = 0;
box2d.b2DynamicTree.prototype.FreeNode = function(a) {
    a.parent = this.m_freeList;
    a.height = -1;
    this.m_freeList = a
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "FreeNode", box2d.b2DynamicTree.prototype.FreeNode);
box2d.b2DynamicTree.prototype.CreateProxy = function(a, b) {
    var c = this.AllocateNode(), e = box2d.b2_aabbExtension, d = box2d.b2_aabbExtension;
    c.aabb.lowerBound.x = a.lowerBound.x - e;
    c.aabb.lowerBound.y = a.lowerBound.y - d;
    c.aabb.upperBound.x = a.upperBound.x + e;
    c.aabb.upperBound.y = a.upperBound.y + d;
    c.userData = b;
    c.height = 0;
    this.InsertLeaf(c);
    return c
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "CreateProxy", box2d.b2DynamicTree.prototype.CreateProxy);
box2d.b2DynamicTree.prototype.DestroyProxy = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.IsLeaf());
    this.RemoveLeaf(a);
    this.FreeNode(a)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "DestroyProxy", box2d.b2DynamicTree.prototype.DestroyProxy);
box2d.b2DynamicTree.prototype.MoveProxy = function(a, b, c) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.IsLeaf());
    if (a.aabb.Contains(b))
        return!1;
    this.RemoveLeaf(a);
    var e = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (0 < c.x ? c.x : -c.x);
    c = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (0 < c.y ? c.y : -c.y);
    a.aabb.lowerBound.x = b.lowerBound.x - e;
    a.aabb.lowerBound.y = b.lowerBound.y - c;
    a.aabb.upperBound.x = b.upperBound.x + e;
    a.aabb.upperBound.y = b.upperBound.y + c;
    this.InsertLeaf(a);
    return!0
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "MoveProxy", box2d.b2DynamicTree.prototype.MoveProxy);
box2d.b2DynamicTree.prototype.InsertLeaf = function(a) {
    ++this.m_insertionCount;
    if (null == this.m_root)
        this.m_root = a, this.m_root.parent = null;
    else {
        var b = a.aabb;
        b.GetCenter();
        for (var c = this.m_root, e, d; !1 == c.IsLeaf(); ) {
            e = c.child1;
            d = c.child2;
            var f = c.aabb.GetPerimeter(), g = box2d.b2DynamicTree.s_combinedAABB;
            g.Combine2(c.aabb, b);
            var h = g.GetPerimeter(), g = 2 * h, h = 2 * (h - f), l = box2d.b2DynamicTree.s_aabb, k, m;
            e.IsLeaf() ? (l.Combine2(b, e.aabb), f = l.GetPerimeter() + h) : (l.Combine2(b, e.aabb), k = e.aabb.GetPerimeter(), m = l.GetPerimeter(),
                    f = m - k + h);
            d.IsLeaf() ? (l.Combine2(b, d.aabb), h = l.GetPerimeter() + h) : (l.Combine2(b, d.aabb), k = d.aabb.GetPerimeter(), m = l.GetPerimeter(), h = m - k + h);
            if (g < f && g < h)
                break;
            c = f < h ? e : d
        }
        e = c.parent;
        d = this.AllocateNode();
        d.parent = e;
        d.userData = null;
        d.aabb.Combine2(b, c.aabb);
        d.height = c.height + 1;
        e ? (e.child1 == c ? e.child1 = d : e.child2 = d, d.child1 = c, d.child2 = a, c.parent = d, a.parent = d) : (d.child1 = c, d.child2 = a, c.parent = d, this.m_root = a.parent = d);
        for (c = a.parent; null != c; )
            c = this.Balance(c), e = c.child1, d = c.child2, box2d.ENABLE_ASSERTS && box2d.b2Assert(null !=
                    e), box2d.ENABLE_ASSERTS && box2d.b2Assert(null != d), c.height = 1 + box2d.b2Max(e.height, d.height), c.aabb.Combine2(e.aabb, d.aabb), c = c.parent
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "InsertLeaf", box2d.b2DynamicTree.prototype.InsertLeaf);
box2d.b2DynamicTree.prototype.RemoveLeaf = function(a) {
    if (a == this.m_root)
        this.m_root = null;
    else {
        var b = a.parent, c = b.parent;
        a = b.child1 == a ? b.child2 : b.child1;
        if (c)
            for (c.child1 == b?c.child1 = a:c.child2 = a, a.parent = c, this.FreeNode(b), b = c; b; )
                b = this.Balance(b), c = b.child1, a = b.child2, b.aabb.Combine2(c.aabb, a.aabb), b.height = 1 + box2d.b2Max(c.height, a.height), b = b.parent;
        else
            this.m_root = a, a.parent = null, this.FreeNode(b)
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "RemoveLeaf", box2d.b2DynamicTree.prototype.RemoveLeaf);
box2d.b2DynamicTree.prototype.Balance = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null != a);
    if (a.IsLeaf() || 2 > a.height)
        return a;
    var b = a.child1, c = a.child2, e = c.height - b.height;
    if (1 < e) {
        var e = c.child1, d = c.child2;
        c.child1 = a;
        c.parent = a.parent;
        a.parent = c;
        null != c.parent ? c.parent.child1 == a ? c.parent.child1 = c : (box2d.ENABLE_ASSERTS && box2d.b2Assert(c.parent.child2 == a), c.parent.child2 = c) : this.m_root = c;
        e.height > d.height ? (c.child2 = e, a.child2 = d, d.parent = a, a.aabb.Combine2(b.aabb, d.aabb), c.aabb.Combine2(a.aabb, e.aabb),
                a.height = 1 + box2d.b2Max(b.height, d.height), c.height = 1 + box2d.b2Max(a.height, e.height)) : (c.child2 = d, a.child2 = e, e.parent = a, a.aabb.Combine2(b.aabb, e.aabb), c.aabb.Combine2(a.aabb, d.aabb), a.height = 1 + box2d.b2Max(b.height, e.height), c.height = 1 + box2d.b2Max(a.height, d.height));
        return c
    }
    return-1 > e ? (e = b.child1, d = b.child2, b.child1 = a, b.parent = a.parent, a.parent = b, null != b.parent ? b.parent.child1 == a ? b.parent.child1 = b : (box2d.ENABLE_ASSERTS && box2d.b2Assert(b.parent.child2 == a), b.parent.child2 = b) : this.m_root = b, e.height >
            d.height ? (b.child2 = e, a.child1 = d, d.parent = a, a.aabb.Combine2(c.aabb, d.aabb), b.aabb.Combine2(a.aabb, e.aabb), a.height = 1 + box2d.b2Max(c.height, d.height), b.height = 1 + box2d.b2Max(a.height, e.height)) : (b.child2 = d, a.child1 = e, e.parent = a, a.aabb.Combine2(c.aabb, e.aabb), b.aabb.Combine2(a.aabb, d.aabb), a.height = 1 + box2d.b2Max(c.height, e.height), b.height = 1 + box2d.b2Max(a.height, d.height)), b) : a
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "Balance", box2d.b2DynamicTree.prototype.Balance);
box2d.b2DynamicTree.prototype.GetHeight = function() {
    return null == this.m_root ? 0 : this.m_root.height
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetHeight", box2d.b2DynamicTree.prototype.GetHeight);
box2d.b2DynamicTree.prototype.GetAreaRatio = function() {
    if (null == this.m_root)
        return 0;
    var a = this.m_root.aabb.GetPerimeter(), b = function(a) {
        if (null == a || a.IsLeaf())
            return 0;
        var e = a.aabb.GetPerimeter(), e = e + b(a.child1);
        return e += b(a.child2)
    };
    return b(this.m_root) / a
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetAreaRatio", box2d.b2DynamicTree.prototype.GetAreaRatio);
box2d.b2DynamicTree.prototype.ComputeHeightNode = function(a) {
    if (a.IsLeaf())
        return 0;
    var b = this.ComputeHeightNode(a.child1);
    a = this.ComputeHeightNode(a.child2);
    return 1 + box2d.b2Max(b, a)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ComputeHeightNode", box2d.b2DynamicTree.prototype.ComputeHeightNode);
box2d.b2DynamicTree.prototype.ComputeHeight = function() {
    return this.ComputeHeightNode(this.m_root)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ComputeHeight", box2d.b2DynamicTree.prototype.ComputeHeight);
box2d.b2DynamicTree.prototype.ValidateStructure = function(a) {
    if (null != a) {
        a == this.m_root && box2d.ENABLE_ASSERTS && box2d.b2Assert(null == a.parent);
        var b = a.child1, c = a.child2;
        a.IsLeaf() ? (box2d.ENABLE_ASSERTS && box2d.b2Assert(null == b), box2d.ENABLE_ASSERTS && box2d.b2Assert(null == c), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 == a.height)) : (box2d.ENABLE_ASSERTS && box2d.b2Assert(b.parent == a), box2d.ENABLE_ASSERTS && box2d.b2Assert(c.parent == a), this.ValidateStructure(b), this.ValidateStructure(c))
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ValidateStructure", box2d.b2DynamicTree.prototype.ValidateStructure);
box2d.b2DynamicTree.prototype.ValidateMetrics = function(a) {
    if (null != a) {
        var b = a.child1, c = a.child2;
        if (a.IsLeaf())
            box2d.ENABLE_ASSERTS && box2d.b2Assert(null == b), box2d.ENABLE_ASSERTS && box2d.b2Assert(null == c), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 == a.height);
        else {
            var e;
            e = 1 + box2d.b2Max(b.height, c.height);
            box2d.ENABLE_ASSERTS && box2d.b2Assert(a.height == e);
            e = box2d.b2DynamicTree.s_aabb;
            e.Combine2(b.aabb, c.aabb);
            box2d.ENABLE_ASSERTS && box2d.b2Assert(e.lowerBound == a.aabb.lowerBound);
            box2d.ENABLE_ASSERTS && box2d.b2Assert(e.upperBound ==
                    a.aabb.upperBound);
            this.ValidateMetrics(b);
            this.ValidateMetrics(c)
        }
    }
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ValidateMetrics", box2d.b2DynamicTree.prototype.ValidateMetrics);
box2d.b2DynamicTree.prototype.Validate = function() {
    this.ValidateStructure(this.m_root);
    this.ValidateMetrics(this.m_root);
    for (var a = 0, b = this.m_freeList; null != b; )
        b = b.parent, ++a;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.GetHeight() == this.ComputeHeight())
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "Validate", box2d.b2DynamicTree.prototype.Validate);
box2d.b2DynamicTree.prototype.GetMaxBalance = function() {
    var a;
    a = this.m_root;
    null == a ? a = 0 : 1 >= a.height ? a = 0 : (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == a.IsLeaf()), a = box2d.b2Abs(a.child2.height - a.child1.height), a = box2d.b2Max(0, a));
    return a
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "GetMaxBalance", box2d.b2DynamicTree.prototype.GetMaxBalance);
box2d.b2DynamicTree.prototype.RebuildBottomUp = function() {
    this.Validate()
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "RebuildBottomUp", box2d.b2DynamicTree.prototype.RebuildBottomUp);
box2d.b2DynamicTree.prototype.ShiftOrigin = function(a) {
    var b = function(a, e) {
        if (null != a && !(1 >= a.height)) {
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == a.IsLeaf());
            var d = a.child2;
            b(a.child1, e);
            b(d, e);
            a.aabb.lowerBound.SelfSub(e);
            a.aabb.upperBound.SelfSub(e)
        }
    };
    b(this.m_root, a)
};
goog.exportProperty(box2d.b2DynamicTree.prototype, "ShiftOrigin", box2d.b2DynamicTree.prototype.ShiftOrigin);
box2d.b2Pair = function() {
};
goog.exportSymbol("box2d.b2Pair", box2d.b2Pair);
box2d.b2Pair.prototype.proxyA = null;
goog.exportProperty(box2d.b2Pair.prototype, "proxyA", box2d.b2Pair.prototype.proxyA);
box2d.b2Pair.prototype.proxyB = null;
goog.exportProperty(box2d.b2Pair.prototype, "proxyB", box2d.b2Pair.prototype.proxyB);
box2d.b2BroadPhase = function() {
    this.m_tree = new box2d.b2DynamicTree;
    this.m_moveBuffer = [];
    this.m_pairBuffer = []
};
goog.exportSymbol("box2d.b2BroadPhase", box2d.b2BroadPhase);
box2d.b2BroadPhase.prototype.m_tree = null;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_tree", box2d.b2BroadPhase.prototype.m_tree);
box2d.b2BroadPhase.prototype.m_proxyCount = 0;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_proxyCount", box2d.b2BroadPhase.prototype.m_proxyCount);
box2d.b2BroadPhase.prototype.m_moveCount = 0;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_moveCount", box2d.b2BroadPhase.prototype.m_moveCount);
box2d.b2BroadPhase.prototype.m_moveBuffer = null;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_moveBuffer", box2d.b2BroadPhase.prototype.m_moveBuffer);
box2d.b2BroadPhase.prototype.m_pairCount = 0;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_pairCount", box2d.b2BroadPhase.prototype.m_pairCount);
box2d.b2BroadPhase.prototype.m_pairBuffer = null;
goog.exportProperty(box2d.b2BroadPhase.prototype, "m_pairBuffer", box2d.b2BroadPhase.prototype.m_pairBuffer);
box2d.b2BroadPhase.prototype.CreateProxy = function(a, b) {
    var c = this.m_tree.CreateProxy(a, b);
    ++this.m_proxyCount;
    this.BufferMove(c);
    return c
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "CreateProxy", box2d.b2BroadPhase.prototype.CreateProxy);
box2d.b2BroadPhase.prototype.DestroyProxy = function(a) {
    this.UnBufferMove(a);
    --this.m_proxyCount;
    this.m_tree.DestroyProxy(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "DestroyProxy", box2d.b2BroadPhase.prototype.DestroyProxy);
box2d.b2BroadPhase.prototype.MoveProxy = function(a, b, c) {
    this.m_tree.MoveProxy(a, b, c) && this.BufferMove(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "MoveProxy", box2d.b2BroadPhase.prototype.MoveProxy);
box2d.b2BroadPhase.prototype.TouchProxy = function(a) {
    this.BufferMove(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "TouchProxy", box2d.b2BroadPhase.prototype.TouchProxy);
box2d.b2BroadPhase.prototype.GetFatAABB = function(a) {
    return this.m_tree.GetFatAABB(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetFatAABB", box2d.b2BroadPhase.prototype.GetFatAABB);
box2d.b2BroadPhase.prototype.GetUserData = function(a) {
    return this.m_tree.GetUserData(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetUserData", box2d.b2BroadPhase.prototype.GetUserData);
box2d.b2BroadPhase.prototype.TestOverlap = function(a, b) {
    var c = this.m_tree.GetFatAABB(a), e = this.m_tree.GetFatAABB(b);
    return box2d.b2TestOverlapAABB(c, e)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "TestOverlap", box2d.b2BroadPhase.prototype.TestOverlap);
box2d.b2BroadPhase.prototype.GetProxyCount = function() {
    return this.m_proxyCount
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetProxyCount", box2d.b2BroadPhase.prototype.GetProxyCount);
box2d.b2BroadPhase.prototype.GetTreeHeight = function() {
    return this.m_tree.GetHeight()
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetTreeHeight", box2d.b2BroadPhase.prototype.GetTreeHeight);
box2d.b2BroadPhase.prototype.GetTreeBalance = function() {
    return this.m_tree.GetMaxBalance()
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetTreeBalance", box2d.b2BroadPhase.prototype.GetTreeBalance);
box2d.b2BroadPhase.prototype.GetTreeQuality = function() {
    return this.m_tree.GetAreaRatio()
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "GetTreeQuality", box2d.b2BroadPhase.prototype.GetTreeQuality);
box2d.b2BroadPhase.prototype.ShiftOrigin = function(a) {
    this.m_tree.ShiftOrigin(a)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "ShiftOrigin", box2d.b2BroadPhase.prototype.ShiftOrigin);
box2d.b2BroadPhase.prototype.UpdatePairs = function(a) {
    for (var b = this.m_pairCount = 0; b < this.m_moveCount; ++b) {
        var c = this.m_moveBuffer[b];
        if (null != c) {
            var e = this, d = this.m_tree.GetFatAABB(c);
            this.m_tree.Query(function(a) {
                if (a.m_id == c.m_id)
                    return!0;
                e.m_pairCount == e.m_pairBuffer.length && (e.m_pairBuffer[e.m_pairCount] = new box2d.b2Pair);
                var b = e.m_pairBuffer[e.m_pairCount];
                a.m_id < c.m_id ? (b.proxyA = a, b.proxyB = c) : (b.proxyA = c, b.proxyB = a);
                ++e.m_pairCount;
                return!0
            }, d)
        }
    }
    this.m_moveCount = 0;
    this.m_pairBuffer.length = this.m_pairCount;
    this.m_pairBuffer.sort(box2d.b2PairLessThan);
    for (b = 0; b < this.m_pairCount; ) {
        var d = this.m_pairBuffer[b], f = this.m_tree.GetUserData(d.proxyA), g = this.m_tree.GetUserData(d.proxyB);
        a.AddPair(f, g);
        for (++b; b < this.m_pairCount; ) {
            f = this.m_pairBuffer[b];
            if (f.proxyA.m_id != d.proxyA.m_id || f.proxyB.m_id != d.proxyB.m_id)
                break;
            ++b
        }
    }
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "UpdatePairs", box2d.b2BroadPhase.prototype.UpdatePairs);
box2d.b2BroadPhase.prototype.Query = function(a, b) {
    this.m_tree.Query(a, b)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "Query", box2d.b2BroadPhase.prototype.Query);
box2d.b2BroadPhase.prototype.RayCast = function(a, b) {
    this.m_tree.RayCast(a, b)
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "RayCast", box2d.b2BroadPhase.prototype.RayCast);
box2d.b2BroadPhase.prototype.BufferMove = function(a) {
    this.m_moveBuffer[this.m_moveCount] = a;
    ++this.m_moveCount
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "BufferMove", box2d.b2BroadPhase.prototype.BufferMove);
box2d.b2BroadPhase.prototype.UnBufferMove = function(a) {
    a = this.m_moveBuffer.indexOf(a);
    this.m_moveBuffer[a] = null
};
goog.exportProperty(box2d.b2BroadPhase.prototype, "UnBufferMove", box2d.b2BroadPhase.prototype.UnBufferMove);
box2d.b2PairLessThan = function(a, b) {
    return a.proxyA.m_id == b.proxyA.m_id ? a.proxyB.m_id - b.proxyB.m_id : a.proxyA.m_id - b.proxyA.m_id
};
box2d.b2ContactManager = function() {
    this.m_broadPhase = new box2d.b2BroadPhase;
    this.m_contactFactory = new box2d.b2ContactFactory(this.m_allocator)
};
box2d.b2ContactManager.prototype.m_broadPhase = null;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_broadPhase", box2d.b2ContactManager.prototype.m_broadPhase);
box2d.b2ContactManager.prototype.m_contactList = null;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactList", box2d.b2ContactManager.prototype.m_contactList);
box2d.b2ContactManager.prototype.m_contactCount = 0;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactCount", box2d.b2ContactManager.prototype.m_contactCount);
box2d.b2ContactManager.prototype.m_contactFilter = box2d.b2ContactFilter.b2_defaultFilter;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactFilter", box2d.b2ContactManager.prototype.m_contactFilter);
box2d.b2ContactManager.prototype.m_contactListener = box2d.b2ContactListener.b2_defaultListener;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactListener", box2d.b2ContactManager.prototype.m_contactListener);
box2d.b2ContactManager.prototype.m_allocator = null;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_allocator", box2d.b2ContactManager.prototype.m_allocator);
box2d.b2ContactManager.prototype.m_contactFactory = null;
goog.exportSymbol("box2d.b2ContactManager.prototype.m_contactFactory", box2d.b2ContactManager.prototype.m_contactFactory);
box2d.b2ContactManager.prototype.Destroy = function(a) {
    var b = a.GetFixtureA(), c = a.GetFixtureB(), b = b.GetBody(), c = c.GetBody();
    this.m_contactListener && a.IsTouching() && this.m_contactListener.EndContact(a);
    a.m_prev && (a.m_prev.m_next = a.m_next);
    a.m_next && (a.m_next.m_prev = a.m_prev);
    a == this.m_contactList && (this.m_contactList = a.m_next);
    a.m_nodeA.prev && (a.m_nodeA.prev.next = a.m_nodeA.next);
    a.m_nodeA.next && (a.m_nodeA.next.prev = a.m_nodeA.prev);
    a.m_nodeA == b.m_contactList && (b.m_contactList = a.m_nodeA.next);
    a.m_nodeB.prev &&
            (a.m_nodeB.prev.next = a.m_nodeB.next);
    a.m_nodeB.next && (a.m_nodeB.next.prev = a.m_nodeB.prev);
    a.m_nodeB == c.m_contactList && (c.m_contactList = a.m_nodeB.next);
    this.m_contactFactory.Destroy(a);
    --this.m_contactCount
};
goog.exportSymbol("box2d.b2ContactManager.prototype.Destroy", box2d.b2ContactManager.prototype.Destroy);
box2d.b2ContactManager.prototype.Collide = function() {
    for (var a = this.m_contactList; a; ) {
        var b = a.GetFixtureA(), c = a.GetFixtureB(), e = a.GetChildIndexA(), d = a.GetChildIndexB(), f = b.GetBody(), g = c.GetBody();
        if (a.m_flags & box2d.b2ContactFlag.e_filterFlag) {
            if (!1 == g.ShouldCollide(f)) {
                b = a;
                a = b.m_next;
                this.Destroy(b);
                continue
            }
            if (this.m_contactFilter && !1 == this.m_contactFilter.ShouldCollide(b, c)) {
                b = a;
                a = b.m_next;
                this.Destroy(b);
                continue
            }
            a.m_flags &= ~box2d.b2ContactFlag.e_filterFlag
        }
        f = f.IsAwake() && f.m_type != box2d.b2BodyType.b2_staticBody;
        g = g.IsAwake() && g.m_type != box2d.b2BodyType.b2_staticBody;
        !1 == f && !1 == g ? a = a.m_next : !1 == this.m_broadPhase.TestOverlap(b.m_proxies[e].proxy, c.m_proxies[d].proxy) ? (b = a, a = b.m_next, this.Destroy(b)) : (a.Update(this.m_contactListener), a = a.m_next)
    }
};
goog.exportSymbol("box2d.b2ContactManager.prototype.Collide", box2d.b2ContactManager.prototype.Collide);
box2d.b2ContactManager.prototype.FindNewContacts = function() {
    this.m_broadPhase.UpdatePairs(this)
};
goog.exportSymbol("box2d.b2ContactManager.prototype.FindNewContacts", box2d.b2ContactManager.prototype.FindNewContacts);
box2d.b2ContactManager.prototype.AddPair = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2FixtureProxy);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(b instanceof box2d.b2FixtureProxy);
    var c = a.fixture, e = b.fixture, d = a.childIndex, f = b.childIndex, g = c.GetBody(), h = e.GetBody();
    if (g != h) {
        for (var l = h.GetContactList(); l; ) {
            if (l.other == g) {
                var k = l.contact.GetFixtureA(), m = l.contact.GetFixtureB(), n = l.contact.GetChildIndexA(), p = l.contact.GetChildIndexB();
                if (k == c && m == e && n == d && p == f || k == e && m == c && n == f &&
                        p == d)
                    return
            }
            l = l.next
        }
        !1 == h.ShouldCollide(g) || this.m_contactFilter && !1 == this.m_contactFilter.ShouldCollide(c, e) || (d = this.m_contactFactory.Create(c, d, e, f), null != d && (c = d.GetFixtureA(), e = d.GetFixtureB(), d.GetChildIndexA(), d.GetChildIndexB(), g = c.m_body, h = e.m_body, d.m_prev = null, d.m_next = this.m_contactList, null !== this.m_contactList && (this.m_contactList.m_prev = d), this.m_contactList = d, d.m_nodeA.contact = d, d.m_nodeA.other = h, d.m_nodeA.prev = null, d.m_nodeA.next = g.m_contactList, null != g.m_contactList && (g.m_contactList.prev =
                d.m_nodeA), g.m_contactList = d.m_nodeA, d.m_nodeB.contact = d, d.m_nodeB.other = g, d.m_nodeB.prev = null, d.m_nodeB.next = h.m_contactList, null != h.m_contactList && (h.m_contactList.prev = d.m_nodeB), h.m_contactList = d.m_nodeB, !1 == c.IsSensor() && !1 == e.IsSensor() && (g.SetAwake(!0), h.SetAwake(!0)), ++this.m_contactCount))
    }
};
goog.exportSymbol("box2d.b2ContactManager.prototype.AddPair", box2d.b2ContactManager.prototype.AddPair);
box2d.b2JointFactory = {};
box2d.b2JointFactory.Create = function(a, b) {
    var c = null;
    switch (a.type) {
        case box2d.b2JointType.e_distanceJoint:
            c = new box2d.b2DistanceJoint(a instanceof box2d.b2DistanceJointDef ? a : null);
            break;
        case box2d.b2JointType.e_mouseJoint:
            c = new box2d.b2MouseJoint(a instanceof box2d.b2MouseJointDef ? a : null);
            break;
        case box2d.b2JointType.e_prismaticJoint:
            c = new box2d.b2PrismaticJoint(a instanceof box2d.b2PrismaticJointDef ? a : null);
            break;
        case box2d.b2JointType.e_revoluteJoint:
            c = new box2d.b2RevoluteJoint(a instanceof box2d.b2RevoluteJointDef ?
                    a : null);
            break;
        case box2d.b2JointType.e_pulleyJoint:
            c = new box2d.b2PulleyJoint(a instanceof box2d.b2PulleyJointDef ? a : null);
            break;
        case box2d.b2JointType.e_gearJoint:
            c = new box2d.b2GearJoint(a instanceof box2d.b2GearJointDef ? a : null);
            break;
        case box2d.b2JointType.e_wheelJoint:
            c = new box2d.b2WheelJoint(a instanceof box2d.b2WheelJointDef ? a : null);
            break;
        case box2d.b2JointType.e_weldJoint:
            c = new box2d.b2WeldJoint(a instanceof box2d.b2WeldJointDef ? a : null);
            break;
        case box2d.b2JointType.e_frictionJoint:
            c = new box2d.b2FrictionJoint(a instanceof
                    box2d.b2FrictionJointDef ? a : null);
            break;
        case box2d.b2JointType.e_ropeJoint:
            c = new box2d.b2RopeJoint(a instanceof box2d.b2RopeJointDef ? a : null);
            break;
        case box2d.b2JointType.e_motorJoint:
            c = new box2d.b2MotorJoint(a instanceof box2d.b2MotorJointDef ? a : null);
            break;
        case box2d.b2JointType.e_areaJoint:
            c = new box2d.b2AreaJoint(a instanceof box2d.b2AreaJointDef ? a : null);
            break;
        default:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
    }
    return c
};
goog.exportSymbol("box2d.b2JointFactory.Create", box2d.b2JointFactory.Create);
box2d.b2JointFactory.Destroy = function(a, b) {
};
goog.exportSymbol("box2d.b2JointFactory.Destroy", box2d.b2JointFactory.Destroy);
box2d.b2Color = function(a, b, c) {
    this.r = a;
    this.g = b;
    this.b = c
};
goog.exportSymbol("box2d.b2Color", box2d.b2Color);
box2d.b2Color.prototype.r = 0.5;
goog.exportProperty(box2d.b2Color.prototype, "r", box2d.b2Color.prototype.r);
box2d.b2Color.prototype.g = 0.5;
goog.exportProperty(box2d.b2Color.prototype, "g", box2d.b2Color.prototype.g);
box2d.b2Color.prototype.b = 0.5;
goog.exportProperty(box2d.b2Color.prototype, "b", box2d.b2Color.prototype.b);
box2d.b2Color.prototype.SetRGB = function(a, b, c) {
    this.r = a;
    this.g = b;
    this.b = c;
    return this
};
goog.exportProperty(box2d.b2Color.prototype, "SetRGB", box2d.b2Color.prototype.SetRGB);
box2d.b2Color.prototype.MakeStyleString = function(a) {
    var b = Math.round(Math.max(0, Math.min(255, 255 * this.r))), c = Math.round(Math.max(0, Math.min(255, 255 * this.g))), e = Math.round(Math.max(0, Math.min(255, 255 * this.b)));
    a = "undefined" == typeof a ? Math.max(0, Math.min(1, a)) : 1;
    return box2d.b2Color.MakeStyleString(b, c, e, a)
};
goog.exportProperty(box2d.b2Color.prototype, "MakeStyleString", box2d.b2Color.prototype.MakeStyleString);
box2d.b2Color.MakeStyleString = function(a, b, c, e) {
    return 1 > e ? "rgba(" + a + "," + b + "," + c + "," + e + ")" : "rgb(" + a + "," + b + "," + c + ")"
};
goog.exportProperty(box2d.b2Color, "MakeStyleString", box2d.b2Color.MakeStyleString);
box2d.b2Color.RED = new box2d.b2Color(1, 0, 0);
goog.exportProperty(box2d.b2Color, "RED", box2d.b2Color.RED);
box2d.b2Color.GREEN = new box2d.b2Color(0, 1, 0);
goog.exportProperty(box2d.b2Color, "GREEN", box2d.b2Color.GREEN);
box2d.b2Color.BLUE = new box2d.b2Color(0, 0, 1);
goog.exportProperty(box2d.b2Color, "BLUE", box2d.b2Color.BLUE);
box2d.b2DrawFlags = {e_none: 0, e_shapeBit: 1, e_jointBit: 2, e_aabbBit: 4, e_pairBit: 8, e_centerOfMassBit: 16, e_controllerBit: 32, e_all: 63};
goog.exportSymbol("box2d.b2DrawFlags", box2d.b2DrawFlags);
goog.exportProperty(box2d.b2DrawFlags, "e_none", box2d.b2DrawFlags.e_none);
goog.exportProperty(box2d.b2DrawFlags, "e_shapeBit", box2d.b2DrawFlags.e_shapeBit);
goog.exportProperty(box2d.b2DrawFlags, "e_jointBit", box2d.b2DrawFlags.e_jointBit);
goog.exportProperty(box2d.b2DrawFlags, "e_aabbBit", box2d.b2DrawFlags.e_aabbBit);
goog.exportProperty(box2d.b2DrawFlags, "e_pairBit", box2d.b2DrawFlags.e_pairBit);
goog.exportProperty(box2d.b2DrawFlags, "e_centerOfMassBit", box2d.b2DrawFlags.e_centerOfMassBit);
goog.exportProperty(box2d.b2DrawFlags, "e_controllerBit", box2d.b2DrawFlags.e_controllerBit);
goog.exportProperty(box2d.b2DrawFlags, "e_all", box2d.b2DrawFlags.e_all);
box2d.b2Draw = function() {
};
goog.exportSymbol("box2d.b2Draw", box2d.b2Draw);
box2d.b2Draw.prototype.m_drawFlags = box2d.b2DrawFlags.e_none;
goog.exportProperty(box2d.b2Draw.prototype, "m_drawFlags", box2d.b2Draw.prototype.m_drawFlags);
box2d.b2Draw.prototype.SetFlags = function(a) {
    this.m_drawFlags = a
};
goog.exportProperty(box2d.b2Draw.prototype, "SetFlags", box2d.b2Draw.prototype.SetFlags);
box2d.b2Draw.prototype.GetFlags = function() {
    return this.m_drawFlags
};
goog.exportProperty(box2d.b2Draw.prototype, "GetFlags", box2d.b2Draw.prototype.GetFlags);
box2d.b2Draw.prototype.AppendFlags = function(a) {
    this.m_drawFlags |= a
};
goog.exportProperty(box2d.b2Draw.prototype, "AppendFlags", box2d.b2Draw.prototype.AppendFlags);
box2d.b2Draw.prototype.ClearFlags = function(a) {
    this.m_drawFlags &= ~a
};
goog.exportProperty(box2d.b2Draw.prototype, "ClearFlags", box2d.b2Draw.prototype.ClearFlags);
box2d.b2Draw.prototype.PushTransform = function(a) {
};
goog.exportProperty(box2d.b2Draw.prototype, "PushTransform", box2d.b2Draw.prototype.PushTransform);
box2d.b2Draw.prototype.PopTransform = function(a) {
};
goog.exportProperty(box2d.b2Draw.prototype, "PopTransform", box2d.b2Draw.prototype.PopTransform);
box2d.b2Draw.prototype.DrawPolygon = function(a, b, c) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawPolygon", box2d.b2Draw.prototype.DrawPolygon);
box2d.b2Draw.prototype.DrawSolidPolygon = function(a, b, c) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawSolidPolygon", box2d.b2Draw.prototype.DrawSolidPolygon);
box2d.b2Draw.prototype.DrawCircle = function(a, b, c) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawCircle", box2d.b2Draw.prototype.DrawCircle);
box2d.b2Draw.prototype.DrawSolidCircle = function(a, b, c, e) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawSolidCircle", box2d.b2Draw.prototype.DrawSolidCircle);
box2d.b2Draw.prototype.DrawSegment = function(a, b, c) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawSegment", box2d.b2Draw.prototype.DrawSegment);
box2d.b2Draw.prototype.DrawTransform = function(a) {
};
goog.exportProperty(box2d.b2Draw.prototype, "DrawTransform", box2d.b2Draw.prototype.DrawTransform);
box2d.b2Filter = function() {
};
goog.exportSymbol("box2d.b2Filter", box2d.b2Filter);
box2d.b2Filter.prototype.categoryBits = 1;
goog.exportProperty(box2d.b2Filter.prototype, "categoryBits", box2d.b2Filter.prototype.categoryBits);
box2d.b2Filter.prototype.maskBits = 65535;
goog.exportProperty(box2d.b2Filter.prototype, "maskBits", box2d.b2Filter.prototype.maskBits);
box2d.b2Filter.prototype.groupIndex = 0;
goog.exportProperty(box2d.b2Filter.prototype, "groupIndex", box2d.b2Filter.prototype.groupIndex);
box2d.b2Filter.prototype.Clone = function() {
    return(new box2d.b2Filter).Copy(this)
};
goog.exportProperty(box2d.b2Filter.prototype, "Clone", box2d.b2Filter.prototype.Clone);
box2d.b2Filter.prototype.Copy = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this !== a);
    this.categoryBits = a.categoryBits;
    this.maskBits = a.maskBits;
    this.groupIndex = a.groupIndex;
    return this
};
goog.exportProperty(box2d.b2Filter.prototype, "Copy", box2d.b2Filter.prototype.Copy);
box2d.b2FixtureDef = function() {
    this.filter = new box2d.b2Filter
};
goog.exportSymbol("box2d.b2FixtureDef", box2d.b2FixtureDef);
box2d.b2FixtureDef.prototype.shape = null;
goog.exportProperty(box2d.b2FixtureDef.prototype, "shape", box2d.b2FixtureDef.prototype.shape);
box2d.b2FixtureDef.prototype.userData = null;
goog.exportProperty(box2d.b2FixtureDef.prototype, "userData", box2d.b2FixtureDef.prototype.userData);
box2d.b2FixtureDef.prototype.friction = 0.2;
goog.exportProperty(box2d.b2FixtureDef.prototype, "friction", box2d.b2FixtureDef.prototype.friction);
box2d.b2FixtureDef.prototype.restitution = 0;
goog.exportProperty(box2d.b2FixtureDef.prototype, "restitution", box2d.b2FixtureDef.prototype.restitution);
box2d.b2FixtureDef.prototype.density = 0;
goog.exportProperty(box2d.b2FixtureDef.prototype, "density", box2d.b2FixtureDef.prototype.density);
box2d.b2FixtureDef.prototype.isSensor = !1;
goog.exportProperty(box2d.b2FixtureDef.prototype, "isSensor", box2d.b2FixtureDef.prototype.isSensor);
box2d.b2FixtureDef.prototype.filter = null;
goog.exportProperty(box2d.b2FixtureDef.prototype, "filter", box2d.b2FixtureDef.prototype.filter);
box2d.b2FixtureProxy = function() {
    this.aabb = new box2d.b2AABB
};
goog.exportSymbol("box2d.b2FixtureProxy", box2d.b2FixtureProxy);
box2d.b2FixtureProxy.prototype.aabb = null;
goog.exportProperty(box2d.b2FixtureProxy.prototype, "aabb", box2d.b2FixtureProxy.prototype.aabb);
box2d.b2FixtureProxy.prototype.fixture = null;
goog.exportProperty(box2d.b2FixtureProxy.prototype, "fixture", box2d.b2FixtureProxy.prototype.fixture);
box2d.b2FixtureProxy.prototype.childIndex = 0;
goog.exportProperty(box2d.b2FixtureProxy.prototype, "childIndex", box2d.b2FixtureProxy.prototype.childIndex);
box2d.b2FixtureProxy.prototype.proxy = null;
goog.exportProperty(box2d.b2FixtureProxy.prototype, "proxy", box2d.b2FixtureProxy.prototype.proxy);
box2d.b2FixtureProxy.MakeArray = function(a) {
    return box2d.b2MakeArray(a, function(a) {
        return new box2d.b2FixtureProxy
    })
};
goog.exportProperty(box2d.b2FixtureProxy, "MakeArray", box2d.b2FixtureProxy.MakeArray);
box2d.b2Fixture = function() {
    this.m_proxyCount = 0;
    this.m_filter = new box2d.b2Filter
};
goog.exportSymbol("box2d.b2Fixture", box2d.b2Fixture);
box2d.b2Fixture.prototype.m_density = 0;
goog.exportProperty(box2d.b2Fixture.prototype, "m_density", box2d.b2Fixture.prototype.m_density);
box2d.b2Fixture.prototype.m_next = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_next", box2d.b2Fixture.prototype.m_next);
box2d.b2Fixture.prototype.m_body = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_body", box2d.b2Fixture.prototype.m_body);
box2d.b2Fixture.prototype.m_shape = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_shape", box2d.b2Fixture.prototype.m_shape);
box2d.b2Fixture.prototype.m_friction = 0;
goog.exportProperty(box2d.b2Fixture.prototype, "m_friction", box2d.b2Fixture.prototype.m_friction);
box2d.b2Fixture.prototype.m_restitution = 0;
goog.exportProperty(box2d.b2Fixture.prototype, "m_restitution", box2d.b2Fixture.prototype.m_restitution);
box2d.b2Fixture.prototype.m_proxies = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_proxies", box2d.b2Fixture.prototype.m_proxies);
box2d.b2Fixture.prototype.m_proxyCount = 0;
goog.exportProperty(box2d.b2Fixture.prototype, "m_proxyCount", box2d.b2Fixture.prototype.m_proxyCount);
box2d.b2Fixture.prototype.m_filter = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_filter", box2d.b2Fixture.prototype.m_filter);
box2d.b2Fixture.prototype.m_isSensor = !1;
goog.exportProperty(box2d.b2Fixture.prototype, "m_isSensor", box2d.b2Fixture.prototype.m_isSensor);
box2d.b2Fixture.prototype.m_userData = null;
goog.exportProperty(box2d.b2Fixture.prototype, "m_userData", box2d.b2Fixture.prototype.m_userData);
box2d.b2Fixture.prototype.GetType = function() {
    return this.m_shape.GetType()
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetType", box2d.b2Fixture.prototype.GetType);
box2d.b2Fixture.prototype.GetShape = function() {
    return this.m_shape
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetShape", box2d.b2Fixture.prototype.GetShape);
box2d.b2Fixture.prototype.IsSensor = function() {
    return this.m_isSensor
};
goog.exportProperty(box2d.b2Fixture.prototype, "IsSensor", box2d.b2Fixture.prototype.IsSensor);
box2d.b2Fixture.prototype.GetFilterData = function() {
    return this.m_filter
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetFilterData", box2d.b2Fixture.prototype.GetFilterData);
box2d.b2Fixture.prototype.GetUserData = function() {
    return this.m_userData
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetUserData", box2d.b2Fixture.prototype.GetUserData);
box2d.b2Fixture.prototype.SetUserData = function(a) {
    this.m_userData = a
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetUserData", box2d.b2Fixture.prototype.SetUserData);
box2d.b2Fixture.prototype.GetBody = function() {
    return this.m_body
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetBody", box2d.b2Fixture.prototype.GetBody);
box2d.b2Fixture.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetNext", box2d.b2Fixture.prototype.GetNext);
box2d.b2Fixture.prototype.SetDensity = function(a) {
    this.m_density = a
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetDensity", box2d.b2Fixture.prototype.SetDensity);
box2d.b2Fixture.prototype.GetDensity = function() {
    return this.m_density
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetDensity", box2d.b2Fixture.prototype.GetDensity);
box2d.b2Fixture.prototype.GetFriction = function() {
    return this.m_friction
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetFriction", box2d.b2Fixture.prototype.GetFriction);
box2d.b2Fixture.prototype.SetFriction = function(a) {
    this.m_friction = a
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetFriction", box2d.b2Fixture.prototype.SetFriction);
box2d.b2Fixture.prototype.GetRestitution = function() {
    return this.m_restitution
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetRestitution", box2d.b2Fixture.prototype.GetRestitution);
box2d.b2Fixture.prototype.SetRestitution = function(a) {
    this.m_restitution = a
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetRestitution", box2d.b2Fixture.prototype.SetRestitution);
box2d.b2Fixture.prototype.TestPoint = function(a) {
    return this.m_shape.TestPoint(this.m_body.GetTransform(), a)
};
goog.exportProperty(box2d.b2Fixture.prototype, "TestPoint", box2d.b2Fixture.prototype.TestPoint);
box2d.b2Fixture.prototype.RayCast = function(a, b, c) {
    return this.m_shape.RayCast(a, b, this.m_body.GetTransform(), c)
};
goog.exportProperty(box2d.b2Fixture.prototype, "RayCast", box2d.b2Fixture.prototype.RayCast);
box2d.b2Fixture.prototype.GetMassData = function(a) {
    a = a || new box2d.b2MassData;
    this.m_shape.ComputeMass(a, this.m_density);
    return a
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetMassData", box2d.b2Fixture.prototype.GetMassData);
box2d.b2Fixture.prototype.GetAABB = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= a && a < this.m_proxyCount);
    return this.m_proxies[a].aabb
};
goog.exportProperty(box2d.b2Fixture.prototype, "GetAABB", box2d.b2Fixture.prototype.GetAABB);
box2d.b2Fixture.prototype.Create = function(a, b) {
    this.m_userData = b.userData;
    this.m_friction = b.friction;
    this.m_restitution = b.restitution;
    this.m_body = a;
    this.m_next = null;
    this.m_filter.Copy(b.filter);
    this.m_isSensor = b.isSensor;
    this.m_shape = b.shape.Clone();
    this.m_proxies = box2d.b2FixtureProxy.MakeArray(this.m_shape.GetChildCount());
    this.m_proxyCount = 0;
    this.m_density = b.density
};
goog.exportProperty(box2d.b2Fixture.prototype, "Create", box2d.b2Fixture.prototype.Create);
box2d.b2Fixture.prototype.Destroy = function() {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 == this.m_proxyCount);
    this.m_shape = null
};
goog.exportProperty(box2d.b2Fixture.prototype, "Destroy", box2d.b2Fixture.prototype.Destroy);
box2d.b2Fixture.prototype.CreateProxies = function(a, b) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 == this.m_proxyCount);
    this.m_proxyCount = this.m_shape.GetChildCount();
    for (var c = 0; c < this.m_proxyCount; ++c) {
        var e = this.m_proxies[c];
        this.m_shape.ComputeAABB(e.aabb, b, c);
        e.proxy = a.CreateProxy(e.aabb, e);
        e.fixture = this;
        e.childIndex = c
    }
};
goog.exportProperty(box2d.b2Fixture.prototype, "CreateProxies", box2d.b2Fixture.prototype.CreateProxies);
box2d.b2Fixture.prototype.DestroyProxies = function(a) {
    for (var b = 0; b < this.m_proxyCount; ++b) {
        var c = this.m_proxies[b];
        a.DestroyProxy(c.proxy);
        c.proxy = null
    }
    this.m_proxyCount = 0
};
goog.exportProperty(box2d.b2Fixture.prototype, "DestroyProxies", box2d.b2Fixture.prototype.DestroyProxies);
box2d.b2Fixture.prototype.Synchronize = function(a, b, c) {
    if (0 != this.m_proxyCount)
        for (var e = 0; e < this.m_proxyCount; ++e) {
            var d = this.m_proxies[e], f = box2d.b2Fixture.prototype.Synchronize.s_aabb1, g = box2d.b2Fixture.prototype.Synchronize.s_aabb2;
            this.m_shape.ComputeAABB(f, b, e);
            this.m_shape.ComputeAABB(g, c, e);
            d.aabb.Combine2(f, g);
            f = box2d.b2SubVV(c.p, b.p, box2d.b2Fixture.prototype.Synchronize.s_displacement);
            a.MoveProxy(d.proxy, d.aabb, f)
        }
};
goog.exportProperty(box2d.b2Fixture.prototype, "Synchronize", box2d.b2Fixture.prototype.Synchronize);
box2d.b2Fixture.prototype.Synchronize.s_aabb1 = new box2d.b2AABB;
box2d.b2Fixture.prototype.Synchronize.s_aabb2 = new box2d.b2AABB;
box2d.b2Fixture.prototype.Synchronize.s_displacement = new box2d.b2Vec2;
box2d.b2Fixture.prototype.SetFilterData = function(a) {
    this.m_filter.Copy(a);
    this.Refilter()
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetFilterData", box2d.b2Fixture.prototype.SetFilterData);
box2d.b2Fixture.prototype.Refilter = function() {
    if (!this.m_body) {
        for (var a = this.m_body.GetContactList(); a; ) {
            var b = a.contact, c = b.GetFixtureA(), e = b.GetFixtureB();
            c != this && e != this || b.FlagForFiltering();
            a = a.next
        }
        a = this.m_body.GetWorld();
        if (null !== a)
            for (a = a.m_contactManager.m_broadPhase, b = 0; b < this.m_proxyCount; ++b)
                a.TouchProxy(this.m_proxies[b].proxy)
    }
};
goog.exportProperty(box2d.b2Fixture.prototype, "Refilter", box2d.b2Fixture.prototype.Refilter);
box2d.b2Fixture.prototype.SetSensor = function(a) {
    a != this.m_isSensor && (this.m_body.SetAwake(!0), this.m_isSensor = a)
};
goog.exportProperty(box2d.b2Fixture.prototype, "SetSensor", box2d.b2Fixture.prototype.SetSensor);
box2d.b2Fixture.prototype.Dump = function(a) {
    box2d.DEBUG && (box2d.b2Log("    /*box2d.b2FixtureDef*/ var fd = new box2d.b2FixtureDef();\n"), box2d.b2Log("    fd.friction = %.15f;\n", this.m_friction), box2d.b2Log("    fd.restitution = %.15f;\n", this.m_restitution), box2d.b2Log("    fd.density = %.15f;\n", this.m_density), box2d.b2Log("    fd.isSensor = %s;\n", this.m_isSensor ? "true" : "false"), box2d.b2Log("    fd.filter.categoryBits = %d;\n", this.m_filter.categoryBits), box2d.b2Log("    fd.filter.maskBits = %d;\n",
            this.m_filter.maskBits), box2d.b2Log("    fd.filter.groupIndex = %d;\n", this.m_filter.groupIndex), this.m_shape.Dump(), box2d.b2Log("\n"), box2d.b2Log("    fd.shape = shape;\n"), box2d.b2Log("\n"), box2d.b2Log("    bodies[%d].CreateFixture(fd);\n", a))
};
goog.exportProperty(box2d.b2Fixture.prototype, "Dump", box2d.b2Fixture.prototype.Dump);
box2d.b2BodyType = {b2_unknown: -1, b2_staticBody: 0, b2_kinematicBody: 1, b2_dynamicBody: 2, b2_bulletBody: 3};
goog.exportSymbol("box2d.b2BodyType", box2d.b2BodyType);
goog.exportProperty(box2d.b2BodyType, "b2_unknown", box2d.b2BodyType.b2_unknown);
goog.exportProperty(box2d.b2BodyType, "b2_staticBody", box2d.b2BodyType.b2_staticBody);
goog.exportProperty(box2d.b2BodyType, "b2_kinematicBody", box2d.b2BodyType.b2_kinematicBody);
goog.exportProperty(box2d.b2BodyType, "b2_dynamicBody", box2d.b2BodyType.b2_dynamicBody);
goog.exportProperty(box2d.b2BodyType, "b2_bulletBody", box2d.b2BodyType.b2_bulletBody);
box2d.b2BodyDef = function() {
    this.position = new box2d.b2Vec2(0, 0);
    this.linearVelocity = new box2d.b2Vec2(0, 0)
};
goog.exportSymbol("box2d.b2BodyDef", box2d.b2BodyDef);
box2d.b2BodyDef.prototype.type = box2d.b2BodyType.b2_staticBody;
goog.exportProperty(box2d.b2BodyDef.prototype, "type", box2d.b2BodyDef.prototype.type);
box2d.b2BodyDef.prototype.position = null;
goog.exportProperty(box2d.b2BodyDef.prototype, "position", box2d.b2BodyDef.prototype.position);
box2d.b2BodyDef.prototype.angle = 0;
goog.exportProperty(box2d.b2BodyDef.prototype, "angle", box2d.b2BodyDef.prototype.angle);
box2d.b2BodyDef.prototype.linearVelocity = null;
goog.exportProperty(box2d.b2BodyDef.prototype, "linearVelocity", box2d.b2BodyDef.prototype.linearVelocity);
box2d.b2BodyDef.prototype.angularVelocity = 0;
goog.exportProperty(box2d.b2BodyDef.prototype, "angularVelocity", box2d.b2BodyDef.prototype.angularVelocity);
box2d.b2BodyDef.prototype.linearDamping = 0;
goog.exportProperty(box2d.b2BodyDef.prototype, "linearDamping", box2d.b2BodyDef.prototype.linearDamping);
box2d.b2BodyDef.prototype.angularDamping = 0;
goog.exportProperty(box2d.b2BodyDef.prototype, "angularDamping", box2d.b2BodyDef.prototype.angularDamping);
box2d.b2BodyDef.prototype.allowSleep = !0;
goog.exportProperty(box2d.b2BodyDef.prototype, "allowSleep", box2d.b2BodyDef.prototype.allowSleep);
box2d.b2BodyDef.prototype.awake = !0;
goog.exportProperty(box2d.b2BodyDef.prototype, "awake", box2d.b2BodyDef.prototype.awake);
box2d.b2BodyDef.prototype.fixedRotation = !1;
goog.exportProperty(box2d.b2BodyDef.prototype, "fixedRotation", box2d.b2BodyDef.prototype.fixedRotation);
box2d.b2BodyDef.prototype.bullet = !1;
goog.exportProperty(box2d.b2BodyDef.prototype, "bullet", box2d.b2BodyDef.prototype.bullet);
box2d.b2BodyDef.prototype.active = !0;
goog.exportProperty(box2d.b2BodyDef.prototype, "active", box2d.b2BodyDef.prototype.active);
box2d.b2BodyDef.prototype.userData = null;
goog.exportProperty(box2d.b2BodyDef.prototype, "userData", box2d.b2BodyDef.prototype.userData);
box2d.b2BodyDef.prototype.gravityScale = 1;
goog.exportProperty(box2d.b2BodyDef.prototype, "gravityScale", box2d.b2BodyDef.prototype.gravityScale);
box2d.b2BodyFlag = {e_none: 0, e_islandFlag: 1, e_awakeFlag: 2, e_autoSleepFlag: 4, e_bulletFlag: 8, e_fixedRotationFlag: 16, e_activeFlag: 32, e_toiFlag: 64};
goog.exportProperty(box2d.b2BodyFlag, "e_none", box2d.b2BodyFlag.e_none);
goog.exportProperty(box2d.b2BodyFlag, "e_islandFlag", box2d.b2BodyFlag.e_islandFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_awakeFlag", box2d.b2BodyFlag.e_awakeFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_autoSleepFlag", box2d.b2BodyFlag.e_autoSleepFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_bulletFlag", box2d.b2BodyFlag.e_bulletFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_fixedRotationFlag", box2d.b2BodyFlag.e_fixedRotationFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_activeFlag", box2d.b2BodyFlag.e_activeFlag);
goog.exportProperty(box2d.b2BodyFlag, "e_toiFlag", box2d.b2BodyFlag.e_toiFlag);
box2d.b2Body = function(a, b) {
    this.m_xf = new box2d.b2Transform;
    this.m_out_xf = new box2d.b2Transform;
    this.m_sweep = new box2d.b2Sweep;
    this.m_out_sweep = new box2d.b2Sweep;
    this.m_linearVelocity = new box2d.b2Vec2;
    this.m_out_linearVelocity = new box2d.b2Vec2;
    this.m_force = new box2d.b2Vec2;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.position.IsValid());
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.linearVelocity.IsValid());
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.angle));
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.angularVelocity));
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.gravityScale) && 0 <= a.gravityScale);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.angularDamping) && 0 <= a.angularDamping);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.linearDamping) && 0 <= a.linearDamping);
    this.m_flags = box2d.b2BodyFlag.e_none;
    a.bullet && (this.m_flags |= box2d.b2BodyFlag.e_bulletFlag);
    a.fixedRotation && (this.m_flags |= box2d.b2BodyFlag.e_fixedRotationFlag);
    a.allowSleep && (this.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag);
    a.awake &&
            (this.m_flags |= box2d.b2BodyFlag.e_awakeFlag);
    a.active && (this.m_flags |= box2d.b2BodyFlag.e_activeFlag);
    this.m_world = b;
    this.m_xf.p.Copy(a.position);
    this.m_xf.q.SetAngleRadians(a.angle);
    this.m_sweep.localCenter.SetZero();
    this.m_sweep.c0.Copy(this.m_xf.p);
    this.m_sweep.c.Copy(this.m_xf.p);
    this.m_sweep.a0 = a.angle;
    this.m_sweep.a = a.angle;
    this.m_sweep.alpha0 = 0;
    this.m_linearVelocity.Copy(a.linearVelocity);
    this.m_angularVelocity = a.angularVelocity;
    this.m_linearDamping = a.linearDamping;
    this.m_angularDamping = a.angularDamping;
    this.m_gravityScale = a.gravityScale;
    this.m_force.SetZero();
    this.m_sleepTime = this.m_torque = 0;
    this.m_type = a.type;
    this.m_invMass = a.type == box2d.b2BodyType.b2_dynamicBody ? this.m_mass = 1 : this.m_mass = 0;
    this.m_invI = this.m_I = 0;
    this.m_userData = a.userData;
    this.m_fixtureList = null;
    this.m_fixtureCount = 0;
    this.m_controllerList = null;
    this.m_controllerCount = 0
};
goog.exportSymbol("box2d.b2Body", box2d.b2Body);
box2d.b2Body.prototype.m_flags = box2d.b2BodyFlag.e_none;
goog.exportProperty(box2d.b2Body.prototype, "m_flags", box2d.b2Body.prototype.m_flags);
box2d.b2Body.prototype.m_islandIndex = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_islandIndex", box2d.b2Body.prototype.m_islandIndex);
box2d.b2Body.prototype.m_world = null;
goog.exportProperty(box2d.b2Body.prototype, "m_world", box2d.b2Body.prototype.m_world);
box2d.b2Body.prototype.m_xf = null;
goog.exportProperty(box2d.b2Body.prototype, "m_xf", box2d.b2Body.prototype.m_xf);
box2d.b2Body.prototype.m_out_xf = null;
goog.exportProperty(box2d.b2Body.prototype, "m_out_xf", box2d.b2Body.prototype.m_out_xf);
box2d.b2Body.prototype.m_sweep = null;
goog.exportProperty(box2d.b2Body.prototype, "m_sweep", box2d.b2Body.prototype.m_sweep);
box2d.b2Body.prototype.m_out_sweep = null;
goog.exportProperty(box2d.b2Body.prototype, "m_out_sweep", box2d.b2Body.prototype.m_out_sweep);
box2d.b2Body.prototype.m_jointList = null;
goog.exportProperty(box2d.b2Body.prototype, "m_jointList", box2d.b2Body.prototype.m_jointList);
box2d.b2Body.prototype.m_contactList = null;
goog.exportProperty(box2d.b2Body.prototype, "m_contactList", box2d.b2Body.prototype.m_contactList);
box2d.b2Body.prototype.m_prev = null;
goog.exportProperty(box2d.b2Body.prototype, "m_prev", box2d.b2Body.prototype.m_prev);
box2d.b2Body.prototype.m_next = null;
goog.exportProperty(box2d.b2Body.prototype, "m_next", box2d.b2Body.prototype.m_next);
box2d.b2Body.prototype.m_linearVelocity = null;
goog.exportProperty(box2d.b2Body.prototype, "m_linearVelocity", box2d.b2Body.prototype.m_linearVelocity);
box2d.b2Body.prototype.m_out_linearVelocity = null;
goog.exportProperty(box2d.b2Body.prototype, "m_out_linearVelocity", box2d.b2Body.prototype.m_out_linearVelocity);
box2d.b2Body.prototype.m_angularVelocity = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_angularVelocity", box2d.b2Body.prototype.m_angularVelocity);
box2d.b2Body.prototype.m_linearDamping = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_linearDamping", box2d.b2Body.prototype.m_linearDamping);
box2d.b2Body.prototype.m_angularDamping = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_angularDamping", box2d.b2Body.prototype.m_angularDamping);
box2d.b2Body.prototype.m_gravityScale = 1;
goog.exportProperty(box2d.b2Body.prototype, "m_gravityScale", box2d.b2Body.prototype.m_gravityScale);
box2d.b2Body.prototype.m_force = null;
goog.exportProperty(box2d.b2Body.prototype, "m_force", box2d.b2Body.prototype.m_force);
box2d.b2Body.prototype.m_torque = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_torque", box2d.b2Body.prototype.m_torque);
box2d.b2Body.prototype.m_sleepTime = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_sleepTime", box2d.b2Body.prototype.m_sleepTime);
box2d.b2Body.prototype.m_type = box2d.b2BodyType.b2_staticBody;
goog.exportProperty(box2d.b2Body.prototype, "m_type", box2d.b2Body.prototype.m_type);
box2d.b2Body.prototype.m_mass = 1;
goog.exportProperty(box2d.b2Body.prototype, "m_mass", box2d.b2Body.prototype.m_mass);
box2d.b2Body.prototype.m_invMass = 1;
goog.exportProperty(box2d.b2Body.prototype, "m_invMass", box2d.b2Body.prototype.m_invMass);
box2d.b2Body.prototype.m_I = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_I", box2d.b2Body.prototype.m_I);
box2d.b2Body.prototype.m_invI = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_invI", box2d.b2Body.prototype.m_invI);
box2d.b2Body.prototype.m_userData = null;
goog.exportProperty(box2d.b2Body.prototype, "m_userData", box2d.b2Body.prototype.m_userData);
box2d.b2Body.prototype.m_fixtureList = null;
goog.exportProperty(box2d.b2Body.prototype, "m_fixtureList", box2d.b2Body.prototype.m_fixtureList);
box2d.b2Body.prototype.m_fixtureCount = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_fixtureCount", box2d.b2Body.prototype.m_fixtureCount);
box2d.b2Body.prototype.m_controllerList = null;
goog.exportProperty(box2d.b2Body.prototype, "m_controllerList", box2d.b2Body.prototype.m_controllerList);
box2d.b2Body.prototype.m_controllerCount = 0;
goog.exportProperty(box2d.b2Body.prototype, "m_controllerCount", box2d.b2Body.prototype.m_controllerCount);
box2d.b2Body.prototype.CreateFixture = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (!0 == this.m_world.IsLocked())
        return null;
    var b = new box2d.b2Fixture;
    b.Create(this, a);
    this.m_flags & box2d.b2BodyFlag.e_activeFlag && b.CreateProxies(this.m_world.m_contactManager.m_broadPhase, this.m_xf);
    b.m_next = this.m_fixtureList;
    this.m_fixtureList = b;
    ++this.m_fixtureCount;
    b.m_body = this;
    0 < b.m_density && this.ResetMassData();
    this.m_world.m_flags |= box2d.b2WorldFlag.e_newFixture;
    return b
};
goog.exportProperty(box2d.b2Body.prototype, "CreateFixture", box2d.b2Body.prototype.CreateFixture);
box2d.b2Body.prototype.CreateFixture2 = function(a, b) {
    void 0 === b && (b = 0);
    var c = box2d.b2Body.prototype.CreateFixture2.s_def;
    c.shape = a;
    c.density = b;
    return this.CreateFixture(c)
};
goog.exportProperty(box2d.b2Body.prototype, "CreateFixture2", box2d.b2Body.prototype.CreateFixture2);
box2d.b2Body.prototype.CreateFixture2.s_def = new box2d.b2FixtureDef;
box2d.b2Body.prototype.DestroyFixture = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (!0 != this.m_world.IsLocked()) {
        box2d.ENABLE_ASSERTS && box2d.b2Assert(a.m_body == this);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_fixtureCount);
        for (var b = this.m_fixtureList, c = null, e = !1; null != b; ) {
            if (b == a) {
                c ? c.m_next = a.m_next : this.m_fixtureList = a.m_next;
                e = !0;
                break
            }
            c = b;
            b = b.m_next
        }
        box2d.ENABLE_ASSERTS && box2d.b2Assert(e);
        for (b = this.m_contactList; b; ) {
            var c = b.contact, b = b.next, e = c.GetFixtureA(),
                    d = c.GetFixtureB();
            a != e && a != d || this.m_world.m_contactManager.Destroy(c)
        }
        this.m_flags & box2d.b2BodyFlag.e_activeFlag && a.DestroyProxies(this.m_world.m_contactManager.m_broadPhase);
        a.Destroy();
        a.m_body = null;
        a.m_next = null;
        --this.m_fixtureCount;
        this.ResetMassData()
    }
};
goog.exportProperty(box2d.b2Body.prototype, "DestroyFixture", box2d.b2Body.prototype.DestroyFixture);
box2d.b2Body.prototype.SetTransformVecRadians = function(a, b) {
    this.SetTransformXYRadians(a.x, a.y, b)
};
goog.exportProperty(box2d.b2Body.prototype, "SetTransformVecRadians", box2d.b2Body.prototype.SetTransformVecRadians);
box2d.b2Body.prototype.SetTransformXYRadians = function(a, b, c) {
    if (this.m_xf.p.x != a || this.m_xf.p.y != b || this.m_xf.q.GetAngleRadians() != c)
        if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked()), !0 != this.m_world.IsLocked()) {
            this.m_xf.q.SetAngleRadians(c);
            this.m_xf.p.SetXY(a, b);
            box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
            this.m_sweep.a = c;
            this.m_sweep.c0.Copy(this.m_sweep.c);
            this.m_sweep.a0 = c;
            a = this.m_world.m_contactManager.m_broadPhase;
            for (b = this.m_fixtureList; b; b = b.m_next)
                b.Synchronize(a,
                        this.m_xf, this.m_xf);
            this.m_world.m_contactManager.FindNewContacts()
        }
};
goog.exportProperty(box2d.b2Body.prototype, "SetTransformXYRadians", box2d.b2Body.prototype.SetTransformXYRadians);
box2d.b2Body.prototype.SetTransform = function(a) {
    this.SetTransformVecRadians(a.p, a.GetAngleRadians())
};
goog.exportProperty(box2d.b2Body.prototype, "SetTransform", box2d.b2Body.prototype.SetTransform);
box2d.b2Body.prototype.GetTransform = function(a) {
    a = a || this.m_out_xf;
    return a.Copy(this.m_xf)
};
goog.exportProperty(box2d.b2Body.prototype, "GetTransform", box2d.b2Body.prototype.GetTransform);
box2d.b2Body.prototype.GetPosition = function(a) {
    a = a || this.m_out_xf.p;
    return a.Copy(this.m_xf.p)
};
goog.exportProperty(box2d.b2Body.prototype, "GetPosition", box2d.b2Body.prototype.GetPosition);
box2d.b2Body.prototype.SetPosition = function(a) {
    this.SetTransformVecRadians(a, this.GetAngleRadians())
};
goog.exportProperty(box2d.b2Body.prototype, "SetPosition", box2d.b2Body.prototype.SetPosition);
box2d.b2Body.prototype.SetPositionXY = function(a, b) {
    this.SetTransformXYRadians(a, b, this.GetAngleRadians())
};
goog.exportProperty(box2d.b2Body.prototype, "SetPositionXY", box2d.b2Body.prototype.SetPositionXY);
box2d.b2Body.prototype.GetAngleRadians = function() {
    return this.m_sweep.a
};
goog.exportProperty(box2d.b2Body.prototype, "GetAngleRadians", box2d.b2Body.prototype.GetAngleRadians);
box2d.b2Body.prototype.SetAngleRadians = function(a) {
    this.SetTransformVecRadians(this.GetPosition(), a)
};
goog.exportProperty(box2d.b2Body.prototype, "SetAngleRadians", box2d.b2Body.prototype.SetAngleRadians);
box2d.b2Body.prototype.GetWorldCenter = function(a) {
    a = a || this.m_out_sweep.c;
    return a.Copy(this.m_sweep.c)
};
goog.exportProperty(box2d.b2Body.prototype, "GetWorldCenter", box2d.b2Body.prototype.GetWorldCenter);
box2d.b2Body.prototype.GetLocalCenter = function(a) {
    a = a || this.m_out_sweep.localCenter;
    return a.Copy(this.m_sweep.localCenter)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLocalCenter", box2d.b2Body.prototype.GetLocalCenter);
box2d.b2Body.prototype.SetLinearVelocity = function(a) {
    this.m_type != box2d.b2BodyType.b2_staticBody && (0 < box2d.b2DotVV(a, a) && this.SetAwake(!0), this.m_linearVelocity.Copy(a))
};
goog.exportProperty(box2d.b2Body.prototype, "SetLinearVelocity", box2d.b2Body.prototype.SetLinearVelocity);
box2d.b2Body.prototype.GetLinearVelocity = function(a) {
    a = a || this.m_out_linearVelocity;
    return a.Copy(this.m_linearVelocity)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLinearVelocity", box2d.b2Body.prototype.GetLinearVelocity);
box2d.b2Body.prototype.SetAngularVelocity = function(a) {
    this.m_type != box2d.b2BodyType.b2_staticBody && (0 < a * a && this.SetAwake(!0), this.m_angularVelocity = a)
};
goog.exportProperty(box2d.b2Body.prototype, "SetAngularVelocity", box2d.b2Body.prototype.SetAngularVelocity);
box2d.b2Body.prototype.GetAngularVelocity = function() {
    return this.m_angularVelocity
};
goog.exportProperty(box2d.b2Body.prototype, "GetAngularVelocity", box2d.b2Body.prototype.GetAngularVelocity);
box2d.b2Body.prototype.GetDefinition = function(a) {
    a.type = this.GetType();
    a.allowSleep = (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) == box2d.b2BodyFlag.e_autoSleepFlag;
    a.angle = this.GetAngleRadians();
    a.angularDamping = this.m_angularDamping;
    a.gravityScale = this.m_gravityScale;
    a.angularVelocity = this.m_angularVelocity;
    a.fixedRotation = (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) == box2d.b2BodyFlag.e_fixedRotationFlag;
    a.bullet = (this.m_flags & box2d.b2BodyFlag.e_bulletFlag) == box2d.b2BodyFlag.e_bulletFlag;
    a.awake = (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) == box2d.b2BodyFlag.e_awakeFlag;
    a.linearDamping = this.m_linearDamping;
    a.linearVelocity.Copy(this.GetLinearVelocity());
    a.position.Copy(this.GetPosition());
    a.userData = this.GetUserData();
    return a
};
goog.exportProperty(box2d.b2Body.prototype, "GetDefinition", box2d.b2Body.prototype.GetDefinition);
box2d.b2Body.prototype.ApplyForce = function(a, b, c) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_force.x += a.x, this.m_force.y += a.y, this.m_torque += (b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyForce", box2d.b2Body.prototype.ApplyForce);
box2d.b2Body.prototype.ApplyForceToCenter = function(a, b) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_force.x += a.x, this.m_force.y += a.y))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyForceToCenter", box2d.b2Body.prototype.ApplyForceToCenter);
box2d.b2Body.prototype.ApplyTorque = function(a, b) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_torque += a))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyTorque", box2d.b2Body.prototype.ApplyTorque);
box2d.b2Body.prototype.ApplyLinearImpulse = function(a, b, c) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_linearVelocity.x += this.m_invMass * a.x, this.m_linearVelocity.y += this.m_invMass * a.y, this.m_angularVelocity += this.m_invI * ((b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x)))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyLinearImpulse", box2d.b2Body.prototype.ApplyLinearImpulse);
box2d.b2Body.prototype.ApplyAngularImpulse = function(a, b) {
    this.m_type == box2d.b2BodyType.b2_dynamicBody && (0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_angularVelocity += this.m_invI * a))
};
goog.exportProperty(box2d.b2Body.prototype, "ApplyAngularImpulse", box2d.b2Body.prototype.ApplyAngularImpulse);
box2d.b2Body.prototype.GetMass = function() {
    return this.m_mass
};
goog.exportProperty(box2d.b2Body.prototype, "GetMass", box2d.b2Body.prototype.GetMass);
box2d.b2Body.prototype.GetInertia = function() {
    return this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter)
};
goog.exportProperty(box2d.b2Body.prototype, "GetInertia", box2d.b2Body.prototype.GetInertia);
box2d.b2Body.prototype.GetMassData = function(a) {
    a.mass = this.m_mass;
    a.I = this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter);
    a.center.Copy(this.m_sweep.localCenter);
    return a
};
goog.exportProperty(box2d.b2Body.prototype, "GetMassData", box2d.b2Body.prototype.GetMassData);
box2d.b2Body.prototype.SetMassData = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (!0 != this.m_world.IsLocked() && this.m_type == box2d.b2BodyType.b2_dynamicBody) {
        this.m_invI = this.m_I = this.m_invMass = 0;
        this.m_mass = a.mass;
        0 >= this.m_mass && (this.m_mass = 1);
        this.m_invMass = 1 / this.m_mass;
        0 < a.I && 0 == (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) && (this.m_I = a.I - this.m_mass * box2d.b2DotVV(a.center, a.center), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_I), this.m_invI = 1 / this.m_I);
        var b = box2d.b2Body.prototype.SetMassData.s_oldCenter.Copy(this.m_sweep.c);
        this.m_sweep.localCenter.Copy(a.center);
        box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
        this.m_sweep.c0.Copy(this.m_sweep.c);
        box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, b, box2d.b2Vec2.s_t0), this.m_linearVelocity)
    }
};
goog.exportProperty(box2d.b2Body.prototype, "SetMassData", box2d.b2Body.prototype.SetMassData);
box2d.b2Body.prototype.SetMassData.s_oldCenter = new box2d.b2Vec2;
box2d.b2Body.prototype.ResetMassData = function() {
    this.m_invI = this.m_I = this.m_invMass = this.m_mass = 0;
    this.m_sweep.localCenter.SetZero();
    if (this.m_type == box2d.b2BodyType.b2_staticBody || this.m_type == box2d.b2BodyType.b2_kinematicBody)
        this.m_sweep.c0.Copy(this.m_xf.p), this.m_sweep.c.Copy(this.m_xf.p), this.m_sweep.a0 = this.m_sweep.a;
    else {
        box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_type == box2d.b2BodyType.b2_dynamicBody);
        for (var a = box2d.b2Body.prototype.ResetMassData.s_localCenter.SetZero(), b = this.m_fixtureList; b; b =
                b.m_next)
            if (0 != b.m_density) {
                var c = b.GetMassData(box2d.b2Body.prototype.ResetMassData.s_massData);
                this.m_mass += c.mass;
                a.x += c.center.x * c.mass;
                a.y += c.center.y * c.mass;
                this.m_I += c.I
            }
        0 < this.m_mass ? (this.m_invMass = 1 / this.m_mass, a.x *= this.m_invMass, a.y *= this.m_invMass) : this.m_invMass = this.m_mass = 1;
        0 < this.m_I && 0 == (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) ? (this.m_I -= this.m_mass * box2d.b2DotVV(a, a), box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_I), this.m_invI = 1 / this.m_I) : this.m_invI = this.m_I = 0;
        b = box2d.b2Body.prototype.ResetMassData.s_oldCenter.Copy(this.m_sweep.c);
        this.m_sweep.localCenter.Copy(a);
        box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
        this.m_sweep.c0.Copy(this.m_sweep.c);
        box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, b, box2d.b2Vec2.s_t0), this.m_linearVelocity)
    }
};
goog.exportProperty(box2d.b2Body.prototype, "ResetMassData", box2d.b2Body.prototype.ResetMassData);
box2d.b2Body.prototype.ResetMassData.s_localCenter = new box2d.b2Vec2;
box2d.b2Body.prototype.ResetMassData.s_oldCenter = new box2d.b2Vec2;
box2d.b2Body.prototype.ResetMassData.s_massData = new box2d.b2MassData;
box2d.b2Body.prototype.GetWorldPoint = function(a, b) {
    return box2d.b2MulXV(this.m_xf, a, b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetWorldPoint", box2d.b2Body.prototype.GetWorldPoint);
box2d.b2Body.prototype.GetWorldVector = function(a, b) {
    return box2d.b2MulRV(this.m_xf.q, a, b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetWorldVector", box2d.b2Body.prototype.GetWorldVector);
box2d.b2Body.prototype.GetLocalPoint = function(a, b) {
    return box2d.b2MulTXV(this.m_xf, a, b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLocalPoint", box2d.b2Body.prototype.GetLocalPoint);
box2d.b2Body.prototype.GetLocalVector = function(a, b) {
    return box2d.b2MulTRV(this.m_xf.q, a, b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLocalVector", box2d.b2Body.prototype.GetLocalVector);
box2d.b2Body.prototype.GetLinearVelocityFromWorldPoint = function(a, b) {
    return box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(a, this.m_sweep.c, box2d.b2Vec2.s_t0), b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLinearVelocityFromWorldPoint", box2d.b2Body.prototype.GetLinearVelocityFromWorldPoint);
box2d.b2Body.prototype.GetLinearVelocityFromLocalPoint = function(a, b) {
    return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(a, b), b)
};
goog.exportProperty(box2d.b2Body.prototype, "GetLinearVelocityFromLocalPoint", box2d.b2Body.prototype.GetLinearVelocityFromLocalPoint);
box2d.b2Body.prototype.GetLinearDamping = function() {
    return this.m_linearDamping
};
goog.exportProperty(box2d.b2Body.prototype, "GetLinearDamping", box2d.b2Body.prototype.GetLinearDamping);
box2d.b2Body.prototype.SetLinearDamping = function(a) {
    this.m_linearDamping = a
};
goog.exportProperty(box2d.b2Body.prototype, "SetLinearDamping", box2d.b2Body.prototype.SetLinearDamping);
box2d.b2Body.prototype.GetAngularDamping = function() {
    return this.m_angularDamping
};
goog.exportProperty(box2d.b2Body.prototype, "GetAngularDamping", box2d.b2Body.prototype.GetAngularDamping);
box2d.b2Body.prototype.SetAngularDamping = function(a) {
    this.m_angularDamping = a
};
goog.exportProperty(box2d.b2Body.prototype, "SetAngularDamping", box2d.b2Body.prototype.SetAngularDamping);
box2d.b2Body.prototype.GetGravityScale = function() {
    return this.m_gravityScale
};
goog.exportProperty(box2d.b2Body.prototype, "GetGravityScale", box2d.b2Body.prototype.GetGravityScale);
box2d.b2Body.prototype.SetGravityScale = function(a) {
    this.m_gravityScale = a
};
goog.exportProperty(box2d.b2Body.prototype, "SetGravityScale", box2d.b2Body.prototype.SetGravityScale);
box2d.b2Body.prototype.SetType = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (!0 != this.m_world.IsLocked() && this.m_type != a) {
        this.m_type = a;
        this.ResetMassData();
        this.m_type == box2d.b2BodyType.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_sweep.a0 = this.m_sweep.a, this.m_sweep.c0.Copy(this.m_sweep.c), this.SynchronizeFixtures());
        this.SetAwake(!0);
        this.m_force.SetZero();
        this.m_torque = 0;
        for (a = this.m_contactList; a; ) {
            var b = a;
            a = a.next;
            this.m_world.m_contactManager.Destroy(b.contact)
        }
        this.m_contactList =
                null;
        a = this.m_world.m_contactManager.m_broadPhase;
        for (b = this.m_fixtureList; b; b = b.m_next)
            for (var c = b.m_proxyCount, e = 0; e < c; ++e)
                a.TouchProxy(b.m_proxies[e].proxy)
    }
};
goog.exportProperty(box2d.b2Body.prototype, "SetType", box2d.b2Body.prototype.SetType);
box2d.b2Body.prototype.GetType = function() {
    return this.m_type
};
goog.exportProperty(box2d.b2Body.prototype, "GetType", box2d.b2Body.prototype.GetType);
box2d.b2Body.prototype.SetBullet = function(a) {
    this.m_flags = a ? this.m_flags | box2d.b2BodyFlag.e_bulletFlag : this.m_flags & ~box2d.b2BodyFlag.e_bulletFlag
};
goog.exportProperty(box2d.b2Body.prototype, "SetBullet", box2d.b2Body.prototype.SetBullet);
box2d.b2Body.prototype.IsBullet = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_bulletFlag) == box2d.b2BodyFlag.e_bulletFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsBullet", box2d.b2Body.prototype.IsBullet);
box2d.b2Body.prototype.SetSleepingAllowed = function(a) {
    a ? this.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag : (this.m_flags &= ~box2d.b2BodyFlag.e_autoSleepFlag, this.SetAwake(!0))
};
goog.exportProperty(box2d.b2Body.prototype, "SetSleepingAllowed", box2d.b2Body.prototype.SetSleepingAllowed);
box2d.b2Body.prototype.IsSleepingAllowed = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) == box2d.b2BodyFlag.e_autoSleepFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsSleepingAllowed", box2d.b2Body.prototype.IsSleepingAllowed);
box2d.b2Body.prototype.SetAwake = function(a) {
    a ? 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && (this.m_flags |= box2d.b2BodyFlag.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~box2d.b2BodyFlag.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0)
};
goog.exportProperty(box2d.b2Body.prototype, "SetAwake", box2d.b2Body.prototype.SetAwake);
box2d.b2Body.prototype.IsAwake = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_awakeFlag) == box2d.b2BodyFlag.e_awakeFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsAwake", box2d.b2Body.prototype.IsAwake);
box2d.b2Body.prototype.SetActive = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.m_world.IsLocked());
    if (a != this.IsActive())
        if (a) {
            this.m_flags |= box2d.b2BodyFlag.e_activeFlag;
            a = this.m_world.m_contactManager.m_broadPhase;
            for (var b = this.m_fixtureList; b; b = b.m_next)
                b.CreateProxies(a, this.m_xf)
        } else {
            this.m_flags &= ~box2d.b2BodyFlag.e_activeFlag;
            a = this.m_world.m_contactManager.m_broadPhase;
            for (b = this.m_fixtureList; b; b = b.m_next)
                b.DestroyProxies(a);
            for (a = this.m_contactList; a; )
                b = a, a = a.next, this.m_world.m_contactManager.Destroy(b.contact);
            this.m_contactList = null
        }
};
goog.exportProperty(box2d.b2Body.prototype, "SetActive", box2d.b2Body.prototype.SetActive);
box2d.b2Body.prototype.IsActive = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_activeFlag) == box2d.b2BodyFlag.e_activeFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsActive", box2d.b2Body.prototype.IsActive);
box2d.b2Body.prototype.SetFixedRotation = function(a) {
    (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) == box2d.b2BodyFlag.e_fixedRotationFlag != a && (this.m_flags = a ? this.m_flags | box2d.b2BodyFlag.e_fixedRotationFlag : this.m_flags & ~box2d.b2BodyFlag.e_fixedRotationFlag, this.m_angularVelocity = 0, this.ResetMassData())
};
goog.exportProperty(box2d.b2Body.prototype, "SetFixedRotation", box2d.b2Body.prototype.SetFixedRotation);
box2d.b2Body.prototype.IsFixedRotation = function() {
    return(this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) == box2d.b2BodyFlag.e_fixedRotationFlag
};
goog.exportProperty(box2d.b2Body.prototype, "IsFixedRotation", box2d.b2Body.prototype.IsFixedRotation);
box2d.b2Body.prototype.GetFixtureList = function() {
    return this.m_fixtureList
};
goog.exportProperty(box2d.b2Body.prototype, "GetFixtureList", box2d.b2Body.prototype.GetFixtureList);
box2d.b2Body.prototype.GetJointList = function() {
    return this.m_jointList
};
goog.exportProperty(box2d.b2Body.prototype, "GetJointList", box2d.b2Body.prototype.GetJointList);
box2d.b2Body.prototype.GetContactList = function() {
    return this.m_contactList
};
goog.exportProperty(box2d.b2Body.prototype, "GetContactList", box2d.b2Body.prototype.GetContactList);
box2d.b2Body.prototype.GetNext = function() {
    return this.m_next
};
goog.exportProperty(box2d.b2Body.prototype, "GetNext", box2d.b2Body.prototype.GetNext);
box2d.b2Body.prototype.GetUserData = function() {
    return this.m_userData
};
goog.exportProperty(box2d.b2Body.prototype, "GetUserData", box2d.b2Body.prototype.GetUserData);
box2d.b2Body.prototype.SetUserData = function(a) {
    this.m_userData = a
};
goog.exportProperty(box2d.b2Body.prototype, "SetUserData", box2d.b2Body.prototype.SetUserData);
box2d.b2Body.prototype.GetWorld = function() {
    return this.m_world
};
goog.exportProperty(box2d.b2Body.prototype, "GetWorld", box2d.b2Body.prototype.GetWorld);
box2d.b2Body.prototype.SynchronizeFixtures = function() {
    var a = box2d.b2Body.prototype.SynchronizeFixtures.s_xf1;
    a.q.SetAngleRadians(this.m_sweep.a0);
    box2d.b2MulRV(a.q, this.m_sweep.localCenter, a.p);
    box2d.b2SubVV(this.m_sweep.c0, a.p, a.p);
    for (var b = this.m_world.m_contactManager.m_broadPhase, c = this.m_fixtureList; c; c = c.m_next)
        c.Synchronize(b, a, this.m_xf)
};
goog.exportProperty(box2d.b2Body.prototype, "SynchronizeFixtures", box2d.b2Body.prototype.SynchronizeFixtures);
box2d.b2Body.prototype.SynchronizeFixtures.s_xf1 = new box2d.b2Transform;
box2d.b2Body.prototype.SynchronizeTransform = function() {
    this.m_xf.q.SetAngleRadians(this.m_sweep.a);
    box2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);
    box2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p)
};
goog.exportProperty(box2d.b2Body.prototype, "SynchronizeTransform", box2d.b2Body.prototype.SynchronizeTransform);
box2d.b2Body.prototype.ShouldCollide = function(a) {
    if (this.m_type != box2d.b2BodyType.b2_dynamicBody && a.m_type != box2d.b2BodyType.b2_dynamicBody)
        return!1;
    for (var b = this.m_jointList; b; b = b.next)
        if (b.other == a && !1 == b.joint.m_collideConnected)
            return!1;
    return!0
};
goog.exportProperty(box2d.b2Body.prototype, "ShouldCollide", box2d.b2Body.prototype.ShouldCollide);
box2d.b2Body.prototype.Advance = function(a) {
    this.m_sweep.Advance(a);
    this.m_sweep.c.Copy(this.m_sweep.c0);
    this.m_sweep.a = this.m_sweep.a0;
    this.m_xf.q.SetAngleRadians(this.m_sweep.a);
    box2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);
    box2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p)
};
goog.exportProperty(box2d.b2Body.prototype, "Advance", box2d.b2Body.prototype.Advance);
box2d.b2Body.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_islandIndex;
        box2d.b2Log("if (true)\n");
        box2d.b2Log("{\n");
        box2d.b2Log("  /*box2d.b2BodyDef*/ var bd = new box2d.b2BodyDef();\n");
        var b = "";
        switch (this.m_type) {
            case box2d.b2BodyType.b2_staticBody:
                b = "box2d.b2BodyType.b2_staticBody";
                break;
            case box2d.b2BodyType.b2_kinematicBody:
                b = "box2d.b2BodyType.b2_kinematicBody";
                break;
            case box2d.b2BodyType.b2_dynamicBody:
                b = "box2d.b2BodyType.b2_dynamicBody";
                break;
            default:
                box2d.ENABLE_ASSERTS && box2d.b2Assert(!1)
        }
        box2d.b2Log("  bd.type = %s;\n",
                b);
        box2d.b2Log("  bd.position.SetXY(%.15f, %.15f);\n", this.m_xf.p.x, this.m_xf.p.y);
        box2d.b2Log("  bd.angle = %.15f;\n", this.m_sweep.a);
        box2d.b2Log("  bd.linearVelocity.SetXY(%.15f, %.15f);\n", this.m_linearVelocity.x, this.m_linearVelocity.y);
        box2d.b2Log("  bd.angularVelocity = %.15f;\n", this.m_angularVelocity);
        box2d.b2Log("  bd.linearDamping = %.15f;\n", this.m_linearDamping);
        box2d.b2Log("  bd.angularDamping = %.15f;\n", this.m_angularDamping);
        box2d.b2Log("  bd.allowSleep = %s;\n", this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag ?
                "true" : "false");
        box2d.b2Log("  bd.awake = %s;\n", this.m_flags & box2d.b2BodyFlag.e_awakeFlag ? "true" : "false");
        box2d.b2Log("  bd.fixedRotation = %s;\n", this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag ? "true" : "false");
        box2d.b2Log("  bd.bullet = %s;\n", this.m_flags & box2d.b2BodyFlag.e_bulletFlag ? "true" : "false");
        box2d.b2Log("  bd.active = %s;\n", this.m_flags & box2d.b2BodyFlag.e_activeFlag ? "true" : "false");
        box2d.b2Log("  bd.gravityScale = %.15f;\n", this.m_gravityScale);
        box2d.b2Log("\n");
        box2d.b2Log("  bodies[%d] = this.m_world.CreateBody(bd);\n",
                this.m_islandIndex);
        box2d.b2Log("\n");
        for (b = this.m_fixtureList; b; b = b.m_next)
            box2d.b2Log("  if (true)\n"), box2d.b2Log("  {\n"), b.Dump(a), box2d.b2Log("  }\n");
        box2d.b2Log("}\n")
    }
};
goog.exportProperty(box2d.b2Body.prototype, "Dump", box2d.b2Body.prototype.Dump);
box2d.b2Body.prototype.GetControllerList = function() {
    return this.m_controllerList
};
goog.exportProperty(box2d.b2Body.prototype, "GetControllerList", box2d.b2Body.prototype.GetControllerList);
box2d.b2Body.prototype.GetControllerCount = function() {
    return this.m_controllerCount
};
goog.exportProperty(box2d.b2Body.prototype, "GetControllerCount", box2d.b2Body.prototype.GetControllerCount);
box2d.b2WorldFlag = {e_none: 0, e_newFixture: 1, e_locked: 2, e_clearForces: 4};
goog.exportSymbol("box2d.b2WorldFlag", box2d.b2WorldFlag);
goog.exportProperty(box2d.b2WorldFlag, "e_none", box2d.b2WorldFlag.e_none);
goog.exportProperty(box2d.b2WorldFlag, "e_newFixture", box2d.b2WorldFlag.e_newFixture);
goog.exportProperty(box2d.b2WorldFlag, "e_locked", box2d.b2WorldFlag.e_locked);
goog.exportProperty(box2d.b2WorldFlag, "e_clearForces", box2d.b2WorldFlag.e_clearForces);
box2d.b2World = function(a) {
    this.m_flags = box2d.b2WorldFlag.e_clearForces;
    this.m_contactManager = new box2d.b2ContactManager;
    this.m_gravity = a.Clone();
    this.m_out_gravity = new box2d.b2Vec2;
    this.m_allowSleep = !0;
    this.m_debugDraw = this.m_destructionListener = null;
    this.m_continuousPhysics = this.m_warmStarting = !0;
    this.m_subStepping = !1;
    this.m_stepComplete = !0;
    this.m_profile = new box2d.b2Profile;
    this.m_island = new box2d.b2Island;
    this.s_stack = []
};
goog.exportSymbol("box2d.b2World", box2d.b2World);
box2d.b2World.prototype.m_flags = box2d.b2WorldFlag.e_none;
goog.exportProperty(box2d.b2World.prototype, "m_flags", box2d.b2World.prototype.m_flags);
box2d.b2World.prototype.m_contactManager = null;
goog.exportProperty(box2d.b2World.prototype, "m_contactManager", box2d.b2World.prototype.m_contactManager);
box2d.b2World.prototype.m_bodyList = null;
goog.exportProperty(box2d.b2World.prototype, "m_bodyList", box2d.b2World.prototype.m_bodyList);
box2d.b2World.prototype.m_jointList = null;
goog.exportProperty(box2d.b2World.prototype, "m_jointList", box2d.b2World.prototype.m_jointList);
box2d.b2World.prototype.m_bodyCount = 0;
goog.exportProperty(box2d.b2World.prototype, "m_bodyCount", box2d.b2World.prototype.m_bodyCount);
box2d.b2World.prototype.m_jointCount = 0;
goog.exportProperty(box2d.b2World.prototype, "m_jointCount", box2d.b2World.prototype.m_jointCount);
box2d.b2World.prototype.m_gravity = null;
goog.exportProperty(box2d.b2World.prototype, "m_gravity", box2d.b2World.prototype.m_gravity);
box2d.b2World.prototype.m_out_gravity = null;
goog.exportProperty(box2d.b2World.prototype, "m_out_gravity", box2d.b2World.prototype.m_out_gravity);
box2d.b2World.prototype.m_allowSleep = !0;
goog.exportProperty(box2d.b2World.prototype, "m_allowSleep", box2d.b2World.prototype.m_allowSleep);
box2d.b2World.prototype.m_destructionListener = null;
goog.exportProperty(box2d.b2World.prototype, "m_destructionListener", box2d.b2World.prototype.m_destructionListener);
box2d.b2World.prototype.m_debugDraw = null;
goog.exportProperty(box2d.b2World.prototype, "m_debugDraw", box2d.b2World.prototype.m_debugDraw);
box2d.b2World.prototype.m_inv_dt0 = 0;
goog.exportProperty(box2d.b2World.prototype, "m_inv_dt0", box2d.b2World.prototype.m_inv_dt0);
box2d.b2World.prototype.m_warmStarting = !0;
goog.exportProperty(box2d.b2World.prototype, "m_warmStarting", box2d.b2World.prototype.m_warmStarting);
box2d.b2World.prototype.m_continuousPhysics = !0;
goog.exportProperty(box2d.b2World.prototype, "m_continuousPhysics", box2d.b2World.prototype.m_continuousPhysics);
box2d.b2World.prototype.m_subStepping = !1;
goog.exportProperty(box2d.b2World.prototype, "m_subStepping", box2d.b2World.prototype.m_subStepping);
box2d.b2World.prototype.m_stepComplete = !0;
goog.exportProperty(box2d.b2World.prototype, "m_stepComplete", box2d.b2World.prototype.m_stepComplete);
box2d.b2World.prototype.m_profile = null;
goog.exportProperty(box2d.b2World.prototype, "m_profile", box2d.b2World.prototype.m_profile);
box2d.b2World.prototype.m_island = null;
goog.exportProperty(box2d.b2World.prototype, "m_island", box2d.b2World.prototype.m_island);
box2d.b2World.prototype.s_stack = null;
goog.exportProperty(box2d.b2World.prototype, "s_stack", box2d.b2World.prototype.s_stack);
box2d.b2World.prototype.m_controllerList = null;
goog.exportProperty(box2d.b2World.prototype, "m_controllerList", box2d.b2World.prototype.m_controllerList);
box2d.b2World.prototype.m_controllerCount = 0;
goog.exportProperty(box2d.b2World.prototype, "m_controllerCount", box2d.b2World.prototype.m_controllerCount);
box2d.b2World.prototype.SetAllowSleeping = function(a) {
    if (a != this.m_allowSleep && (this.m_allowSleep = a, !1 == this.m_allowSleep))
        for (a = this.m_bodyList; a; a = a.m_next)
            a.SetAwake(!0)
};
goog.exportProperty(box2d.b2World.prototype, "SetAllowSleeping", box2d.b2World.prototype.SetAllowSleeping);
box2d.b2World.prototype.GetAllowSleeping = function() {
    return this.m_allowSleep
};
goog.exportProperty(box2d.b2World.prototype, "GetAllowSleeping", box2d.b2World.prototype.GetAllowSleeping);
box2d.b2World.prototype.SetWarmStarting = function(a) {
    this.m_warmStarting = a
};
goog.exportProperty(box2d.b2World.prototype, "SetWarmStarting", box2d.b2World.prototype.SetWarmStarting);
box2d.b2World.prototype.GetWarmStarting = function() {
    return this.m_warmStarting
};
goog.exportProperty(box2d.b2World.prototype, "GetWarmStarting", box2d.b2World.prototype.GetWarmStarting);
box2d.b2World.prototype.SetContinuousPhysics = function(a) {
    this.m_continuousPhysics = a
};
goog.exportProperty(box2d.b2World.prototype, "SetContinuousPhysics", box2d.b2World.prototype.SetContinuousPhysics);
box2d.b2World.prototype.GetContinuousPhysics = function() {
    return this.m_continuousPhysics
};
goog.exportProperty(box2d.b2World.prototype, "GetContinuousPhysics", box2d.b2World.prototype.GetContinuousPhysics);
box2d.b2World.prototype.SetSubStepping = function(a) {
    this.m_subStepping = a
};
goog.exportProperty(box2d.b2World.prototype, "SetSubStepping", box2d.b2World.prototype.SetSubStepping);
box2d.b2World.prototype.GetSubStepping = function() {
    return this.m_subStepping
};
goog.exportProperty(box2d.b2World.prototype, "GetSubStepping", box2d.b2World.prototype.GetSubStepping);
box2d.b2World.prototype.GetBodyList = function() {
    return this.m_bodyList
};
goog.exportProperty(box2d.b2World.prototype, "GetBodyList", box2d.b2World.prototype.GetBodyList);
box2d.b2World.prototype.GetJointList = function() {
    return this.m_jointList
};
goog.exportProperty(box2d.b2World.prototype, "GetJointList", box2d.b2World.prototype.GetJointList);
box2d.b2World.prototype.GetContactList = function() {
    return this.m_contactManager.m_contactList
};
goog.exportProperty(box2d.b2World.prototype, "GetContactList", box2d.b2World.prototype.GetContactList);
box2d.b2World.prototype.GetBodyCount = function() {
    return this.m_bodyCount
};
goog.exportProperty(box2d.b2World.prototype, "GetBodyCount", box2d.b2World.prototype.GetBodyCount);
box2d.b2World.prototype.GetJointCount = function() {
    return this.m_jointCount
};
goog.exportProperty(box2d.b2World.prototype, "GetJointCount", box2d.b2World.prototype.GetJointCount);
box2d.b2World.prototype.GetContactCount = function() {
    return this.m_contactManager.m_contactCount
};
goog.exportProperty(box2d.b2World.prototype, "GetContactCount", box2d.b2World.prototype.GetContactCount);
box2d.b2World.prototype.SetGravity = function(a, b) {
    b = b || !0;
    if (this.m_gravity.x !== a.x || this.m_gravity.y !== a.y)
        if (this.m_gravity.Copy(a), b)
            for (var c = this.m_bodyList; c; c = c.m_next)
                c.SetAwake(!0)
};
goog.exportProperty(box2d.b2World.prototype, "SetGravity", box2d.b2World.prototype.SetGravity);
box2d.b2World.prototype.GetGravity = function(a) {
    a = a || this.m_out_gravity;
    return a.Copy(this.m_gravity)
};
goog.exportProperty(box2d.b2World.prototype, "GetGravity", box2d.b2World.prototype.GetGravity);
box2d.b2World.prototype.IsLocked = function() {
    return 0 < (this.m_flags & box2d.b2WorldFlag.e_locked)
};
goog.exportProperty(box2d.b2World.prototype, "IsLocked", box2d.b2World.prototype.IsLocked);
box2d.b2World.prototype.SetAutoClearForces = function(a) {
    this.m_flags = a ? this.m_flags | box2d.b2WorldFlag.e_clearForces : this.m_flags & ~box2d.b2WorldFlag.e_clearForces
};
goog.exportProperty(box2d.b2World.prototype, "SetAutoClearForces", box2d.b2World.prototype.SetAutoClearForces);
box2d.b2World.prototype.GetAutoClearForces = function() {
    return(this.m_flags & box2d.b2WorldFlag.e_clearForces) == box2d.b2WorldFlag.e_clearForces
};
goog.exportProperty(box2d.b2World.prototype, "GetAutoClearForces", box2d.b2World.prototype.GetAutoClearForces);
box2d.b2World.prototype.GetContactManager = function() {
    return this.m_contactManager
};
goog.exportProperty(box2d.b2World.prototype, "GetContactManager", box2d.b2World.prototype.GetContactManager);
box2d.b2World.prototype.GetProfile = function() {
    return this.m_profile
};
goog.exportProperty(box2d.b2World.prototype, "GetProfile", box2d.b2World.prototype.GetProfile);
box2d.b2World.prototype.SetDestructionListener = function(a) {
    this.m_destructionListener = a
};
goog.exportProperty(box2d.b2World.prototype, "SetDestructionListener", box2d.b2World.prototype.SetDestructionListener);
box2d.b2World.prototype.SetContactFilter = function(a) {
    this.m_contactManager.m_contactFilter = a
};
goog.exportProperty(box2d.b2World.prototype, "SetContactFilter", box2d.b2World.prototype.SetContactFilter);
box2d.b2World.prototype.SetContactListener = function(a) {
    this.m_contactManager.m_contactListener = a
};
goog.exportProperty(box2d.b2World.prototype, "SetContactListener", box2d.b2World.prototype.SetContactListener);
box2d.b2World.prototype.SetDebugDraw = function(a) {
    this.m_debugDraw = a
};
goog.exportProperty(box2d.b2World.prototype, "SetDebugDraw", box2d.b2World.prototype.SetDebugDraw);
box2d.b2World.prototype.CreateBody = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (this.IsLocked())
        return null;
    a = new box2d.b2Body(a, this);
    a.m_prev = null;
    if (a.m_next = this.m_bodyList)
        this.m_bodyList.m_prev = a;
    this.m_bodyList = a;
    ++this.m_bodyCount;
    return a
};
goog.exportProperty(box2d.b2World.prototype, "CreateBody", box2d.b2World.prototype.CreateBody);
box2d.b2World.prototype.DestroyBody = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_bodyCount);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (!this.IsLocked()) {
        for (var b = a.m_jointList; b; ) {
            var c = b, b = b.next;
            this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(c.joint);
            this.DestroyJoint(c.joint);
            a.m_jointList = b
        }
        a.m_jointList = null;
        for (b = a.m_controllerList; b; )
            c = b, b = b.nextController, c.controller.RemoveBody(a);
        for (b = a.m_contactList; b; )
            c = b, b = b.next, this.m_contactManager.Destroy(c.contact);
        a.m_contactList = null;
        for (b = a.m_fixtureList; b; )
            c = b, b = b.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(c), c.DestroyProxies(this.m_contactManager.m_broadPhase), c.Destroy(), a.m_fixtureList = b, a.m_fixtureCount -= 1;
        a.m_fixtureList = null;
        a.m_fixtureCount = 0;
        a.m_prev && (a.m_prev.m_next = a.m_next);
        a.m_next && (a.m_next.m_prev = a.m_prev);
        a == this.m_bodyList && (this.m_bodyList = a.m_next);
        --this.m_bodyCount
    }
};
goog.exportProperty(box2d.b2World.prototype, "DestroyBody", box2d.b2World.prototype.DestroyBody);
box2d.b2World.prototype.CreateJoint = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (this.IsLocked())
        return null;
    var b = box2d.b2JointFactory.Create(a, null);
    b.m_prev = null;
    if (b.m_next = this.m_jointList)
        this.m_jointList.m_prev = b;
    this.m_jointList = b;
    ++this.m_jointCount;
    b.m_edgeA.joint = b;
    b.m_edgeA.other = b.m_bodyB;
    b.m_edgeA.prev = null;
    if (b.m_edgeA.next = b.m_bodyA.m_jointList)
        b.m_bodyA.m_jointList.prev = b.m_edgeA;
    b.m_bodyA.m_jointList = b.m_edgeA;
    b.m_edgeB.joint = b;
    b.m_edgeB.other = b.m_bodyA;
    b.m_edgeB.prev = null;
    if (b.m_edgeB.next = b.m_bodyB.m_jointList)
        b.m_bodyB.m_jointList.prev = b.m_edgeB;
    b.m_bodyB.m_jointList = b.m_edgeB;
    var c = a.bodyA, e = a.bodyB;
    if (!1 == a.collideConnected)
        for (a = e.GetContactList(); a; )
            a.other == c && a.contact.FlagForFiltering(), a = a.next;
    return b
};
goog.exportProperty(box2d.b2World.prototype, "CreateJoint", box2d.b2World.prototype.CreateJoint);
box2d.b2World.prototype.DestroyJoint = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (!this.IsLocked()) {
        var b = a.m_collideConnected;
        a.m_prev && (a.m_prev.m_next = a.m_next);
        a.m_next && (a.m_next.m_prev = a.m_prev);
        a == this.m_jointList && (this.m_jointList = a.m_next);
        var c = a.m_bodyA, e = a.m_bodyB;
        c.SetAwake(!0);
        e.SetAwake(!0);
        a.m_edgeA.prev && (a.m_edgeA.prev.next = a.m_edgeA.next);
        a.m_edgeA.next && (a.m_edgeA.next.prev = a.m_edgeA.prev);
        a.m_edgeA == c.m_jointList && (c.m_jointList = a.m_edgeA.next);
        a.m_edgeA.prev =
                null;
        a.m_edgeA.next = null;
        a.m_edgeB.prev && (a.m_edgeB.prev.next = a.m_edgeB.next);
        a.m_edgeB.next && (a.m_edgeB.next.prev = a.m_edgeB.prev);
        a.m_edgeB == e.m_jointList && (e.m_jointList = a.m_edgeB.next);
        a.m_edgeB.prev = null;
        a.m_edgeB.next = null;
        box2d.b2JointFactory.Destroy(a, null);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(0 < this.m_jointCount);
        --this.m_jointCount;
        if (!1 == b)
            for (a = e.GetContactList(); a; )
                a.other == c && a.contact.FlagForFiltering(), a = a.next
    }
};
goog.exportProperty(box2d.b2World.prototype, "DestroyJoint", box2d.b2World.prototype.DestroyJoint);
box2d.b2World.prototype.Solve = function(a) {
    for (var b = this.m_controllerList; b; b = b.m_next)
        b.Step(a);
    this.m_profile.solveInit = 0;
    this.m_profile.solveVelocity = 0;
    this.m_profile.solvePosition = 0;
    b = this.m_island;
    b.Initialize(this.m_bodyCount, this.m_contactManager.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener);
    for (var c = this.m_bodyList; c; c = c.m_next)
        c.m_flags &= ~box2d.b2BodyFlag.e_islandFlag;
    for (var e = this.m_contactManager.m_contactList; e; e = e.m_next)
        e.m_flags &= ~box2d.b2ContactFlag.e_islandFlag;
    for (e = this.m_jointList; e; e = e.m_next)
        e.m_islandFlag = !1;
    for (var e = this.m_bodyCount, d = this.s_stack, f = this.m_bodyList; f; f = f.m_next)
        if (!(f.m_flags & box2d.b2BodyFlag.e_islandFlag) && !1 != f.IsAwake() && !1 != f.IsActive() && f.GetType() != box2d.b2BodyType.b2_staticBody) {
            b.Clear();
            var g = 0;
            d[g++] = f;
            for (f.m_flags |= box2d.b2BodyFlag.e_islandFlag; 0 < g; )
                if (c = d[--g], box2d.ENABLE_ASSERTS && box2d.b2Assert(!0 == c.IsActive()), b.AddBody(c), c.SetAwake(!0), c.GetType() != box2d.b2BodyType.b2_staticBody) {
                    for (var h = c.m_contactList; h; h =
                            h.next) {
                        var l = h.contact;
                        if (!(l.m_flags & box2d.b2ContactFlag.e_islandFlag) && !1 != l.IsEnabled() && !1 != l.IsTouching()) {
                            var k = l.m_fixtureB.m_isSensor;
                            l.m_fixtureA.m_isSensor || k || (b.AddContact(l), l.m_flags |= box2d.b2ContactFlag.e_islandFlag, l = h.other, l.m_flags & box2d.b2BodyFlag.e_islandFlag || (box2d.ENABLE_ASSERTS && box2d.b2Assert(g < e), d[g++] = l, l.m_flags |= box2d.b2BodyFlag.e_islandFlag))
                        }
                    }
                    for (c = c.m_jointList; c; c = c.next)
                        !0 != c.joint.m_islandFlag && (l = c.other, !1 != l.IsActive() && (b.AddJoint(c.joint), c.joint.m_islandFlag =
                                !0, l.m_flags & box2d.b2BodyFlag.e_islandFlag || (box2d.ENABLE_ASSERTS && box2d.b2Assert(g < e), d[g++] = l, l.m_flags |= box2d.b2BodyFlag.e_islandFlag)))
                }
            c = new box2d.b2Profile;
            b.Solve(c, a, this.m_gravity, this.m_allowSleep);
            this.m_profile.solveInit += c.solveInit;
            this.m_profile.solveVelocity += c.solveVelocity;
            this.m_profile.solvePosition += c.solvePosition;
            for (g = 0; g < b.m_bodyCount; ++g)
                c = b.m_bodies[g], c.GetType() == box2d.b2BodyType.b2_staticBody && (c.m_flags &= ~box2d.b2BodyFlag.e_islandFlag)
        }
    for (g = 0; g < d.length && d[g]; ++g)
        d[g] =
                null;
    a = new box2d.b2Timer;
    for (c = this.m_bodyList; c; c = c.m_next)
        0 != (c.m_flags & box2d.b2BodyFlag.e_islandFlag) && c.GetType() != box2d.b2BodyType.b2_staticBody && c.SynchronizeFixtures();
    this.m_contactManager.FindNewContacts();
    this.m_profile.broadphase = a.GetMilliseconds()
};
goog.exportProperty(box2d.b2World.prototype, "Solve", box2d.b2World.prototype.Solve);
box2d.b2World.prototype.SolveTOI = function(a) {
    var b = this.m_island;
    b.Initialize(2 * box2d.b2_maxTOIContacts, box2d.b2_maxTOIContacts, 0, null, this.m_contactManager.m_contactListener);
    if (this.m_stepComplete) {
        for (var c = this.m_bodyList; c; c = c.m_next)
            c.m_flags &= ~box2d.b2BodyFlag.e_islandFlag, c.m_sweep.alpha0 = 0;
        for (var e = this.m_contactManager.m_contactList; e; e = e.m_next)
            e.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag), e.m_toiCount = 0, e.m_toi = 1
    }
    for (; ; ) {
        for (var d = null, c = 1, e = this.m_contactManager.m_contactList; e; e =
                e.m_next)
            if (!1 != e.IsEnabled() && !(e.m_toiCount > box2d.b2_maxSubSteps)) {
                var f = 1;
                if (e.m_flags & box2d.b2ContactFlag.e_toiFlag)
                    f = e.m_toi;
                else {
                    var g = e.GetFixtureA(), h = e.GetFixtureB();
                    if (g.IsSensor() || h.IsSensor())
                        continue;
                    var f = g.GetBody(), l = h.GetBody(), k = f.m_type, m = l.m_type;
                    box2d.ENABLE_ASSERTS && box2d.b2Assert(k == box2d.b2BodyType.b2_dynamicBody || m == box2d.b2BodyType.b2_dynamicBody);
                    var n = f.IsAwake() && k != box2d.b2BodyType.b2_staticBody, p = l.IsAwake() && m != box2d.b2BodyType.b2_staticBody;
                    if (!1 == n && !1 == p)
                        continue;
                    k = f.IsBullet() || k != box2d.b2BodyType.b2_dynamicBody;
                    m = l.IsBullet() || m != box2d.b2BodyType.b2_dynamicBody;
                    if (!1 == k && !1 == m)
                        continue;
                    m = f.m_sweep.alpha0;
                    f.m_sweep.alpha0 < l.m_sweep.alpha0 ? (m = l.m_sweep.alpha0, f.m_sweep.Advance(m)) : l.m_sweep.alpha0 < f.m_sweep.alpha0 && (m = f.m_sweep.alpha0, l.m_sweep.Advance(m));
                    box2d.ENABLE_ASSERTS && box2d.b2Assert(1 > m);
                    n = e.GetChildIndexA();
                    p = e.GetChildIndexB();
                    k = box2d.b2World.prototype.SolveTOI.s_toi_input;
                    k.proxyA.SetShape(g.GetShape(), n);
                    k.proxyB.SetShape(h.GetShape(), p);
                    k.sweepA.Copy(f.m_sweep);
                    k.sweepB.Copy(l.m_sweep);
                    k.tMax = 1;
                    f = box2d.b2World.prototype.SolveTOI.s_toi_output;
                    box2d.b2TimeOfImpact(f, k);
                    l = f.t;
                    f = f.state == box2d.b2TOIOutputState.e_touching ? box2d.b2Min(m + (1 - m) * l, 1) : 1;
                    e.m_toi = f;
                    e.m_flags |= box2d.b2ContactFlag.e_toiFlag
                }
                f < c && (d = e, c = f)
            }
        if (null == d || 1 - 10 * box2d.b2_epsilon < c) {
            this.m_stepComplete = !0;
            break
        }
        g = d.GetFixtureA();
        h = d.GetFixtureB();
        f = g.GetBody();
        l = h.GetBody();
        e = box2d.b2World.prototype.SolveTOI.s_backup1.Copy(f.m_sweep);
        g = box2d.b2World.prototype.SolveTOI.s_backup2.Copy(l.m_sweep);
        f.Advance(c);
        l.Advance(c);
        d.Update(this.m_contactManager.m_contactListener);
        d.m_flags &= ~box2d.b2ContactFlag.e_toiFlag;
        ++d.m_toiCount;
        if (!1 == d.IsEnabled() || !1 == d.IsTouching())
            d.SetEnabled(!1), f.m_sweep.Copy(e), l.m_sweep.Copy(g), f.SynchronizeTransform(), l.SynchronizeTransform();
        else {
            f.SetAwake(!0);
            l.SetAwake(!0);
            b.Clear();
            b.AddBody(f);
            b.AddBody(l);
            b.AddContact(d);
            f.m_flags |= box2d.b2BodyFlag.e_islandFlag;
            l.m_flags |= box2d.b2BodyFlag.e_islandFlag;
            d.m_flags |= box2d.b2ContactFlag.e_islandFlag;
            for (d = 0; 2 > d; ++d)
                if (e =
                        0 == d ? f : l, e.m_type == box2d.b2BodyType.b2_dynamicBody)
                    for (g = e.m_contactList; g && b.m_bodyCount != b.m_bodyCapacity && b.m_contactCount != b.m_contactCapacity; g = g.next)
                        h = g.contact, h.m_flags & box2d.b2ContactFlag.e_islandFlag || (m = g.other, m.m_type == box2d.b2BodyType.b2_dynamicBody && !1 == e.IsBullet() && !1 == m.IsBullet()) || (k = h.m_fixtureB.m_isSensor, h.m_fixtureA.m_isSensor || k || (k = box2d.b2World.prototype.SolveTOI.s_backup.Copy(m.m_sweep), 0 == (m.m_flags & box2d.b2BodyFlag.e_islandFlag) && m.Advance(c), h.Update(this.m_contactManager.m_contactListener),
                                !1 == h.IsEnabled() ? (m.m_sweep.Copy(k), m.SynchronizeTransform()) : !1 == h.IsTouching() ? (m.m_sweep.Copy(k), m.SynchronizeTransform()) : (h.m_flags |= box2d.b2ContactFlag.e_islandFlag, b.AddContact(h), m.m_flags & box2d.b2BodyFlag.e_islandFlag || (m.m_flags |= box2d.b2BodyFlag.e_islandFlag, m.m_type != box2d.b2BodyType.b2_staticBody && m.SetAwake(!0), b.AddBody(m)))));
            d = box2d.b2World.prototype.SolveTOI.s_subStep;
            d.dt = (1 - c) * a.dt;
            d.inv_dt = 1 / d.dt;
            d.dtRatio = 1;
            d.positionIterations = 20;
            d.velocityIterations = a.velocityIterations;
            d.warmStarting =
                    !1;
            b.SolveTOI(d, f.m_islandIndex, l.m_islandIndex);
            for (d = 0; d < b.m_bodyCount; ++d)
                if (e = b.m_bodies[d], e.m_flags &= ~box2d.b2BodyFlag.e_islandFlag, e.m_type == box2d.b2BodyType.b2_dynamicBody)
                    for (e.SynchronizeFixtures(), g = e.m_contactList; g; g = g.next)
                        g.contact.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag);
            this.m_contactManager.FindNewContacts();
            if (this.m_subStepping) {
                this.m_stepComplete = !1;
                break
            }
        }
    }
};
goog.exportProperty(box2d.b2World.prototype, "SolveTOI", box2d.b2World.prototype.SolveTOI);
box2d.b2World.prototype.SolveTOI.s_subStep = new box2d.b2TimeStep;
box2d.b2World.prototype.SolveTOI.s_backup = new box2d.b2Sweep;
box2d.b2World.prototype.SolveTOI.s_backup1 = new box2d.b2Sweep;
box2d.b2World.prototype.SolveTOI.s_backup2 = new box2d.b2Sweep;
box2d.b2World.prototype.SolveTOI.s_toi_input = new box2d.b2TOIInput;
box2d.b2World.prototype.SolveTOI.s_toi_output = new box2d.b2TOIOutput;
box2d.b2World.prototype.Step = function(a, b, c) {
    var e = new box2d.b2Timer;
    this.m_flags & box2d.b2WorldFlag.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~box2d.b2WorldFlag.e_newFixture);
    this.m_flags |= box2d.b2WorldFlag.e_locked;
    var d = box2d.b2World.prototype.Step.s_step;
    d.dt = a;
    d.velocityIterations = b;
    d.positionIterations = c;
    d.inv_dt = 0 < a ? 1 / a : 0;
    d.dtRatio = this.m_inv_dt0 * a;
    d.warmStarting = this.m_warmStarting;
    a = new box2d.b2Timer;
    this.m_contactManager.Collide();
    this.m_profile.collide = a.GetMilliseconds();
    this.m_stepComplete && 0 < d.dt && (a = new box2d.b2Timer, this.Solve(d), this.m_profile.solve = a.GetMilliseconds());
    this.m_continuousPhysics && 0 < d.dt && (a = new box2d.b2Timer, this.SolveTOI(d), this.m_profile.solveTOI = a.GetMilliseconds());
    0 < d.dt && (this.m_inv_dt0 = d.inv_dt);
    this.m_flags & box2d.b2WorldFlag.e_clearForces && this.ClearForces();
    this.m_flags &= ~box2d.b2WorldFlag.e_locked;
    this.m_profile.step = e.GetMilliseconds()
};
goog.exportProperty(box2d.b2World.prototype, "Step", box2d.b2World.prototype.Step);
box2d.b2World.prototype.Step.s_step = new box2d.b2TimeStep;
box2d.b2World.prototype.ClearForces = function() {
    for (var a = this.m_bodyList; a; a = a.m_next)
        a.m_force.SetZero(), a.m_torque = 0
};
goog.exportProperty(box2d.b2World.prototype, "ClearForces", box2d.b2World.prototype.ClearForces);
box2d.b2World.prototype.QueryAABB = function(a, b) {
    var c = this.m_contactManager.m_broadPhase;
    c.Query(function(b) {
        b = c.GetUserData(b);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(b instanceof box2d.b2FixtureProxy);
        b = b.fixture;
        return a instanceof box2d.b2QueryCallback ? a.ReportFixture(b) : a(b)
    }, b)
};
goog.exportProperty(box2d.b2World.prototype, "QueryAABB", box2d.b2World.prototype.QueryAABB);
box2d.b2World.prototype.QueryShape = function(a, b, c) {
    var e = this.m_contactManager.m_broadPhase, d = box2d.b2World.prototype.QueryShape.s_aabb;
    b.ComputeAABB(d, c, 0);
    e.Query(function(d) {
        d = e.GetUserData(d);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2FixtureProxy);
        d = d.fixture;
        return box2d.b2TestOverlapShape(b, 0, d.GetShape(), 0, c, d.GetBody().GetTransform()) ? a instanceof box2d.b2QueryCallback ? a.ReportFixture(d) : a(d) : !0
    }, d)
};
goog.exportProperty(box2d.b2World.prototype, "QueryShape", box2d.b2World.prototype.QueryShape);
box2d.b2World.prototype.QueryShape.s_aabb = new box2d.b2AABB;
box2d.b2World.prototype.QueryPoint = function(a, b) {
    var c = this.m_contactManager.m_broadPhase, e = box2d.b2World.prototype.QueryPoint.s_aabb;
    e.lowerBound.SetXY(b.x - box2d.b2_linearSlop, b.y - box2d.b2_linearSlop);
    e.upperBound.SetXY(b.x + box2d.b2_linearSlop, b.y + box2d.b2_linearSlop);
    c.Query(function(d) {
        d = c.GetUserData(d);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(d instanceof box2d.b2FixtureProxy);
        d = d.fixture;
        return d.TestPoint(b) ? a instanceof box2d.b2QueryCallback ? a.ReportFixture(d) : a(d) : !0
    }, e)
};
goog.exportProperty(box2d.b2World.prototype, "QueryPoint", box2d.b2World.prototype.QueryPoint);
box2d.b2World.prototype.QueryPoint.s_aabb = new box2d.b2AABB;
box2d.b2World.prototype.RayCast = function(a, b, c) {
    var e = this.m_contactManager.m_broadPhase, d = box2d.b2World.prototype.RayCast.s_input;
    d.maxFraction = 1;
    d.p1.Copy(b);
    d.p2.Copy(c);
    e.RayCast(function(d, g) {
        var h = e.GetUserData(g);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(h instanceof box2d.b2FixtureProxy);
        var l = h.fixture, k = box2d.b2World.prototype.RayCast.s_output;
        if (l.RayCast(k, d, h.childIndex)) {
            var h = k.fraction, m = box2d.b2World.prototype.RayCast.s_point;
            m.SetXY((1 - h) * b.x + h * c.x, (1 - h) * b.y + h * c.y);
            return a instanceof
                    box2d.b2RayCastCallback ? a.ReportFixture(l, m, k.normal, h) : a(l, m, k.normal, h)
        }
        return d.maxFraction
    }, d)
};
goog.exportProperty(box2d.b2World.prototype, "RayCast", box2d.b2World.prototype.RayCast);
box2d.b2World.prototype.RayCast.s_input = new box2d.b2RayCastInput;
box2d.b2World.prototype.RayCast.s_output = new box2d.b2RayCastOutput;
box2d.b2World.prototype.RayCast.s_point = new box2d.b2Vec2;
box2d.b2World.prototype.RayCastOne = function(a, b) {
    var c = null, e = 1;
    this.RayCast(function(a, b, g, h) {
        h < e && (e = h, c = a);
        return e
    }, a, b);
    return c
};
goog.exportProperty(box2d.b2World.prototype, "RayCastOne", box2d.b2World.prototype.RayCastOne);
box2d.b2World.prototype.RayCastAll = function(a, b, c) {
    c.length = 0;
    this.RayCast(function(a, b, f, g) {
        c.push(a);
        return 1
    }, a, b);
    return c
};
goog.exportProperty(box2d.b2World.prototype, "RayCastAll", box2d.b2World.prototype.RayCastAll);
box2d.b2World.prototype.DrawShape = function(a, b) {
    var c = a.GetShape();
    switch (c.m_type) {
        case box2d.b2ShapeType.e_circleShape:
            c = c instanceof box2d.b2CircleShape ? c : null;
            this.m_debugDraw.DrawSolidCircle(c.m_p, c.m_radius, box2d.b2Vec2.UNITX, b);
            break;
        case box2d.b2ShapeType.e_edgeShape:
            var e = c instanceof box2d.b2EdgeShape ? c : null, c = e.m_vertex1, d = e.m_vertex2;
            this.m_debugDraw.DrawSegment(c, d, b);
            break;
        case box2d.b2ShapeType.e_chainShape:
            var c = c instanceof box2d.b2ChainShape ? c : null, e = c.m_count, f = c.m_vertices, c = f[0];
            this.m_debugDraw.DrawCircle(c, 0.05, b);
            for (var g = 1; g < e; ++g)
                d = f[g], this.m_debugDraw.DrawSegment(c, d, b), this.m_debugDraw.DrawCircle(d, 0.05, b), c = d;
            break;
        case box2d.b2ShapeType.e_polygonShape:
            e = c instanceof box2d.b2PolygonShape ? c : null, c = e.m_count, f = e.m_vertices, this.m_debugDraw.DrawSolidPolygon(f, c, b)
        }
};
goog.exportProperty(box2d.b2World.prototype, "DrawShape", box2d.b2World.prototype.DrawShape);
box2d.b2World.prototype.DrawJoint = function(a) {
    var b = a.GetBodyA(), c = a.GetBodyB(), e = b.m_xf.p, d = c.m_xf.p, c = a.GetAnchorA(box2d.b2World.prototype.DrawJoint.s_p1), b = a.GetAnchorB(box2d.b2World.prototype.DrawJoint.s_p2), f = box2d.b2World.prototype.DrawJoint.s_color.SetRGB(0.5, 0.8, 0.8);
    switch (a.m_type) {
        case box2d.b2JointType.e_distanceJoint:
            this.m_debugDraw.DrawSegment(c, b, f);
            break;
        case box2d.b2JointType.e_pulleyJoint:
            e = a instanceof box2d.b2PulleyJoint ? a : null;
            a = e.GetGroundAnchorA(box2d.b2World.prototype.DrawJoint.s_s1);
            e = e.GetGroundAnchorB(box2d.b2World.prototype.DrawJoint.s_s2);
            this.m_debugDraw.DrawSegment(a, c, f);
            this.m_debugDraw.DrawSegment(e, b, f);
            this.m_debugDraw.DrawSegment(a, e, f);
            break;
        case box2d.b2JointType.e_mouseJoint:
            this.m_debugDraw.DrawSegment(c, b, f);
            break;
        default:
            this.m_debugDraw.DrawSegment(e, c, f), this.m_debugDraw.DrawSegment(c, b, f), this.m_debugDraw.DrawSegment(d, b, f)
        }
};
goog.exportProperty(box2d.b2World.prototype, "DrawJoint", box2d.b2World.prototype.DrawJoint);
box2d.b2World.prototype.DrawJoint.s_p1 = new box2d.b2Vec2;
box2d.b2World.prototype.DrawJoint.s_p2 = new box2d.b2Vec2;
box2d.b2World.prototype.DrawJoint.s_color = new box2d.b2Color(0.5, 0.8, 0.8);
box2d.b2World.prototype.DrawJoint.s_s1 = new box2d.b2Vec2;
box2d.b2World.prototype.DrawJoint.s_s2 = new box2d.b2Vec2;
box2d.b2World.prototype.DrawDebugData = function() {
    if (null != this.m_debugDraw) {
        var a = this.m_debugDraw.GetFlags(), b = box2d.b2World.prototype.DrawDebugData.s_color.SetRGB(0, 0, 0);
        if (a & box2d.b2DrawFlags.e_shapeBit)
            for (var c = this.m_bodyList; c; c = c.m_next) {
                var e = c.m_xf;
                this.m_debugDraw.PushTransform(e);
                for (var d = c.GetFixtureList(); d; d = d.m_next)
                    !1 == c.IsActive() ? b.SetRGB(0.5, 0.5, 0.3) : c.GetType() == box2d.b2BodyType.b2_staticBody ? b.SetRGB(0.5, 0.9, 0.5) : c.GetType() == box2d.b2BodyType.b2_kinematicBody ? b.SetRGB(0.5, 0.5,
                            0.9) : !1 == c.IsAwake() ? b.SetRGB(0.6, 0.6, 0.6) : b.SetRGB(0.9, 0.7, 0.7), this.DrawShape(d, b);
                this.m_debugDraw.PopTransform(e)
            }
        if (a & box2d.b2DrawFlags.e_jointBit)
            for (c = this.m_jointList; c; c = c.m_next)
                this.DrawJoint(c);
        if (a & box2d.b2DrawFlags.e_aabbBit) {
            b.SetRGB(0.9, 0.3, 0.9);
            for (var e = this.m_contactManager.m_broadPhase, f = box2d.b2World.prototype.DrawDebugData.s_vs, c = this.m_bodyList; c; c = c.m_next)
                if (!1 != c.IsActive())
                    for (d = c.GetFixtureList(); d; d = d.m_next)
                        for (var g = 0; g < d.m_proxyCount; ++g) {
                            var h = e.GetFatAABB(d.m_proxies[g].proxy);
                            f[0].SetXY(h.lowerBound.x, h.lowerBound.y);
                            f[1].SetXY(h.upperBound.x, h.lowerBound.y);
                            f[2].SetXY(h.upperBound.x, h.upperBound.y);
                            f[3].SetXY(h.lowerBound.x, h.upperBound.y);
                            this.m_debugDraw.DrawPolygon(f, 4, b)
                        }
        }
        if (a & box2d.b2DrawFlags.e_centerOfMassBit)
            for (c = this.m_bodyList; c; c = c.m_next)
                e = box2d.b2World.prototype.DrawDebugData.s_xf, e.q.Copy(c.m_xf.q), e.p.Copy(c.GetWorldCenter()), this.m_debugDraw.DrawTransform(e);
        if (a & box2d.b2DrawFlags.e_controllerBit)
            for (a = this.m_controllerList; a; a = a.m_next)
                a.Draw(this.m_debugDraw)
    }
};
goog.exportProperty(box2d.b2World.prototype, "DrawDebugData", box2d.b2World.prototype.DrawDebugData);
box2d.b2World.prototype.DrawDebugData.s_color = new box2d.b2Color(0, 0, 0);
box2d.b2World.prototype.DrawDebugData.s_vs = box2d.b2Vec2.MakeArray(4);
box2d.b2World.prototype.DrawDebugData.s_xf = new box2d.b2Transform;
box2d.b2World.prototype.SetBroadPhase = function(a) {
    var b = this.m_contactManager.m_broadPhase;
    this.m_contactManager.m_broadPhase = a;
    for (var c = this.m_bodyList; c; c = c.m_next)
        for (var e = c.m_fixtureList; e; e = e.m_next)
            e.m_proxy = a.CreateProxy(b.GetFatAABB(e.m_proxy), e)
};
goog.exportProperty(box2d.b2World.prototype, "SetBroadPhase", box2d.b2World.prototype.SetBroadPhase);
box2d.b2World.prototype.GetProxyCount = function() {
    return this.m_contactManager.m_broadPhase.GetProxyCount()
};
goog.exportProperty(box2d.b2World.prototype, "GetProxyCount", box2d.b2World.prototype.GetProxyCount);
box2d.b2World.prototype.GetTreeHeight = function() {
    return this.m_contactManager.m_broadPhase.GetTreeHeight()
};
goog.exportProperty(box2d.b2World.prototype, "GetTreeHeight", box2d.b2World.prototype.GetTreeHeight);
box2d.b2World.prototype.GetTreeBalance = function() {
    return this.m_contactManager.m_broadPhase.GetTreeBalance()
};
goog.exportProperty(box2d.b2World.prototype, "GetTreeBalance", box2d.b2World.prototype.GetTreeBalance);
box2d.b2World.prototype.GetTreeQuality = function() {
    return this.m_contactManager.m_broadPhase.GetTreeQuality()
};
goog.exportProperty(box2d.b2World.prototype, "GetTreeQuality", box2d.b2World.prototype.GetTreeQuality);
box2d.b2World.prototype.ShiftOrigin = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 == this.IsLocked());
    if (!this.IsLocked()) {
        for (var b = this.m_bodyList; b; b = b.m_next)
            b.m_xf.p.SelfSub(a), b.m_sweep.c0.SelfSub(a), b.m_sweep.c.SelfSub(a);
        for (b = this.m_jointList; b; b = b.m_next)
            b.ShiftOrigin(a);
        this.m_contactManager.m_broadPhase.ShiftOrigin(a)
    }
};
goog.exportProperty(box2d.b2World.prototype, "ShiftOrigin", box2d.b2World.prototype.ShiftOrigin);
box2d.b2World.prototype.Dump = function() {
    if (box2d.DEBUG && (this.m_flags & box2d.b2WorldFlag.e_locked) != box2d.b2WorldFlag.e_locked) {
        box2d.b2Log("/** @type {box2d.b2Vec2} */ var g = new box2d.b2Vec2(%.15f, %.15f);\n", this.m_gravity.x, this.m_gravity.y);
        box2d.b2Log("this.m_world.SetGravity(g);\n");
        box2d.b2Log("/** @type {Array.<box2d.b2Body>} */ var bodies = new Array(%d);\n", this.m_bodyCount);
        box2d.b2Log("/** @type {Array.<box2d.b2Joint>} */ var joints = new Array(%d);\n", this.m_jointCount);
        for (var a = 0,
                b = this.m_bodyList; b; b = b.m_next)
            b.m_islandIndex = a, b.Dump(), ++a;
        a = 0;
        for (b = this.m_jointList; b; b = b.m_next)
            b.m_index = a, ++a;
        for (b = this.m_jointList; b; b = b.m_next)
            b.m_type != box2d.b2JointType.e_gearJoint && (box2d.b2Log("if (true)\n"), box2d.b2Log("{\n"), b.Dump(), box2d.b2Log("}\n"));
        for (b = this.m_jointList; b; b = b.m_next)
            b.m_type == box2d.b2JointType.e_gearJoint && (box2d.b2Log("if (true)\n"), box2d.b2Log("{\n"), b.Dump(), box2d.b2Log("}\n"))
    }
};
goog.exportProperty(box2d.b2World.prototype, "Dump", box2d.b2World.prototype.Dump);
box2d.b2World.prototype.AddController = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null === a.m_world, "Controller can only be a member of one world");
    a.m_world = this;
    a.m_next = this.m_controllerList;
    a.m_prev = null;
    this.m_controllerList && (this.m_controllerList.m_prev = a);
    this.m_controllerList = a;
    ++this.m_controllerCount;
    return a
};
goog.exportProperty(box2d.b2World.prototype, "AddController", box2d.b2World.prototype.AddController);
box2d.b2World.prototype.RemoveController = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.m_world === this, "Controller is not a member of this world");
    a.m_prev && (a.m_prev.m_next = a.m_next);
    a.m_next && (a.m_next.m_prev = a.m_prev);
    this.m_controllerList == a && (this.m_controllerList = a.m_next);
    --this.m_controllerCount;
    a.m_prev = null;
    a.m_next = null;
    a.m_world = null
};
goog.exportProperty(box2d.b2World.prototype, "RemoveController", box2d.b2World.prototype.RemoveController);
box2d.b2AreaJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_areaJoint);
    this.bodies = []
};
goog.inherits(box2d.b2AreaJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2AreaJointDef", box2d.b2AreaJointDef);
box2d.b2AreaJointDef.prototype.world = null;
goog.exportProperty(box2d.b2AreaJointDef.prototype, "world", box2d.b2AreaJointDef.prototype.world);
box2d.b2AreaJointDef.prototype.bodies = null;
goog.exportProperty(box2d.b2AreaJointDef.prototype, "bodies", box2d.b2AreaJointDef.prototype.bodies);
box2d.b2AreaJointDef.prototype.frequencyHz = 0;
goog.exportProperty(box2d.b2AreaJointDef.prototype, "frequencyHz", box2d.b2AreaJointDef.prototype.frequencyHz);
box2d.b2AreaJointDef.prototype.dampingRatio = 0;
goog.exportProperty(box2d.b2AreaJointDef.prototype, "dampingRatio", box2d.b2AreaJointDef.prototype.dampingRatio);
box2d.b2AreaJointDef.prototype.AddBody = function(a) {
    this.bodies.push(a);
    1 == this.bodies.length ? this.bodyA = a : 2 == this.bodies.length && (this.bodyB = a)
};
goog.exportProperty(box2d.b2AreaJointDef.prototype, "AddBody", box2d.b2AreaJointDef.prototype.AddBody);
box2d.b2AreaJoint = function(a) {
    box2d.b2Joint.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= a.bodies.length, "You cannot create an area joint with less than three bodies.");
    this.m_bodies = a.bodies;
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_targetLengths = box2d.b2MakeNumberArray(a.bodies.length);
    this.m_normals = box2d.b2Vec2.MakeArray(a.bodies.length);
    this.m_joints = Array(a.bodies.length);
    this.m_deltas = box2d.b2Vec2.MakeArray(a.bodies.length);
    this.m_delta = new box2d.b2Vec2;
    var b = new box2d.b2DistanceJointDef;
    b.frequencyHz = a.frequencyHz;
    b.dampingRatio = a.dampingRatio;
    for (var c = this.m_targetArea = 0, e = this.m_bodies.length; c < e; ++c) {
        var d = this.m_bodies[c], f = this.m_bodies[(c + 1) % e], g = d.GetWorldCenter(), h = f.GetWorldCenter();
        this.m_targetLengths[c] = box2d.b2DistanceVV(g, h);
        this.m_targetArea += box2d.b2CrossVV(g, h);
        b.Initialize(d, f, g, h);
        this.m_joints[c] = a.world.CreateJoint(b)
    }
    this.m_targetArea *= 0.5
};
goog.inherits(box2d.b2AreaJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2AreaJoint", box2d.b2AreaJoint);
box2d.b2AreaJoint.prototype.m_bodies = null;
goog.exportProperty(box2d.b2AreaJoint.prototype, "m_bodies", box2d.b2AreaJoint.prototype.m_bodies);
box2d.b2AreaJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2AreaJoint.prototype, "m_frequencyHz", box2d.b2AreaJoint.prototype.m_frequencyHz);
box2d.b2AreaJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2AreaJoint.prototype, "m_dampingRatio", box2d.b2AreaJoint.prototype.m_dampingRatio);
box2d.b2AreaJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2AreaJoint.prototype, "m_impulse", box2d.b2AreaJoint.prototype.m_impulse);
box2d.b2AreaJoint.prototype.m_targetLengths = null;
box2d.b2AreaJoint.prototype.m_targetArea = 0;
box2d.b2AreaJoint.prototype.m_normals = null;
box2d.b2AreaJoint.prototype.m_joints = null;
box2d.b2AreaJoint.prototype.m_deltas = null;
box2d.b2AreaJoint.prototype.m_delta = null;
box2d.b2AreaJoint.prototype.GetAnchorA = function(a) {
    return a.SetZero()
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetAnchorA", box2d.b2AreaJoint.prototype.GetAnchorA);
box2d.b2AreaJoint.prototype.GetAnchorB = function(a) {
    return a.SetZero()
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetAnchorB", box2d.b2AreaJoint.prototype.GetAnchorB);
box2d.b2AreaJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetZero()
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetReactionForce", box2d.b2AreaJoint.prototype.GetReactionForce);
box2d.b2AreaJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetReactionTorque", box2d.b2AreaJoint.prototype.GetReactionTorque);
box2d.b2AreaJoint.prototype.SetFrequency = function(a) {
    this.m_frequencyHz = a;
    for (var b = 0, c = this.m_joints.length; b < c; ++b)
        this.m_joints[b].SetFrequency(a)
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "SetFrequency", box2d.b2AreaJoint.prototype.SetFrequency);
box2d.b2AreaJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetFrequency", box2d.b2AreaJoint.prototype.GetFrequency);
box2d.b2AreaJoint.prototype.SetDampingRatio = function(a) {
    this.m_dampingRatio = a;
    for (var b = 0, c = this.m_joints.length; b < c; ++b)
        this.m_joints[b].SetDampingRatio(a)
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "SetDampingRatio", box2d.b2AreaJoint.prototype.SetDampingRatio);
box2d.b2AreaJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "GetDampingRatio", box2d.b2AreaJoint.prototype.GetDampingRatio);
box2d.b2AreaJoint.prototype.Dump = function() {
    box2d.DEBUG && box2d.b2Log("Area joint dumping is not supported.\n")
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "Dump", box2d.b2AreaJoint.prototype.Dump);
box2d.b2AreaJoint.prototype.InitVelocityConstraints = function(a) {
    for (var b = 0, c = this.m_bodies.length; b < c; ++b) {
        var e = this.m_deltas[b];
        box2d.b2SubVV(a.positions[this.m_bodies[(b + 1) % c].m_islandIndex].c, a.positions[this.m_bodies[(b + c - 1) % c].m_islandIndex].c, e)
    }
    if (a.step.warmStarting)
        for (this.m_impulse *= a.step.dtRatio, b = 0, c = this.m_bodies.length; b < c; ++b) {
            var d = this.m_bodies[b], f = a.velocities[d.m_islandIndex].v, e = this.m_deltas[b];
            f.x += 0.5 * (d.m_invMass * e.y) * this.m_impulse;
            f.y += 0.5 * (d.m_invMass * -e.x) * this.m_impulse
        }
    else
        this.m_impulse =
        0
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "InitVelocityConstraints", box2d.b2AreaJoint.prototype.InitVelocityConstraints);
box2d.b2AreaJoint.prototype.SolveVelocityConstraints = function(a) {
    for (var b = 0, c = 0, e = 0, d = this.m_bodies.length; e < d; ++e)
        var f = this.m_bodies[e], g = a.velocities[f.m_islandIndex].v, h = this.m_deltas[e], b = b + h.GetLengthSquared() / f.GetMass(), c = c + box2d.b2CrossVV(g, h);
    b = -2 * c / b;
    this.m_impulse += b;
    e = 0;
    for (d = this.m_bodies.length; e < d; ++e)
        f = this.m_bodies[e], g = a.velocities[f.m_islandIndex].v, h = this.m_deltas[e], g.x += 0.5 * (f.m_invMass * h.y) * b, g.y += 0.5 * (f.m_invMass * -h.x) * b
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "SolveVelocityConstraints", box2d.b2AreaJoint.prototype.SolveVelocityConstraints);
box2d.b2AreaJoint.prototype.SolvePositionConstraints = function(a) {
    for (var b = 0, c = 0, e = 0, d = this.m_bodies.length; e < d; ++e) {
        var f = this.m_bodies[e], f = a.positions[f.m_islandIndex].c, g = a.positions[this.m_bodies[(e + 1) % d].m_islandIndex].c, h = box2d.b2SubVV(g, f, this.m_delta), l = h.GetLength();
        l < box2d.b2_epsilon && (l = 1);
        this.m_normals[e].x = h.y / l;
        this.m_normals[e].y = -h.x / l;
        b += l;
        c += box2d.b2CrossVV(f, g)
    }
    b = 0.5 * (this.m_targetArea - 0.5 * c) / b;
    c = !0;
    e = 0;
    for (d = this.m_bodies.length; e < d; ++e)
        f = this.m_bodies[e], f = a.positions[f.m_islandIndex].c,
                h = box2d.b2AddVV(this.m_normals[e], this.m_normals[(e + 1) % d], this.m_delta), h.SelfMul(b), g = h.GetLengthSquared(), g > box2d.b2Sq(box2d.b2_maxLinearCorrection) && h.SelfMul(box2d.b2_maxLinearCorrection / box2d.b2Sqrt(g)), g > box2d.b2Sq(box2d.b2_linearSlop) && (c = !1), f.x += h.x, f.y += h.y;
    return c
};
goog.exportProperty(box2d.b2AreaJoint.prototype, "SolvePositionConstraints", box2d.b2AreaJoint.prototype.SolvePositionConstraints);
box2d.b2BuoyancyController = function() {
    box2d.b2Controller.call(this);
    this.normal = new box2d.b2Vec2(0, 1);
    this.velocity = new box2d.b2Vec2(0, 0);
    this.gravity = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2BuoyancyController, box2d.b2Controller);
goog.exportSymbol("box2d.b2BuoyancyController", box2d.b2BuoyancyController);
box2d.b2BuoyancyController.prototype.normal = null;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "normal", box2d.b2BuoyancyController.prototype.normal);
box2d.b2BuoyancyController.prototype.offset = 0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "offset", box2d.b2BuoyancyController.prototype.offset);
box2d.b2BuoyancyController.prototype.density = 0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "density", box2d.b2BuoyancyController.prototype.density);
box2d.b2BuoyancyController.prototype.velocity = null;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "velocity", box2d.b2BuoyancyController.prototype.velocity);
box2d.b2BuoyancyController.prototype.linearDrag = 0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "linearDrag", box2d.b2BuoyancyController.prototype.linearDrag);
box2d.b2BuoyancyController.prototype.angularDrag = 0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "angularDrag", box2d.b2BuoyancyController.prototype.angularDrag);
box2d.b2BuoyancyController.prototype.useDensity = !1;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "useDensity", box2d.b2BuoyancyController.prototype.useDensity);
box2d.b2BuoyancyController.prototype.useWorldGravity = !0;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "useWorldGravity", box2d.b2BuoyancyController.prototype.useWorldGravity);
box2d.b2BuoyancyController.prototype.gravity = null;
goog.exportProperty(box2d.b2BuoyancyController.prototype, "gravity", box2d.b2BuoyancyController.prototype.gravity);
box2d.b2BuoyancyController.prototype.Step = function(a) {
    if (this.m_bodyList)
        for (this.useWorldGravity && this.gravity.Copy(this.GetWorld().GetGravity()), a = this.m_bodyList; a; a = a.nextBody) {
            var b = a.body;
            if (!1 != b.IsAwake()) {
                for (var c = new box2d.b2Vec2, e = new box2d.b2Vec2, d = 0, f = 0, g = b.GetFixtureList(); g; g = g.m_next) {
                    var h = new box2d.b2Vec2, l = g.GetShape().ComputeSubmergedArea(this.normal, this.offset, b.GetTransform(), h), d = d + l;
                    c.x += l * h.x;
                    c.y += l * h.y;
                    var k = 0, k = this.useDensity ? g.GetDensity() : 1, f = f + l * k;
                    e.x += l * h.x * k;
                    e.y +=
                            l * h.y * k
                }
                c.x /= d;
                c.y /= d;
                e.x /= f;
                e.y /= f;
                d < box2d.b2_epsilon || (f = box2d.b2NegV(this.gravity, new box2d.b2Vec2), f.SelfMul(this.density * d), b.ApplyForce(f, e), e = b.GetLinearVelocityFromWorldPoint(c, new box2d.b2Vec2), e.SelfSub(this.velocity), e.SelfMul(-this.linearDrag * d), b.ApplyForce(e, c), b.ApplyTorque(-b.GetInertia() / b.GetMass() * d * b.GetAngularVelocity() * this.angularDrag))
            }
        }
};
goog.exportProperty(box2d.b2BuoyancyController.prototype, "Step", box2d.b2BuoyancyController.prototype.Step);
box2d.b2BuoyancyController.prototype.Draw = function(a) {
    var b = new box2d.b2Vec2, c = new box2d.b2Vec2;
    b.x = this.normal.x * this.offset + 100 * this.normal.y;
    b.y = this.normal.y * this.offset - 100 * this.normal.x;
    c.x = this.normal.x * this.offset - 100 * this.normal.y;
    c.y = this.normal.y * this.offset + 100 * this.normal.x;
    var e = new box2d.b2Color(0, 0, 0.8);
    a.DrawSegment(b, c, e)
};
goog.exportProperty(box2d.b2BuoyancyController.prototype, "Draw", box2d.b2BuoyancyController.prototype.Draw);
box2d.b2TensorDampingController = function() {
    box2d.b2Controller.call(this);
    this.T = new box2d.b2Mat22;
    this.maxTimestep = 0
};
goog.inherits(box2d.b2TensorDampingController, box2d.b2Controller);
goog.exportSymbol("box2d.b2TensorDampingController", box2d.b2TensorDampingController);
box2d.b2TensorDampingController.prototype.T = new box2d.b2Mat22;
goog.exportProperty(box2d.b2TensorDampingController.prototype, "T", box2d.b2TensorDampingController.prototype.T);
box2d.b2TensorDampingController.prototype.maxTimestep = 0;
goog.exportProperty(box2d.b2TensorDampingController.prototype, "maxTimestep", box2d.b2TensorDampingController.prototype.maxTimestep);
box2d.b2TensorDampingController.prototype.Step = function(a) {
    a = a.dt;
    if (!(a <= box2d.b2_epsilon)) {
        a > this.maxTimestep && 0 < this.maxTimestep && (a = this.maxTimestep);
        for (var b = this.m_bodyList; b; b = b.nextBody) {
            var c = b.body;
            if (c.IsAwake()) {
                var e = c.GetWorldVector(box2d.b2MulMV(this.T, c.GetLocalVector(c.GetLinearVelocity(), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1), box2d.b2TensorDampingController.prototype.Step.s_damping);
                c.SetLinearVelocity(box2d.b2AddVV(c.GetLinearVelocity(), box2d.b2MulSV(a, e, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1))
            }
        }
    }
};
box2d.b2TensorDampingController.prototype.Step.s_damping = new box2d.b2Vec2;
box2d.b2TensorDampingController.prototype.SetAxisAligned = function(a, b) {
    this.T.ex.x = -a;
    this.T.ex.y = 0;
    this.T.ey.x = 0;
    this.T.ey.y = -b;
    this.maxTimestep = 0 < a || 0 < b ? 1 / box2d.b2Max(a, b) : 0
};
box2d.b2DistanceJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_distanceJoint);
    this.localAnchorA = new box2d.b2Vec2;
    this.localAnchorB = new box2d.b2Vec2
};
goog.inherits(box2d.b2DistanceJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2DistanceJointDef", box2d.b2DistanceJointDef);
box2d.b2DistanceJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "localAnchorA", box2d.b2DistanceJointDef.prototype.localAnchorA);
box2d.b2DistanceJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "localAnchorB", box2d.b2DistanceJointDef.prototype.localAnchorB);
box2d.b2DistanceJointDef.prototype.length = 1;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "length", box2d.b2DistanceJointDef.prototype.length);
box2d.b2DistanceJointDef.prototype.frequencyHz = 0;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "frequencyHz", box2d.b2DistanceJointDef.prototype.frequencyHz);
box2d.b2DistanceJointDef.prototype.dampingRatio = 0;
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "dampingRatio", box2d.b2DistanceJointDef.prototype.dampingRatio);
box2d.b2DistanceJointDef.prototype.Initialize = function(a, b, c, e) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(e, this.localAnchorB);
    this.length = box2d.b2DistanceVV(c, e);
    this.dampingRatio = this.frequencyHz = 0
};
goog.exportProperty(box2d.b2DistanceJointDef.prototype, "Initialize", box2d.b2DistanceJointDef.prototype.Initialize);
box2d.b2DistanceJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_u = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_length = a.length
};
goog.inherits(box2d.b2DistanceJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2DistanceJoint", box2d.b2DistanceJoint);
box2d.b2DistanceJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_frequencyHz", box2d.b2DistanceJoint.prototype.m_frequencyHz);
box2d.b2DistanceJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_dampingRatio", box2d.b2DistanceJoint.prototype.m_dampingRatio);
box2d.b2DistanceJoint.prototype.m_bias = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_bias", box2d.b2DistanceJoint.prototype.m_bias);
box2d.b2DistanceJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_localAnchorA", box2d.b2DistanceJoint.prototype.m_localAnchorA);
box2d.b2DistanceJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_localAnchorB", box2d.b2DistanceJoint.prototype.m_localAnchorB);
box2d.b2DistanceJoint.prototype.m_gamma = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_gamma", box2d.b2DistanceJoint.prototype.m_gamma);
box2d.b2DistanceJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_impulse", box2d.b2DistanceJoint.prototype.m_impulse);
box2d.b2DistanceJoint.prototype.m_length = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_length", box2d.b2DistanceJoint.prototype.m_length);
box2d.b2DistanceJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_indexA", box2d.b2DistanceJoint.prototype.m_indexA);
box2d.b2DistanceJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_indexB", box2d.b2DistanceJoint.prototype.m_indexB);
box2d.b2DistanceJoint.prototype.m_u = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_u", box2d.b2DistanceJoint.prototype.m_u);
box2d.b2DistanceJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_rA", box2d.b2DistanceJoint.prototype.m_rA);
box2d.b2DistanceJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_rB", box2d.b2DistanceJoint.prototype.m_rB);
box2d.b2DistanceJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_localCenterA", box2d.b2DistanceJoint.prototype.m_localCenterA);
box2d.b2DistanceJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_localCenterB", box2d.b2DistanceJoint.prototype.m_localCenterB);
box2d.b2DistanceJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_invMassA", box2d.b2DistanceJoint.prototype.m_invMassA);
box2d.b2DistanceJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_invMassB", box2d.b2DistanceJoint.prototype.m_invMassB);
box2d.b2DistanceJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_invIA", box2d.b2DistanceJoint.prototype.m_invIA);
box2d.b2DistanceJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_invIB", box2d.b2DistanceJoint.prototype.m_invIB);
box2d.b2DistanceJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_mass", box2d.b2DistanceJoint.prototype.m_mass);
box2d.b2DistanceJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_qA", box2d.b2DistanceJoint.prototype.m_qA);
box2d.b2DistanceJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_qB", box2d.b2DistanceJoint.prototype.m_qB);
box2d.b2DistanceJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_lalcA", box2d.b2DistanceJoint.prototype.m_lalcA);
box2d.b2DistanceJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2DistanceJoint.prototype, "m_lalcB", box2d.b2DistanceJoint.prototype.m_lalcB);
box2d.b2DistanceJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetAnchorA", box2d.b2DistanceJoint.prototype.GetAnchorA);
box2d.b2DistanceJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetAnchorB", box2d.b2DistanceJoint.prototype.GetAnchorB);
box2d.b2DistanceJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_impulse * this.m_u.x, a * this.m_impulse * this.m_u.y)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetReactionForce", box2d.b2DistanceJoint.prototype.GetReactionForce);
box2d.b2DistanceJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetReactionTorque", box2d.b2DistanceJoint.prototype.GetReactionTorque);
box2d.b2DistanceJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetLocalAnchorA", box2d.b2DistanceJoint.prototype.GetLocalAnchorA);
box2d.b2DistanceJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetLocalAnchorB", box2d.b2DistanceJoint.prototype.GetLocalAnchorB);
box2d.b2DistanceJoint.prototype.SetLength = function(a) {
    this.m_length = a
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SetLength", box2d.b2DistanceJoint.prototype.SetLength);
box2d.b2DistanceJoint.prototype.GetLength = function() {
    return this.m_length
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetLength", box2d.b2DistanceJoint.prototype.GetLength);
box2d.b2DistanceJoint.prototype.SetFrequency = function(a) {
    this.m_frequencyHz = a
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SetFrequency", box2d.b2DistanceJoint.prototype.SetFrequency);
box2d.b2DistanceJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetFrequency", box2d.b2DistanceJoint.prototype.GetFrequency);
box2d.b2DistanceJoint.prototype.SetDampingRatio = function(a) {
    this.m_dampingRatio = a
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SetDampingRatio", box2d.b2DistanceJoint.prototype.SetDampingRatio);
box2d.b2DistanceJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "GetDampingRatio", box2d.b2DistanceJoint.prototype.GetDampingRatio);
box2d.b2DistanceJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2DistanceJointDef*/ var jd = new box2d.b2DistanceJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.length = %.15f;\n", this.m_length);
        box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
        box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "Dump", box2d.b2DistanceJoint.prototype.Dump);
box2d.b2DistanceJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].c, f = a.positions[this.m_indexB].a, g = a.velocities[this.m_indexB].v, h = a.velocities[this.m_indexB].w, l = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), f = this.m_qB.SetAngleRadians(f);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(f, this.m_lalcB, this.m_rB);
    this.m_u.x = d.x + this.m_rB.x - b.x - this.m_rA.x;
    this.m_u.y = d.y + this.m_rB.y -
            b.y - this.m_rA.y;
    d = this.m_u.GetLength();
    d > box2d.b2_linearSlop ? this.m_u.SelfMul(1 / d) : this.m_u.SetZero();
    b = box2d.b2CrossVV(this.m_rA, this.m_u);
    l = box2d.b2CrossVV(this.m_rB, this.m_u);
    b = this.m_invMassA + this.m_invIA * b * b + this.m_invMassB + this.m_invIB * l * l;
    this.m_mass = 0 != b ? 1 / b : 0;
    if (0 < this.m_frequencyHz) {
        var d = d - this.m_length, l = 2 * box2d.b2_pi * this.m_frequencyHz, f = this.m_mass * l * l, k = a.step.dt;
        this.m_gamma = k * (2 * this.m_mass * this.m_dampingRatio * l + k * f);
        this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;
        this.m_bias = d * k * f *
                this.m_gamma;
        b += this.m_gamma;
        this.m_mass = 0 != b ? 1 / b : 0
    } else
        this.m_bias = this.m_gamma = 0;
    a.step.warmStarting ? (this.m_impulse *= a.step.dtRatio, b = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P), c.SelfMulSub(this.m_invMassA, b), e -= this.m_invIA * box2d.b2CrossVV(this.m_rA, b), g.SelfMulAdd(this.m_invMassB, b), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, b)) : this.m_impulse = 0;
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w = h
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "InitVelocityConstraints", box2d.b2DistanceJoint.prototype.InitVelocityConstraints);
box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA), g = box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB), f = box2d.b2DotVV(this.m_u, box2d.b2SubVV(g, f, box2d.b2Vec2.s_t0)), f = -this.m_mass * (f + this.m_bias + this.m_gamma *
            this.m_impulse);
    this.m_impulse += f;
    f = box2d.b2MulSV(f, this.m_u, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P);
    b.SelfMulSub(this.m_invMassA, f);
    c -= this.m_invIA * box2d.b2CrossVV(this.m_rA, f);
    e.SelfMulAdd(this.m_invMassB, f);
    d += this.m_invIB * box2d.b2CrossVV(this.m_rB, f);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SolveVelocityConstraints", box2d.b2DistanceJoint.prototype.SolveVelocityConstraints);
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2;
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2;
box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2DistanceJoint.prototype.SolvePositionConstraints = function(a) {
    if (0 < this.m_frequencyHz)
        return!0;
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a;
    this.m_qA.SetAngleRadians(c);
    this.m_qB.SetAngleRadians(d);
    var f = box2d.b2MulRV(this.m_qA, this.m_lalcA, this.m_rA), g = box2d.b2MulRV(this.m_qB, this.m_lalcB, this.m_rB), h = this.m_u;
    h.x = e.x + g.x - b.x - f.x;
    h.y = e.y + g.y - b.y - f.y;
    var l = this.m_u.Normalize() - this.m_length, l = box2d.b2Clamp(l,
            -box2d.b2_maxLinearCorrection, box2d.b2_maxLinearCorrection), h = box2d.b2MulSV(-this.m_mass * l, h, box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P);
    b.SelfMulSub(this.m_invMassA, h);
    c -= this.m_invIA * box2d.b2CrossVV(f, h);
    e.SelfMulAdd(this.m_invMassB, h);
    d += this.m_invIB * box2d.b2CrossVV(g, h);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return box2d.b2Abs(l) < box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2DistanceJoint.prototype, "SolvePositionConstraints", box2d.b2DistanceJoint.prototype.SolvePositionConstraints);
box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2FrictionJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_frictionJoint);
    this.localAnchorA = new box2d.b2Vec2;
    this.localAnchorB = new box2d.b2Vec2
};
goog.inherits(box2d.b2FrictionJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2FrictionJointDef", box2d.b2FrictionJointDef);
box2d.b2FrictionJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "localAnchorA", box2d.b2FrictionJointDef.prototype.localAnchorA);
box2d.b2FrictionJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "localAnchorB", box2d.b2FrictionJointDef.prototype.localAnchorB);
box2d.b2FrictionJointDef.prototype.maxForce = 0;
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "maxForce", box2d.b2FrictionJointDef.prototype.maxForce);
box2d.b2FrictionJointDef.prototype.maxTorque = 0;
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "maxTorque", box2d.b2FrictionJointDef.prototype.maxTorque);
box2d.b2FrictionJointDef.prototype.Initialize = function(a, b, c) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB)
};
goog.exportProperty(box2d.b2FrictionJointDef.prototype, "Initialize", box2d.b2FrictionJointDef.prototype.Initialize);
box2d.b2FrictionJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_linearImpulse = (new box2d.b2Vec2).SetZero();
    this.m_maxForce = a.maxForce;
    this.m_maxTorque = a.maxTorque;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_linearMass = (new box2d.b2Mat22).SetZero();
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_K = new box2d.b2Mat22
};
goog.inherits(box2d.b2FrictionJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2FrictionJoint", box2d.b2FrictionJoint);
box2d.b2FrictionJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_localAnchorA", box2d.b2FrictionJoint.prototype.m_localAnchorA);
box2d.b2FrictionJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_localAnchorB", box2d.b2FrictionJoint.prototype.m_localAnchorB);
box2d.b2FrictionJoint.prototype.m_linearImpulse = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_linearImpulse", box2d.b2FrictionJoint.prototype.m_linearImpulse);
box2d.b2FrictionJoint.prototype.m_angularImpulse = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_angularImpulse", box2d.b2FrictionJoint.prototype.m_angularImpulse);
box2d.b2FrictionJoint.prototype.m_maxForce = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_maxForce", box2d.b2FrictionJoint.prototype.m_maxForce);
box2d.b2FrictionJoint.prototype.m_maxTorque = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_maxTorque", box2d.b2FrictionJoint.prototype.m_maxTorque);
box2d.b2FrictionJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_indexA", box2d.b2FrictionJoint.prototype.m_indexA);
box2d.b2FrictionJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_indexB", box2d.b2FrictionJoint.prototype.m_indexB);
box2d.b2FrictionJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_rA", box2d.b2FrictionJoint.prototype.m_rA);
box2d.b2FrictionJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_rB", box2d.b2FrictionJoint.prototype.m_rB);
box2d.b2FrictionJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_localCenterA", box2d.b2FrictionJoint.prototype.m_localCenterA);
box2d.b2FrictionJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_localCenterB", box2d.b2FrictionJoint.prototype.m_localCenterB);
box2d.b2FrictionJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_invMassA", box2d.b2FrictionJoint.prototype.m_invMassA);
box2d.b2FrictionJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_invMassB", box2d.b2FrictionJoint.prototype.m_invMassB);
box2d.b2FrictionJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_invIA", box2d.b2FrictionJoint.prototype.m_invIA);
box2d.b2FrictionJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_invIB", box2d.b2FrictionJoint.prototype.m_invIB);
box2d.b2FrictionJoint.prototype.m_linearMass = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_linearMass", box2d.b2FrictionJoint.prototype.m_linearMass);
box2d.b2FrictionJoint.prototype.m_angularMass = 0;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_angularMass", box2d.b2FrictionJoint.prototype.m_angularMass);
box2d.b2FrictionJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_qA", box2d.b2FrictionJoint.prototype.m_qA);
box2d.b2FrictionJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_qB", box2d.b2FrictionJoint.prototype.m_qB);
box2d.b2FrictionJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_lalcA", box2d.b2FrictionJoint.prototype.m_lalcA);
box2d.b2FrictionJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_lalcB", box2d.b2FrictionJoint.prototype.m_lalcB);
box2d.b2FrictionJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2FrictionJoint.prototype, "m_K", box2d.b2FrictionJoint.prototype.m_K);
box2d.b2FrictionJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.positions[this.m_indexB].a,
            d = a.velocities[this.m_indexB].v, f = a.velocities[this.m_indexB].w, g = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), e = this.m_qB.SetAngleRadians(e);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    g = box2d.b2MulRV(g, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var h = box2d.b2MulRV(e, this.m_lalcB, this.m_rB), e = this.m_invMassA, l = this.m_invMassB, k = this.m_invIA, m = this.m_invIB, n = this.m_K;
    n.ex.x = e + l + k * g.y * g.y + m * h.y * h.y;
    n.ex.y = -k * g.x * g.y -
            m * h.x * h.y;
    n.ey.x = n.ex.y;
    n.ey.y = e + l + k * g.x * g.x + m * h.x * h.x;
    n.GetInverse(this.m_linearMass);
    this.m_angularMass = k + m;
    0 < this.m_angularMass && (this.m_angularMass = 1 / this.m_angularMass);
    a.step.warmStarting ? (this.m_linearImpulse.SelfMul(a.step.dtRatio), this.m_angularImpulse *= a.step.dtRatio, g = this.m_linearImpulse, b.SelfMulSub(e, g), c -= k * (box2d.b2CrossVV(this.m_rA, g) + this.m_angularImpulse), d.SelfMulAdd(l, g), f += m * (box2d.b2CrossVV(this.m_rB, g) + this.m_angularImpulse)) : (this.m_linearImpulse.SetZero(), this.m_angularImpulse =
            0);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = f
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "InitVelocityConstraints", box2d.b2FrictionJoint.prototype.InitVelocityConstraints);
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB, k = a.step.dt, m, n = -this.m_angularMass * (d - c), p = this.m_angularImpulse;
    m = k * this.m_maxTorque;
    this.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + n, -m, m);
    n = this.m_angularImpulse - p;
    c -= h * n;
    d += l * n;
    m = box2d.b2SubVV(box2d.b2AddVCrossSV(e, d, this.m_rB,
            box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot);
    n = box2d.b2MulMV(this.m_linearMass, m, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV).SelfNeg();
    p = box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV.Copy(this.m_linearImpulse);
    this.m_linearImpulse.SelfAdd(n);
    m = k * this.m_maxForce;
    this.m_linearImpulse.GetLengthSquared() > m * m && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.SelfMul(m));
    box2d.b2SubVV(this.m_linearImpulse, p, n);
    b.SelfMulSub(f, n);
    c -= h * box2d.b2CrossVV(this.m_rA, n);
    e.SelfMulAdd(g, n);
    d += l * box2d.b2CrossVV(this.m_rB, n);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "SolveVelocityConstraints", box2d.b2FrictionJoint.prototype.SolveVelocityConstraints);
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2;
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV = new box2d.b2Vec2;
box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV = new box2d.b2Vec2;
box2d.b2FrictionJoint.prototype.SolvePositionConstraints = function(a) {
    return!0
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "SolvePositionConstraints", box2d.b2FrictionJoint.prototype.SolvePositionConstraints);
box2d.b2FrictionJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetAnchorA", box2d.b2FrictionJoint.prototype.GetAnchorA);
box2d.b2FrictionJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetAnchorB", box2d.b2FrictionJoint.prototype.GetAnchorB);
box2d.b2FrictionJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_linearImpulse.x, a * this.m_linearImpulse.y)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetReactionForce", box2d.b2FrictionJoint.prototype.GetReactionForce);
box2d.b2FrictionJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_angularImpulse
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetReactionTorque", box2d.b2FrictionJoint.prototype.GetReactionTorque);
box2d.b2FrictionJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetLocalAnchorA", box2d.b2FrictionJoint.prototype.GetLocalAnchorA);
box2d.b2FrictionJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetLocalAnchorB", box2d.b2FrictionJoint.prototype.GetLocalAnchorB);
box2d.b2FrictionJoint.prototype.SetMaxForce = function(a) {
    this.m_maxForce = a
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "SetMaxForce", box2d.b2FrictionJoint.prototype.SetMaxForce);
box2d.b2FrictionJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetMaxForce", box2d.b2FrictionJoint.prototype.GetMaxForce);
box2d.b2FrictionJoint.prototype.SetMaxTorque = function(a) {
    this.m_maxTorque = a
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "SetMaxTorque", box2d.b2FrictionJoint.prototype.SetMaxTorque);
box2d.b2FrictionJoint.prototype.GetMaxTorque = function() {
    return this.m_maxTorque
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "GetMaxTorque", box2d.b2FrictionJoint.prototype.GetMaxTorque);
box2d.b2FrictionJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2FrictionJointDef*/ var jd = new box2d.b2FrictionJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.maxForce = %.15f;\n", this.m_maxForce);
        box2d.b2Log("  jd.maxTorque = %.15f;\n", this.m_maxTorque);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2FrictionJoint.prototype, "Dump", box2d.b2FrictionJoint.prototype.Dump);
box2d.b2MouseJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_mouseJoint);
    this.target = new box2d.b2Vec2
};
goog.inherits(box2d.b2MouseJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2MouseJointDef", box2d.b2MouseJointDef);
box2d.b2MouseJointDef.prototype.target = null;
goog.exportProperty(box2d.b2MouseJointDef.prototype, "target", box2d.b2MouseJointDef.prototype.target);
box2d.b2MouseJointDef.prototype.maxForce = 0;
goog.exportProperty(box2d.b2MouseJointDef.prototype, "maxForce", box2d.b2MouseJointDef.prototype.maxForce);
box2d.b2MouseJointDef.prototype.frequencyHz = 5;
goog.exportProperty(box2d.b2MouseJointDef.prototype, "frequencyHz", box2d.b2MouseJointDef.prototype.frequencyHz);
box2d.b2MouseJointDef.prototype.dampingRatio = 0.7;
goog.exportProperty(box2d.b2MouseJointDef.prototype, "dampingRatio", box2d.b2MouseJointDef.prototype.dampingRatio);
box2d.b2MouseJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_localAnchorB = new box2d.b2Vec2;
    this.m_targetA = new box2d.b2Vec2;
    this.m_impulse = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_mass = new box2d.b2Mat22;
    this.m_C = new box2d.b2Vec2;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_K = new box2d.b2Mat22;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a.target.IsValid());
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.maxForce) && 0 <= a.maxForce);
    box2d.ENABLE_ASSERTS &&
            box2d.b2Assert(box2d.b2IsValid(a.frequencyHz) && 0 <= a.frequencyHz);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a.dampingRatio) && 0 <= a.dampingRatio);
    this.m_targetA.Copy(a.target);
    box2d.b2MulTXV(this.m_bodyB.GetTransform(), this.m_targetA, this.m_localAnchorB);
    this.m_maxForce = a.maxForce;
    this.m_impulse.SetZero();
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_gamma = this.m_beta = 0
};
goog.inherits(box2d.b2MouseJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2MouseJoint", box2d.b2MouseJoint);
box2d.b2MouseJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_localAnchorB", box2d.b2MouseJoint.prototype.m_localAnchorB);
box2d.b2MouseJoint.prototype.m_targetA = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_targetA", box2d.b2MouseJoint.prototype.m_targetA);
box2d.b2MouseJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_frequencyHz", box2d.b2MouseJoint.prototype.m_frequencyHz);
box2d.b2MouseJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_dampingRatio", box2d.b2MouseJoint.prototype.m_dampingRatio);
box2d.b2MouseJoint.prototype.m_beta = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_beta", box2d.b2MouseJoint.prototype.m_beta);
box2d.b2MouseJoint.prototype.m_impulse = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_impulse", box2d.b2MouseJoint.prototype.m_impulse);
box2d.b2MouseJoint.prototype.m_maxForce = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_maxForce", box2d.b2MouseJoint.prototype.m_maxForce);
box2d.b2MouseJoint.prototype.m_gamma = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_gamma", box2d.b2MouseJoint.prototype.m_gamma);
box2d.b2MouseJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_indexA", box2d.b2MouseJoint.prototype.m_indexA);
box2d.b2MouseJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_indexB", box2d.b2MouseJoint.prototype.m_indexB);
box2d.b2MouseJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_rB", box2d.b2MouseJoint.prototype.m_rB);
box2d.b2MouseJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_localCenterB", box2d.b2MouseJoint.prototype.m_localCenterB);
box2d.b2MouseJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_invMassB", box2d.b2MouseJoint.prototype.m_invMassB);
box2d.b2MouseJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_invIB", box2d.b2MouseJoint.prototype.m_invIB);
box2d.b2MouseJoint.prototype.m_mass = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_mass", box2d.b2MouseJoint.prototype.m_mass);
box2d.b2MouseJoint.prototype.m_C = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_C", box2d.b2MouseJoint.prototype.m_C);
box2d.b2MouseJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_qB", box2d.b2MouseJoint.prototype.m_qB);
box2d.b2MouseJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_lalcB", box2d.b2MouseJoint.prototype.m_lalcB);
box2d.b2MouseJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2MouseJoint.prototype, "m_K", box2d.b2MouseJoint.prototype.m_K);
box2d.b2MouseJoint.prototype.SetTarget = function(a) {
    !1 == this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(!0);
    this.m_targetA.Copy(a)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SetTarget", box2d.b2MouseJoint.prototype.SetTarget);
box2d.b2MouseJoint.prototype.GetTarget = function(a) {
    return a.Copy(this.m_targetA)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetTarget", box2d.b2MouseJoint.prototype.GetTarget);
box2d.b2MouseJoint.prototype.SetMaxForce = function(a) {
    this.m_maxForce = a
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SetMaxForce", box2d.b2MouseJoint.prototype.SetMaxForce);
box2d.b2MouseJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetMaxForce", box2d.b2MouseJoint.prototype.GetMaxForce);
box2d.b2MouseJoint.prototype.SetFrequency = function(a) {
    this.m_frequencyHz = a
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SetFrequency", box2d.b2MouseJoint.prototype.SetFrequency);
box2d.b2MouseJoint.prototype.GetFrequency = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetFrequency", box2d.b2MouseJoint.prototype.GetFrequency);
box2d.b2MouseJoint.prototype.SetDampingRatio = function(a) {
    this.m_dampingRatio = a
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SetDampingRatio", box2d.b2MouseJoint.prototype.SetDampingRatio);
box2d.b2MouseJoint.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetDampingRatio", box2d.b2MouseJoint.prototype.GetDampingRatio);
box2d.b2MouseJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexB].c, c = a.velocities[this.m_indexB].v, e = a.velocities[this.m_indexB].w, d = this.m_qB.SetAngleRadians(a.positions[this.m_indexB].a), f = this.m_bodyB.GetMass(), g = 2 * box2d.b2_pi * this.m_frequencyHz, h = 2 * f * this.m_dampingRatio * g, f = f * g * g, g = a.step.dt;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(h + g * f > box2d.b2_epsilon);
    this.m_gamma = g * (h + g * f);
    0 != this.m_gamma && (this.m_gamma = 1 / this.m_gamma);
    this.m_beta = g * f * this.m_gamma;
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(d, this.m_lalcB, this.m_rB);
    d = this.m_K;
    d.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;
    d.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
    d.ey.x = d.ex.y;
    d.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;
    d.GetInverse(this.m_mass);
    this.m_C.x = b.x + this.m_rB.x - this.m_targetA.x;
    this.m_C.y = b.y + this.m_rB.y - this.m_targetA.y;
    this.m_C.SelfMul(this.m_beta);
    e *= 0.98;
    a.step.warmStarting ? (this.m_impulse.SelfMul(a.step.dtRatio), c.x += this.m_invMassB * this.m_impulse.x, c.y += this.m_invMassB * this.m_impulse.y, e += this.m_invIB * box2d.b2CrossVV(this.m_rB, this.m_impulse)) : this.m_impulse.SetZero();
    a.velocities[this.m_indexB].w = e
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "InitVelocityConstraints", box2d.b2MouseJoint.prototype.InitVelocityConstraints);
box2d.b2MouseJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexB].v, c = a.velocities[this.m_indexB].w, e = box2d.b2AddVCrossSV(b, c, this.m_rB, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot), e = box2d.b2MulMV(this.m_mass, box2d.b2AddVV(e, box2d.b2AddVV(this.m_C, box2d.b2MulSV(this.m_gamma, this.m_impulse, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0).SelfNeg(), box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse), d = box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_impulse);
    this.m_impulse.SelfAdd(e);
    var f = a.step.dt * this.m_maxForce;
    this.m_impulse.GetLengthSquared() > f * f && this.m_impulse.SelfMul(f / this.m_impulse.GetLength());
    box2d.b2SubVV(this.m_impulse, d, e);
    b.SelfMulAdd(this.m_invMassB, e);
    c += this.m_invIB * box2d.b2CrossVV(this.m_rB, e);
    a.velocities[this.m_indexB].w = c
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SolveVelocityConstraints", box2d.b2MouseJoint.prototype.SolveVelocityConstraints);
box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2;
box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2;
box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2;
box2d.b2MouseJoint.prototype.SolvePositionConstraints = function(a) {
    return!0
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "SolvePositionConstraints", box2d.b2MouseJoint.prototype.SolvePositionConstraints);
box2d.b2MouseJoint.prototype.GetAnchorA = function(a) {
    return a.Copy(this.m_targetA)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetAnchorA", box2d.b2MouseJoint.prototype.GetAnchorA);
box2d.b2MouseJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetAnchorB", box2d.b2MouseJoint.prototype.GetAnchorB);
box2d.b2MouseJoint.prototype.GetReactionForce = function(a, b) {
    return box2d.b2MulSV(a, this.m_impulse, b)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetReactionForce", box2d.b2MouseJoint.prototype.GetReactionForce);
box2d.b2MouseJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "GetReactionTorque", box2d.b2MouseJoint.prototype.GetReactionTorque);
box2d.b2MouseJoint.prototype.Dump = function() {
    box2d.DEBUG && box2d.b2Log("Mouse joint dumping is not supported.\n")
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "Dump", box2d.b2MouseJoint.prototype.Dump);
box2d.b2MouseJoint.prototype.ShiftOrigin = function(a) {
    this.m_targetA.SelfSub(a)
};
goog.exportProperty(box2d.b2MouseJoint.prototype, "ShiftOrigin", box2d.b2MouseJoint.prototype.ShiftOrigin);
box2d.b2ConstantForceController = function() {
    box2d.b2Controller.call(this);
    this.F = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2ConstantForceController, box2d.b2Controller);
goog.exportSymbol("box2d.b2ConstantForceController", box2d.b2ConstantForceController);
box2d.b2ConstantAccelController.prototype.F = null;
goog.exportProperty(box2d.b2ConstantAccelController.prototype, "F", box2d.b2ConstantAccelController.prototype.F);
box2d.b2ConstantForceController.prototype.Step = function(a) {
    for (a = this.m_bodyList; a; a = a.nextBody) {
        var b = a.body;
        b.IsAwake() && b.ApplyForce(this.F, b.GetWorldCenter())
    }
};
goog.exportProperty(box2d.b2ConstantForceController.prototype, "Step", box2d.b2ConstantForceController.prototype.Step);
box2d.b2_minPulleyLength = 2;
goog.exportSymbol("box2d.b2_minPulleyLength", box2d.b2_minPulleyLength);
box2d.b2PulleyJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_pulleyJoint);
    this.collideConnected = !0;
    this.groundAnchorA = new box2d.b2Vec2(-1, 1);
    this.groundAnchorB = new box2d.b2Vec2(1, 1);
    this.localAnchorA = new box2d.b2Vec2(-1, 0);
    this.localAnchorB = new box2d.b2Vec2(1, 0)
};
goog.inherits(box2d.b2PulleyJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2PulleyJointDef", box2d.b2PulleyJointDef);
box2d.b2PulleyJointDef.prototype.groundAnchorA = null;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "groundAnchorA", box2d.b2PulleyJointDef.prototype.groundAnchorA);
box2d.b2PulleyJointDef.prototype.groundAnchorB = null;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "groundAnchorB", box2d.b2PulleyJointDef.prototype.groundAnchorB);
box2d.b2PulleyJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "localAnchorA", box2d.b2PulleyJointDef.prototype.localAnchorA);
box2d.b2PulleyJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "localAnchorB", box2d.b2PulleyJointDef.prototype.localAnchorB);
box2d.b2PulleyJointDef.prototype.lengthA = 0;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "lengthA", box2d.b2PulleyJointDef.prototype.lengthA);
box2d.b2PulleyJointDef.prototype.lengthB = 0;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "lengthB", box2d.b2PulleyJointDef.prototype.lengthB);
box2d.b2PulleyJointDef.prototype.ratio = 1;
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "ratio", box2d.b2PulleyJointDef.prototype.ratio);
box2d.b2PulleyJointDef.prototype.Initialize = function(a, b, c, e, d, f, g) {
    this.bodyA = a;
    this.bodyB = b;
    this.groundAnchorA.Copy(c);
    this.groundAnchorB.Copy(e);
    this.bodyA.GetLocalPoint(d, this.localAnchorA);
    this.bodyB.GetLocalPoint(f, this.localAnchorB);
    this.lengthA = box2d.b2DistanceVV(d, c);
    this.lengthB = box2d.b2DistanceVV(f, e);
    this.ratio = g;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.ratio > box2d.b2_epsilon)
};
goog.exportProperty(box2d.b2PulleyJointDef.prototype, "Initialize", box2d.b2PulleyJointDef.prototype.Initialize);
box2d.b2PulleyJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_groundAnchorA = new box2d.b2Vec2;
    this.m_groundAnchorB = new box2d.b2Vec2;
    this.m_localAnchorA = new box2d.b2Vec2;
    this.m_localAnchorB = new box2d.b2Vec2;
    this.m_uA = new box2d.b2Vec2;
    this.m_uB = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_groundAnchorA.Copy(a.groundAnchorA);
    this.m_groundAnchorB.Copy(a.groundAnchorB);
    this.m_localAnchorA.Copy(a.localAnchorA);
    this.m_localAnchorB.Copy(a.localAnchorB);
    this.m_lengthA = a.lengthA;
    this.m_lengthB = a.lengthB;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(0 != a.ratio);
    this.m_ratio = a.ratio;
    this.m_constant = a.lengthA + this.m_ratio * a.lengthB;
    this.m_impulse = 0
};
goog.inherits(box2d.b2PulleyJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2PulleyJoint", box2d.b2PulleyJoint);
box2d.b2PulleyJoint.prototype.m_groundAnchorA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_groundAnchorA", box2d.b2PulleyJoint.prototype.m_groundAnchorA);
box2d.b2PulleyJoint.prototype.m_groundAnchorB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_groundAnchorB", box2d.b2PulleyJoint.prototype.m_groundAnchorB);
box2d.b2PulleyJoint.prototype.m_lengthA = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_lengthA", box2d.b2PulleyJoint.prototype.m_lengthA);
box2d.b2PulleyJoint.prototype.m_lengthB = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_lengthB", box2d.b2PulleyJoint.prototype.m_lengthB);
box2d.b2PulleyJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_localAnchorA", box2d.b2PulleyJoint.prototype.m_localAnchorA);
box2d.b2PulleyJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_localAnchorB", box2d.b2PulleyJoint.prototype.m_localAnchorB);
box2d.b2PulleyJoint.prototype.m_constant = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_constant", box2d.b2PulleyJoint.prototype.m_constant);
box2d.b2PulleyJoint.prototype.m_ratio = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_ratio", box2d.b2PulleyJoint.prototype.m_ratio);
box2d.b2PulleyJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_impulse", box2d.b2PulleyJoint.prototype.m_impulse);
box2d.b2PulleyJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_indexA", box2d.b2PulleyJoint.prototype.m_indexA);
box2d.b2PulleyJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_indexB", box2d.b2PulleyJoint.prototype.m_indexB);
box2d.b2PulleyJoint.prototype.m_uA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_uA", box2d.b2PulleyJoint.prototype.m_uA);
box2d.b2PulleyJoint.prototype.m_uB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_uB", box2d.b2PulleyJoint.prototype.m_uB);
box2d.b2PulleyJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_rA", box2d.b2PulleyJoint.prototype.m_rA);
box2d.b2PulleyJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_rB", box2d.b2PulleyJoint.prototype.m_rB);
box2d.b2PulleyJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_localCenterA", box2d.b2PulleyJoint.prototype.m_localCenterA);
box2d.b2PulleyJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_localCenterB", box2d.b2PulleyJoint.prototype.m_localCenterB);
box2d.b2PulleyJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_invMassA", box2d.b2PulleyJoint.prototype.m_invMassA);
box2d.b2PulleyJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_invMassB", box2d.b2PulleyJoint.prototype.m_invMassB);
box2d.b2PulleyJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_invIA", box2d.b2PulleyJoint.prototype.m_invIA);
box2d.b2PulleyJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_invIB", box2d.b2PulleyJoint.prototype.m_invIB);
box2d.b2PulleyJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_mass", box2d.b2PulleyJoint.prototype.m_mass);
box2d.b2PulleyJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_qA", box2d.b2PulleyJoint.prototype.m_qA);
box2d.b2PulleyJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_qB", box2d.b2PulleyJoint.prototype.m_qB);
box2d.b2PulleyJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_lalcA", box2d.b2PulleyJoint.prototype.m_lalcA);
box2d.b2PulleyJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2PulleyJoint.prototype, "m_lalcB", box2d.b2PulleyJoint.prototype.m_lalcB);
box2d.b2PulleyJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.velocities[this.m_indexA].v, e = a.velocities[this.m_indexA].w,
            d = a.positions[this.m_indexB].c, f = a.positions[this.m_indexB].a, g = a.velocities[this.m_indexB].v, h = a.velocities[this.m_indexB].w, l = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), f = this.m_qB.SetAngleRadians(f);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    box2d.b2MulRV(f, this.m_lalcB, this.m_rB);
    this.m_uA.Copy(b).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA);
    this.m_uB.Copy(d).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB);
    b = this.m_uA.GetLength();
    d = this.m_uB.GetLength();
    b > 10 * box2d.b2_linearSlop ? this.m_uA.SelfMul(1 / b) : this.m_uA.SetZero();
    d > 10 * box2d.b2_linearSlop ? this.m_uB.SelfMul(1 / d) : this.m_uB.SetZero();
    b = box2d.b2CrossVV(this.m_rA, this.m_uA);
    d = box2d.b2CrossVV(this.m_rB, this.m_uB);
    this.m_mass = this.m_invMassA + this.m_invIA * b * b + this.m_ratio * this.m_ratio * (this.m_invMassB + this.m_invIB * d * d);
    0 < this.m_mass && (this.m_mass = 1 / this.m_mass);
    a.step.warmStarting ? (this.m_impulse *= a.step.dtRatio, b = box2d.b2MulSV(-this.m_impulse, this.m_uA,
            box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA), d = box2d.b2MulSV(-this.m_ratio * this.m_impulse, this.m_uB, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB), c.SelfMulAdd(this.m_invMassA, b), e += this.m_invIA * box2d.b2CrossVV(this.m_rA, b), g.SelfMulAdd(this.m_invMassB, d), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, d)) : this.m_impulse = 0;
    a.velocities[this.m_indexA].w = e;
    a.velocities[this.m_indexB].w = h
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "InitVelocityConstraints", box2d.b2PulleyJoint.prototype.InitVelocityConstraints);
box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = box2d.b2AddVCrossSV(b, c, this.m_rA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA), g = box2d.b2AddVCrossSV(e, d, this.m_rB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB), f = -box2d.b2DotVV(this.m_uA, f) - this.m_ratio * box2d.b2DotVV(this.m_uB, g), g = -this.m_mass * f;
    this.m_impulse += g;
    f =
            box2d.b2MulSV(-g, this.m_uA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA);
    g = box2d.b2MulSV(-this.m_ratio * g, this.m_uB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB);
    b.SelfMulAdd(this.m_invMassA, f);
    c += this.m_invIA * box2d.b2CrossVV(this.m_rA, f);
    e.SelfMulAdd(this.m_invMassB, g);
    d += this.m_invIB * box2d.b2CrossVV(this.m_rB, g);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "SolveVelocityConstraints", box2d.b2PulleyJoint.prototype.SolveVelocityConstraints);
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    f = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var g = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), h = this.m_uA.Copy(b).SelfAdd(f).SelfSub(this.m_groundAnchorA),
            l = this.m_uB.Copy(e).SelfAdd(g).SelfSub(this.m_groundAnchorB), k = h.GetLength(), m = l.GetLength();
    k > 10 * box2d.b2_linearSlop ? h.SelfMul(1 / k) : h.SetZero();
    m > 10 * box2d.b2_linearSlop ? l.SelfMul(1 / m) : l.SetZero();
    var n = box2d.b2CrossVV(f, h), p = box2d.b2CrossVV(g, l), n = this.m_invMassA + this.m_invIA * n * n + this.m_ratio * this.m_ratio * (this.m_invMassB + this.m_invIB * p * p);
    0 < n && (n = 1 / n);
    m = this.m_constant - k - this.m_ratio * m;
    k = box2d.b2Abs(m);
    m *= -n;
    h = box2d.b2MulSV(-m, h, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA);
    l = box2d.b2MulSV(-this.m_ratio *
            m, l, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB);
    b.SelfMulAdd(this.m_invMassA, h);
    c += this.m_invIA * box2d.b2CrossVV(f, h);
    e.SelfMulAdd(this.m_invMassB, l);
    d += this.m_invIB * box2d.b2CrossVV(g, l);
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return k < box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "SolvePositionConstraints", box2d.b2PulleyJoint.prototype.SolvePositionConstraints);
box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetAnchorA", box2d.b2PulleyJoint.prototype.GetAnchorA);
box2d.b2PulleyJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetAnchorB", box2d.b2PulleyJoint.prototype.GetAnchorB);
box2d.b2PulleyJoint.prototype.GetReactionForce = function(a, b) {
    return b.SetXY(a * this.m_impulse * this.m_uB.x, a * this.m_impulse * this.m_uB.y)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetReactionForce", box2d.b2PulleyJoint.prototype.GetReactionForce);
box2d.b2PulleyJoint.prototype.GetReactionTorque = function(a) {
    return 0
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetReactionTorque", box2d.b2PulleyJoint.prototype.GetReactionTorque);
box2d.b2PulleyJoint.prototype.GetGroundAnchorA = function(a) {
    return a.Copy(this.m_groundAnchorA)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetGroundAnchorA", box2d.b2PulleyJoint.prototype.GetGroundAnchorA);
box2d.b2PulleyJoint.prototype.GetGroundAnchorB = function(a) {
    return a.Copy(this.m_groundAnchorB)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetGroundAnchorB", box2d.b2PulleyJoint.prototype.GetGroundAnchorB);
box2d.b2PulleyJoint.prototype.GetLengthA = function() {
    return this.m_lengthA
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetLengthA", box2d.b2PulleyJoint.prototype.GetLengthA);
box2d.b2PulleyJoint.prototype.GetLengthB = function() {
    return this.m_lengthB
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetLengthB", box2d.b2PulleyJoint.prototype.GetLengthB);
box2d.b2PulleyJoint.prototype.GetRatio = function() {
    return this.m_ratio
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetRatio", box2d.b2PulleyJoint.prototype.GetRatio);
box2d.b2PulleyJoint.prototype.GetCurrentLengthA = function() {
    var a = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p);
    return box2d.b2DistanceVV(a, this.m_groundAnchorA)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetCurrentLengthA", box2d.b2PulleyJoint.prototype.GetCurrentLengthA);
box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.GetCurrentLengthB = function() {
    var a = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p);
    return box2d.b2DistanceVV(a, this.m_groundAnchorB)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "GetCurrentLengthB", box2d.b2PulleyJoint.prototype.GetCurrentLengthB);
box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p = new box2d.b2Vec2;
box2d.b2PulleyJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2PulleyJointDef*/ var jd = new box2d.b2PulleyJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.groundAnchorA.SetXY(%.15f, %.15f);\n", this.m_groundAnchorA.x, this.m_groundAnchorA.y);
        box2d.b2Log("  jd.groundAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_groundAnchorB.x, this.m_groundAnchorB.y);
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.lengthA = %.15f;\n", this.m_lengthA);
        box2d.b2Log("  jd.lengthB = %.15f;\n", this.m_lengthB);
        box2d.b2Log("  jd.ratio = %.15f;\n", this.m_ratio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "Dump", box2d.b2PulleyJoint.prototype.Dump);
box2d.b2PulleyJoint.prototype.ShiftOrigin = function(a) {
    this.m_groundAnchorA.SelfSub(a);
    this.m_groundAnchorB.SelfSub(a)
};
goog.exportProperty(box2d.b2PulleyJoint.prototype, "ShiftOrigin", box2d.b2PulleyJoint.prototype.ShiftOrigin);
box2d.b2CircleShape = function(a) {
    box2d.b2Shape.call(this, box2d.b2ShapeType.e_circleShape, a || 0);
    this.m_p = new box2d.b2Vec2
};
goog.inherits(box2d.b2CircleShape, box2d.b2Shape);
goog.exportSymbol("box2d.b2CircleShape", box2d.b2CircleShape);
box2d.b2CircleShape.prototype.m_p = null;
goog.exportProperty(box2d.b2CircleShape.prototype, "m_p", box2d.b2CircleShape.prototype.m_p);
box2d.b2CircleShape.prototype.Clone = function() {
    return(new box2d.b2CircleShape).Copy(this)
};
goog.exportProperty(box2d.b2CircleShape.prototype, "Clone", box2d.b2CircleShape.prototype.Clone);
box2d.b2CircleShape.prototype.Copy = function(a) {
    box2d.b2CircleShape.superClass_.Copy.call(this, a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(a instanceof box2d.b2CircleShape);
    this.m_p.Copy(a.m_p);
    return this
};
goog.exportProperty(box2d.b2CircleShape.prototype, "Copy", box2d.b2CircleShape.prototype.Copy);
box2d.b2CircleShape.prototype.GetChildCount = function() {
    return 1
};
goog.exportProperty(box2d.b2CircleShape.prototype, "GetChildCount", box2d.b2CircleShape.prototype.GetChildCount);
box2d.b2CircleShape.prototype.TestPoint = function(a, b) {
    var c = box2d.b2MulXV(a, this.m_p, box2d.b2CircleShape.prototype.TestPoint.s_center), c = box2d.b2SubVV(b, c, box2d.b2CircleShape.prototype.TestPoint.s_d);
    return box2d.b2DotVV(c, c) <= box2d.b2Sq(this.m_radius)
};
goog.exportProperty(box2d.b2CircleShape.prototype, "TestPoint", box2d.b2CircleShape.prototype.TestPoint);
box2d.b2CircleShape.prototype.TestPoint.s_center = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.TestPoint.s_d = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.RayCast = function(a, b, c, e) {
    c = box2d.b2MulXV(c, this.m_p, box2d.b2CircleShape.prototype.RayCast.s_position);
    c = box2d.b2SubVV(b.p1, c, box2d.b2CircleShape.prototype.RayCast.s_s);
    var d = box2d.b2DotVV(c, c) - box2d.b2Sq(this.m_radius);
    e = box2d.b2SubVV(b.p2, b.p1, box2d.b2CircleShape.prototype.RayCast.s_r);
    var f = box2d.b2DotVV(c, e), g = box2d.b2DotVV(e, e), d = f * f - g * d;
    if (0 > d || g < box2d.b2_epsilon)
        return!1;
    f = -(f + box2d.b2Sqrt(d));
    return 0 <= f && f <= b.maxFraction * g ? (f /= g, a.fraction = f, box2d.b2AddVMulSV(c,
            f, e, a.normal).SelfNormalize(), !0) : !1
};
goog.exportProperty(box2d.b2CircleShape.prototype, "RayCast", box2d.b2CircleShape.prototype.RayCast);
box2d.b2CircleShape.prototype.RayCast.s_position = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.RayCast.s_s = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.RayCast.s_r = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.ComputeAABB = function(a, b, c) {
    b = box2d.b2MulXV(b, this.m_p, box2d.b2CircleShape.prototype.ComputeAABB.s_p);
    a.lowerBound.SetXY(b.x - this.m_radius, b.y - this.m_radius);
    a.upperBound.SetXY(b.x + this.m_radius, b.y + this.m_radius)
};
goog.exportProperty(box2d.b2CircleShape.prototype, "ComputeAABB", box2d.b2CircleShape.prototype.ComputeAABB);
box2d.b2CircleShape.prototype.ComputeAABB.s_p = new box2d.b2Vec2;
box2d.b2CircleShape.prototype.ComputeMass = function(a, b) {
    var c = box2d.b2Sq(this.m_radius);
    a.mass = b * box2d.b2_pi * c;
    a.center.Copy(this.m_p);
    a.I = a.mass * (0.5 * c + box2d.b2DotVV(this.m_p, this.m_p))
};
goog.exportProperty(box2d.b2CircleShape.prototype, "ComputeMass", box2d.b2CircleShape.prototype.ComputeMass);
box2d.b2CircleShape.prototype.SetupDistanceProxy = function(a, b) {
    a.m_vertices = [1, !0];
    a.m_vertices[0] = this.m_p;
    a.m_count = 1;
    a.m_radius = this.m_radius
};
box2d.b2CircleShape.prototype.ComputeSubmergedArea = function(a, b, c, e) {
    c = box2d.b2MulXV(c, this.m_p, new box2d.b2Vec2);
    var d = -(box2d.b2DotVV(a, c) - b);
    if (d < -this.m_radius + box2d.b2_epsilon)
        return 0;
    if (d > this.m_radius)
        return e.Copy(c), box2d.b2_pi * this.m_radius * this.m_radius;
    b = this.m_radius * this.m_radius;
    var f = d * d, d = b * (box2d.b2Asin(d / this.m_radius) + box2d.b2_pi / 2) + d * box2d.b2Sqrt(b - f);
    b = -2 / 3 * box2d.b2Pow(b - f, 1.5) / d;
    e.x = c.x + a.x * b;
    e.y = c.y + a.y * b;
    return d
};
goog.exportProperty(box2d.b2CircleShape.prototype, "ComputeSubmergedArea", box2d.b2CircleShape.prototype.ComputeSubmergedArea);
box2d.b2CircleShape.prototype.Dump = function() {
    box2d.b2Log("    /*box2d.b2CircleShape*/ var shape = new box2d.b2CircleShape();\n");
    box2d.b2Log("    shape.m_radius = %.15f;\n", this.m_radius);
    box2d.b2Log("    shape.m_p.SetXY(%.15f, %.15f);\n", this.m_p.x, this.m_p.y)
};
goog.exportProperty(box2d.b2CircleShape.prototype, "Dump", box2d.b2CircleShape.prototype.Dump);
box2d.b2RopeDef = function() {
    this.vertices = [];
    this.masses = [];
    this.gravity = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2RopeDef", box2d.b2RopeDef);
box2d.b2RopeDef.prototype.vertices = null;
box2d.b2RopeDef.prototype.count = 0;
box2d.b2RopeDef.prototype.masses = null;
box2d.b2RopeDef.prototype.gravity = null;
box2d.b2RopeDef.prototype.damping = 0.1;
box2d.b2RopeDef.prototype.k2 = 0.9;
box2d.b2RopeDef.prototype.k3 = 0.1;
box2d.b2Rope = function() {
    this.m_gravity = new box2d.b2Vec2
};
goog.exportSymbol("box2d.b2Rope", box2d.b2Rope);
box2d.b2Rope.prototype.m_count = 0;
box2d.b2Rope.prototype.m_ps = null;
box2d.b2Rope.prototype.m_p0s = null;
box2d.b2Rope.prototype.m_vs = null;
box2d.b2Rope.prototype.m_ims = null;
box2d.b2Rope.prototype.m_Ls = null;
box2d.b2Rope.prototype.m_as = null;
box2d.b2Rope.prototype.m_gravity = null;
box2d.b2Rope.prototype.m_damping = 0;
box2d.b2Rope.prototype.m_k2 = 1;
box2d.b2Rope.prototype.m_k3 = 0.1;
box2d.b2Rope.prototype.GetVertexCount = function() {
    return this.m_count
};
goog.exportProperty(box2d.b2Rope.prototype, "GetVertexCount", box2d.b2Rope.prototype.GetVertexCount);
box2d.b2Rope.prototype.GetVertices = function() {
    return this.m_ps
};
goog.exportProperty(box2d.b2Rope.prototype, "GetVertices", box2d.b2Rope.prototype.GetVertices);
box2d.b2Rope.prototype.Initialize = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(3 <= a.count);
    this.m_count = a.count;
    this.m_ps = box2d.b2Vec2.MakeArray(this.m_count);
    this.m_p0s = box2d.b2Vec2.MakeArray(this.m_count);
    this.m_vs = box2d.b2Vec2.MakeArray(this.m_count);
    this.m_ims = box2d.b2MakeNumberArray(this.m_count);
    for (var b = 0; b < this.m_count; ++b) {
        this.m_ps[b].Copy(a.vertices[b]);
        this.m_p0s[b].Copy(a.vertices[b]);
        this.m_vs[b].SetZero();
        var c = a.masses[b];
        this.m_ims[b] = 0 < c ? 1 / c : 0
    }
    var e = this.m_count - 1, c = this.m_count -
            2;
    this.m_Ls = box2d.b2MakeNumberArray(e);
    this.m_as = box2d.b2MakeNumberArray(c);
    for (b = 0; b < e; ++b) {
        var d = this.m_ps[b], f = this.m_ps[b + 1];
        this.m_Ls[b] = box2d.b2DistanceVV(d, f)
    }
    for (b = 0; b < c; ++b)
        d = this.m_ps[b], f = this.m_ps[b + 1], e = this.m_ps[b + 2], d = box2d.b2SubVV(f, d, box2d.b2Vec2.s_t0), e = box2d.b2SubVV(e, f, box2d.b2Vec2.s_t1), f = box2d.b2CrossVV(d, e), d = box2d.b2DotVV(d, e), this.m_as[b] = box2d.b2Atan2(f, d);
    this.m_gravity.Copy(a.gravity);
    this.m_damping = a.damping;
    this.m_k2 = a.k2;
    this.m_k3 = a.k3
};
goog.exportProperty(box2d.b2Rope.prototype, "Initialize", box2d.b2Rope.prototype.Initialize);
box2d.b2Rope.prototype.Step = function(a, b) {
    if (0 != a) {
        for (var c = Math.exp(-a * this.m_damping), e = 0; e < this.m_count; ++e)
            this.m_p0s[e].Copy(this.m_ps[e]), 0 < this.m_ims[e] && this.m_vs[e].SelfMulAdd(a, this.m_gravity), this.m_vs[e].SelfMul(c), this.m_ps[e].SelfMulAdd(a, this.m_vs[e]);
        for (e = 0; e < b; ++e)
            this.SolveC2(), this.SolveC3(), this.SolveC2();
        c = 1 / a;
        for (e = 0; e < this.m_count; ++e)
            box2d.b2MulSV(c, box2d.b2SubVV(this.m_ps[e], this.m_p0s[e], box2d.b2Vec2.s_t0), this.m_vs[e])
    }
};
goog.exportProperty(box2d.b2Rope.prototype, "Step", box2d.b2Rope.prototype.Step);
box2d.b2Rope.prototype.SolveC2 = function() {
    for (var a = this.m_count - 1, b = 0; b < a; ++b) {
        var c = this.m_ps[b], e = this.m_ps[b + 1], d = box2d.b2SubVV(e, c, box2d.b2Rope.s_d), f = d.Normalize(), g = this.m_ims[b], h = this.m_ims[b + 1];
        if (0 != g + h) {
            var l = h / (g + h);
            c.SelfMulSub(this.m_k2 * (g / (g + h)) * (this.m_Ls[b] - f), d);
            e.SelfMulAdd(this.m_k2 * l * (this.m_Ls[b] - f), d)
        }
    }
};
goog.exportProperty(box2d.b2Rope.prototype, "SolveC2", box2d.b2Rope.prototype.SolveC2);
box2d.b2Rope.s_d = new box2d.b2Vec2;
box2d.b2Rope.prototype.SetAngleRadians = function(a) {
    for (var b = this.m_count - 2, c = 0; c < b; ++c)
        this.m_as[c] = a
};
goog.exportProperty(box2d.b2Rope.prototype, "SetAngleRadians", box2d.b2Rope.prototype.SetAngleRadians);
box2d.b2Rope.prototype.SolveC3 = function() {
    for (var a = this.m_count - 2, b = 0; b < a; ++b) {
        var c = this.m_ps[b], e = this.m_ps[b + 1], d = this.m_ps[b + 2], f = this.m_ims[b], g = this.m_ims[b + 1], h = this.m_ims[b + 2], l = box2d.b2SubVV(e, c, box2d.b2Rope.s_d1), k = box2d.b2SubVV(d, e, box2d.b2Rope.s_d2), m = l.GetLengthSquared(), n = k.GetLengthSquared();
        if (0 != m * n) {
            var p = box2d.b2CrossVV(l, k), q = box2d.b2DotVV(l, k), p = box2d.b2Atan2(p, q), l = box2d.b2MulSV(-1 / m, l.SelfSkew(), box2d.b2Rope.s_Jd1), m = box2d.b2MulSV(1 / n, k.SelfSkew(), box2d.b2Rope.s_Jd2), k = box2d.b2NegV(l,
                    box2d.b2Rope.s_J1), n = box2d.b2SubVV(l, m, box2d.b2Rope.s_J2), l = m, m = f * box2d.b2DotVV(k, k) + g * box2d.b2DotVV(n, n) + h * box2d.b2DotVV(l, l);
            if (0 != m) {
                m = 1 / m;
                for (q = p - this.m_as[b]; q > box2d.b2_pi; )
                    p -= 2 * box2d.b2_pi, q = p - this.m_as[b];
                for (; q < - box2d.b2_pi; )
                    p += 2 * box2d.b2_pi, q = p - this.m_as[b];
                p = -this.m_k3 * m * q;
                c.SelfMulAdd(f * p, k);
                e.SelfMulAdd(g * p, n);
                d.SelfMulAdd(h * p, l)
            }
        }
    }
};
goog.exportProperty(box2d.b2Rope.prototype, "SolveC3", box2d.b2Rope.prototype.SolveC3);
box2d.b2Rope.s_d1 = new box2d.b2Vec2;
box2d.b2Rope.s_d2 = new box2d.b2Vec2;
box2d.b2Rope.s_Jd1 = new box2d.b2Vec2;
box2d.b2Rope.s_Jd2 = new box2d.b2Vec2;
box2d.b2Rope.s_J1 = new box2d.b2Vec2;
box2d.b2Rope.s_J2 = new box2d.b2Vec2;
box2d.b2Rope.prototype.Draw = function(a) {
    for (var b = new box2d.b2Color(0.4, 0.5, 0.7), c = 0; c < this.m_count - 1; ++c)
        a.DrawSegment(this.m_ps[c], this.m_ps[c + 1], b)
};
goog.exportProperty(box2d.b2Rope.prototype, "Draw", box2d.b2Rope.prototype.Draw);
box2d.b2WheelJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_wheelJoint);
    this.localAnchorA = new box2d.b2Vec2(0, 0);
    this.localAnchorB = new box2d.b2Vec2(0, 0);
    this.localAxisA = new box2d.b2Vec2(1, 0)
};
goog.inherits(box2d.b2WheelJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2WheelJointDef", box2d.b2WheelJointDef);
box2d.b2WheelJointDef.prototype.localAnchorA = null;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "localAnchorA", box2d.b2WheelJointDef.prototype.localAnchorA);
box2d.b2WheelJointDef.prototype.localAnchorB = null;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "localAnchorB", box2d.b2WheelJointDef.prototype.localAnchorB);
box2d.b2WheelJointDef.prototype.localAxisA = null;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "localAxisA", box2d.b2WheelJointDef.prototype.localAxisA);
box2d.b2WheelJointDef.prototype.enableMotor = !1;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "enableMotor", box2d.b2WheelJointDef.prototype.enableMotor);
box2d.b2WheelJointDef.prototype.maxMotorTorque = 0;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "maxMotorTorque", box2d.b2WheelJointDef.prototype.maxMotorTorque);
box2d.b2WheelJointDef.prototype.motorSpeed = 0;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "motorSpeed", box2d.b2WheelJointDef.prototype.motorSpeed);
box2d.b2WheelJointDef.prototype.frequencyHz = 2;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "frequencyHz", box2d.b2WheelJointDef.prototype.frequencyHz);
box2d.b2WheelJointDef.prototype.dampingRatio = 0.7;
goog.exportProperty(box2d.b2WheelJointDef.prototype, "dampingRatio", box2d.b2WheelJointDef.prototype.dampingRatio);
box2d.b2WheelJointDef.prototype.Initialize = function(a, b, c, e) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(c, this.localAnchorA);
    this.bodyB.GetLocalPoint(c, this.localAnchorB);
    this.bodyA.GetLocalVector(e, this.localAxisA)
};
goog.exportProperty(box2d.b2WheelJointDef.prototype, "Initialize", box2d.b2WheelJointDef.prototype.Initialize);
box2d.b2WheelJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_frequencyHz = a.frequencyHz;
    this.m_dampingRatio = a.dampingRatio;
    this.m_localAnchorA = a.localAnchorA.Clone();
    this.m_localAnchorB = a.localAnchorB.Clone();
    this.m_localXAxisA = a.localAxisA.Clone();
    this.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2);
    this.m_maxMotorTorque = a.maxMotorTorque;
    this.m_motorSpeed = a.motorSpeed;
    this.m_enableMotor = a.enableMotor;
    this.m_localCenterA = new box2d.b2Vec2;
    this.m_localCenterB = new box2d.b2Vec2;
    this.m_ax = new box2d.b2Vec2;
    this.m_ay = new box2d.b2Vec2;
    this.m_qA = new box2d.b2Rot;
    this.m_qB = new box2d.b2Rot;
    this.m_lalcA = new box2d.b2Vec2;
    this.m_lalcB = new box2d.b2Vec2;
    this.m_rA = new box2d.b2Vec2;
    this.m_rB = new box2d.b2Vec2;
    this.m_ax.SetZero();
    this.m_ay.SetZero()
};
goog.inherits(box2d.b2WheelJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2WheelJoint", box2d.b2WheelJoint);
box2d.b2WheelJoint.prototype.m_frequencyHz = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_frequencyHz", box2d.b2WheelJoint.prototype.m_frequencyHz);
box2d.b2WheelJoint.prototype.m_dampingRatio = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_dampingRatio", box2d.b2WheelJoint.prototype.m_dampingRatio);
box2d.b2WheelJoint.prototype.m_localAnchorA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localAnchorA", box2d.b2WheelJoint.prototype.m_localAnchorA);
box2d.b2WheelJoint.prototype.m_localAnchorB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localAnchorB", box2d.b2WheelJoint.prototype.m_localAnchorB);
box2d.b2WheelJoint.prototype.m_localXAxisA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localXAxisA", box2d.b2WheelJoint.prototype.m_localXAxisA);
box2d.b2WheelJoint.prototype.m_localYAxisA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localYAxisA", box2d.b2WheelJoint.prototype.m_localYAxisA);
box2d.b2WheelJoint.prototype.m_impulse = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_impulse", box2d.b2WheelJoint.prototype.m_impulse);
box2d.b2WheelJoint.prototype.m_motorImpulse = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_motorImpulse", box2d.b2WheelJoint.prototype.m_motorImpulse);
box2d.b2WheelJoint.prototype.m_springImpulse = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_springImpulse", box2d.b2WheelJoint.prototype.m_springImpulse);
box2d.b2WheelJoint.prototype.m_maxMotorTorque = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_maxMotorTorque", box2d.b2WheelJoint.prototype.m_maxMotorTorque);
box2d.b2WheelJoint.prototype.m_motorSpeed = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_motorSpeed", box2d.b2WheelJoint.prototype.m_motorSpeed);
box2d.b2WheelJoint.prototype.m_enableMotor = !1;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_enableMotor", box2d.b2WheelJoint.prototype.m_enableMotor);
box2d.b2WheelJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_indexA", box2d.b2WheelJoint.prototype.m_indexA);
box2d.b2WheelJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_indexB", box2d.b2WheelJoint.prototype.m_indexB);
box2d.b2WheelJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localCenterA", box2d.b2WheelJoint.prototype.m_localCenterA);
box2d.b2WheelJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_localCenterB", box2d.b2WheelJoint.prototype.m_localCenterB);
box2d.b2WheelJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_invMassA", box2d.b2WheelJoint.prototype.m_invMassA);
box2d.b2WheelJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_invMassB", box2d.b2WheelJoint.prototype.m_invMassB);
box2d.b2WheelJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_invIA", box2d.b2WheelJoint.prototype.m_invIA);
box2d.b2WheelJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_invIB", box2d.b2WheelJoint.prototype.m_invIB);
box2d.b2WheelJoint.prototype.m_ax = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_ax", box2d.b2WheelJoint.prototype.m_ax);
box2d.b2WheelJoint.prototype.m_ay = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_ay", box2d.b2WheelJoint.prototype.m_ay);
box2d.b2WheelJoint.prototype.m_sAx = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_sAx", box2d.b2WheelJoint.prototype.m_sAx);
box2d.b2WheelJoint.prototype.m_sBx = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_sBx", box2d.b2WheelJoint.prototype.m_sBx);
box2d.b2WheelJoint.prototype.m_sAy = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_sAy", box2d.b2WheelJoint.prototype.m_sAy);
box2d.b2WheelJoint.prototype.m_sBy = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_sBy", box2d.b2WheelJoint.prototype.m_sBy);
box2d.b2WheelJoint.prototype.m_mass = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_mass", box2d.b2WheelJoint.prototype.m_mass);
box2d.b2WheelJoint.prototype.m_motorMass = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_motorMass", box2d.b2WheelJoint.prototype.m_motorMass);
box2d.b2WheelJoint.prototype.m_springMass = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_springMass", box2d.b2WheelJoint.prototype.m_springMass);
box2d.b2WheelJoint.prototype.m_bias = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_bias", box2d.b2WheelJoint.prototype.m_bias);
box2d.b2WheelJoint.prototype.m_gamma = 0;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_gamma", box2d.b2WheelJoint.prototype.m_gamma);
box2d.b2WheelJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_qA", box2d.b2WheelJoint.prototype.m_qA);
box2d.b2WheelJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_qB", box2d.b2WheelJoint.prototype.m_qB);
box2d.b2WheelJoint.prototype.m_lalcA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_lalcA", box2d.b2WheelJoint.prototype.m_lalcA);
box2d.b2WheelJoint.prototype.m_lalcB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_lalcB", box2d.b2WheelJoint.prototype.m_lalcB);
box2d.b2WheelJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_rA", box2d.b2WheelJoint.prototype.m_rA);
box2d.b2WheelJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2WheelJoint.prototype, "m_rB", box2d.b2WheelJoint.prototype.m_rB);
box2d.b2WheelJoint.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetMotorSpeed", box2d.b2WheelJoint.prototype.GetMotorSpeed);
box2d.b2WheelJoint.prototype.GetMaxMotorTorque = function() {
    return this.m_maxMotorTorque
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetMaxMotorTorque", box2d.b2WheelJoint.prototype.GetMaxMotorTorque);
box2d.b2WheelJoint.prototype.SetSpringFrequencyHz = function(a) {
    this.m_frequencyHz = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SetSpringFrequencyHz", box2d.b2WheelJoint.prototype.SetSpringFrequencyHz);
box2d.b2WheelJoint.prototype.GetSpringFrequencyHz = function() {
    return this.m_frequencyHz
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetSpringFrequencyHz", box2d.b2WheelJoint.prototype.GetSpringFrequencyHz);
box2d.b2WheelJoint.prototype.SetSpringDampingRatio = function(a) {
    this.m_dampingRatio = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SetSpringDampingRatio", box2d.b2WheelJoint.prototype.SetSpringDampingRatio);
box2d.b2WheelJoint.prototype.GetSpringDampingRatio = function() {
    return this.m_dampingRatio
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetSpringDampingRatio", box2d.b2WheelJoint.prototype.GetSpringDampingRatio);
box2d.b2WheelJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = this.m_invMassA, c = this.m_invMassB, e = this.m_invIA, d = this.m_invIB, f = a.positions[this.m_indexA].c,
            g = a.velocities[this.m_indexA].v, h = a.velocities[this.m_indexA].w, l = a.positions[this.m_indexB].c, k = a.positions[this.m_indexB].a, m = a.velocities[this.m_indexB].v, n = a.velocities[this.m_indexB].w, p = this.m_qA.SetAngleRadians(a.positions[this.m_indexA].a), q = this.m_qB.SetAngleRadians(k);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    k = box2d.b2MulRV(p, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    q = box2d.b2MulRV(q, this.m_lalcB, this.m_rB);
    f =
            box2d.b2SubVV(box2d.b2AddVV(l, q, box2d.b2Vec2.s_t0), box2d.b2AddVV(f, k, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d);
    box2d.b2MulRV(p, this.m_localYAxisA, this.m_ay);
    this.m_sAy = box2d.b2CrossVV(box2d.b2AddVV(f, k, box2d.b2Vec2.s_t0), this.m_ay);
    this.m_sBy = box2d.b2CrossVV(q, this.m_ay);
    this.m_mass = b + c + e * this.m_sAy * this.m_sAy + d * this.m_sBy * this.m_sBy;
    0 < this.m_mass && (this.m_mass = 1 / this.m_mass);
    this.m_gamma = this.m_bias = this.m_springMass = 0;
    0 < this.m_frequencyHz ? (box2d.b2MulRV(p, this.m_localXAxisA,
            this.m_ax), this.m_sAx = box2d.b2CrossVV(box2d.b2AddVV(f, k, box2d.b2Vec2.s_t0), this.m_ax), this.m_sBx = box2d.b2CrossVV(q, this.m_ax), b = b + c + e * this.m_sAx * this.m_sAx + d * this.m_sBx * this.m_sBx, 0 < b && (this.m_springMass = 1 / b, c = box2d.b2DotVV(f, this.m_ax), p = 2 * box2d.b2_pi * this.m_frequencyHz, f = this.m_springMass * p * p, l = a.step.dt, this.m_gamma = l * (2 * this.m_springMass * this.m_dampingRatio * p + l * f), 0 < this.m_gamma && (this.m_gamma = 1 / this.m_gamma), this.m_bias = c * l * f * this.m_gamma, this.m_springMass = b + this.m_gamma, 0 < this.m_springMass &&
            (this.m_springMass = 1 / this.m_springMass))) : this.m_springImpulse = 0;
    this.m_enableMotor ? (this.m_motorMass = e + d, 0 < this.m_motorMass && (this.m_motorMass = 1 / this.m_motorMass)) : this.m_motorImpulse = this.m_motorMass = 0;
    a.step.warmStarting ? (this.m_impulse *= a.step.dtRatio, this.m_springImpulse *= a.step.dtRatio, this.m_motorImpulse *= a.step.dtRatio, e = box2d.b2AddVV(box2d.b2MulSV(this.m_impulse, this.m_ay, box2d.b2Vec2.s_t0), box2d.b2MulSV(this.m_springImpulse, this.m_ax, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P),
            d = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse, b = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse, g.SelfMulSub(this.m_invMassA, e), h -= this.m_invIA * d, m.SelfMulAdd(this.m_invMassB, e), n += this.m_invIB * b) : this.m_motorImpulse = this.m_springImpulse = this.m_impulse = 0;
    a.velocities[this.m_indexA].w = h;
    a.velocities[this.m_indexB].w = n
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "InitVelocityConstraints", box2d.b2WheelJoint.prototype.InitVelocityConstraints);
box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = this.m_invMassA, c = this.m_invMassB, e = this.m_invIA, d = this.m_invIB, f = a.velocities[this.m_indexA].v, g = a.velocities[this.m_indexA].w, h = a.velocities[this.m_indexB].v, l = a.velocities[this.m_indexB].w, k = box2d.b2DotVV(this.m_ax, box2d.b2SubVV(h, f, box2d.b2Vec2.s_t0)) + this.m_sBx * l - this.m_sAx * g, k = -this.m_springMass * (k + this.m_bias + this.m_gamma * this.m_springImpulse);
    this.m_springImpulse += k;
    var m = box2d.b2MulSV(k, this.m_ax, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P),
            n = k * this.m_sAx, k = k * this.m_sBx;
    f.SelfMulSub(b, m);
    g -= e * n;
    h.SelfMulAdd(c, m);
    l += d * k;
    k = l - g - this.m_motorSpeed;
    k *= -this.m_motorMass;
    m = this.m_motorImpulse;
    n = a.step.dt * this.m_maxMotorTorque;
    this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + k, -n, n);
    k = this.m_motorImpulse - m;
    g -= e * k;
    l += d * k;
    k = box2d.b2DotVV(this.m_ay, box2d.b2SubVV(h, f, box2d.b2Vec2.s_t0)) + this.m_sBy * l - this.m_sAy * g;
    k *= -this.m_mass;
    this.m_impulse += k;
    m = box2d.b2MulSV(k, this.m_ay, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P);
    n = k * this.m_sAy;
    k *= this.m_sBy;
    f.SelfMulSub(b, m);
    g -= e * n;
    h.SelfMulAdd(c, m);
    a.velocities[this.m_indexA].w = g;
    a.velocities[this.m_indexB].w = l + d * k
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SolveVelocityConstraints", box2d.b2WheelJoint.prototype.SolveVelocityConstraints);
box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.SolvePositionConstraints = function(a) {
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.positions[this.m_indexB].c, d = a.positions[this.m_indexB].a, f = this.m_qA.SetAngleRadians(c), g = this.m_qB.SetAngleRadians(d);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
    var h = box2d.b2MulRV(f, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
    var g = box2d.b2MulRV(g, this.m_lalcB, this.m_rB), l = box2d.b2AddVV(box2d.b2SubVV(e,
            b, box2d.b2Vec2.s_t0), box2d.b2SubVV(g, h, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d), f = box2d.b2MulRV(f, this.m_localYAxisA, this.m_ay), h = box2d.b2CrossVV(box2d.b2AddVV(l, h, box2d.b2Vec2.s_t0), f), g = box2d.b2CrossVV(g, f), l = box2d.b2DotVV(l, this.m_ay), k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy, k = 0 != k ? -l / k : 0, f = box2d.b2MulSV(k, f, box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P), h = k * h, g = k * g;
    b.SelfMulSub(this.m_invMassA,
            f);
    c -= this.m_invIA * h;
    e.SelfMulAdd(this.m_invMassB, f);
    d += this.m_invIB * g;
    a.positions[this.m_indexA].a = c;
    a.positions[this.m_indexB].a = d;
    return box2d.b2Abs(l) <= box2d.b2_linearSlop
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SolvePositionConstraints", box2d.b2WheelJoint.prototype.SolvePositionConstraints);
box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2;
box2d.b2WheelJoint.prototype.GetDefinition = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(!1);
    return a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetDefinition", box2d.b2WheelJoint.prototype.GetDefinition);
box2d.b2WheelJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, a)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetAnchorA", box2d.b2WheelJoint.prototype.GetAnchorA);
box2d.b2WheelJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, a)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetAnchorB", box2d.b2WheelJoint.prototype.GetAnchorB);
box2d.b2WheelJoint.prototype.GetReactionForce = function(a, b) {
    b.x = a * (this.m_impulse * this.m_ay.x + this.m_springImpulse * this.m_ax.x);
    b.y = a * (this.m_impulse * this.m_ay.y + this.m_springImpulse * this.m_ax.y);
    return b
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetReactionForce", box2d.b2WheelJoint.prototype.GetReactionForce);
box2d.b2WheelJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_motorImpulse
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetReactionTorque", box2d.b2WheelJoint.prototype.GetReactionTorque);
box2d.b2WheelJoint.prototype.GetLocalAnchorA = function(a) {
    return a.Copy(this.m_localAnchorA)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetLocalAnchorA", box2d.b2WheelJoint.prototype.GetLocalAnchorA);
box2d.b2WheelJoint.prototype.GetLocalAnchorB = function(a) {
    return a.Copy(this.m_localAnchorB)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetLocalAnchorB", box2d.b2WheelJoint.prototype.GetLocalAnchorB);
box2d.b2WheelJoint.prototype.GetLocalAxisA = function(a) {
    return a.Copy(this.m_localXAxisA)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetLocalAxisA", box2d.b2WheelJoint.prototype.GetLocalAxisA);
box2d.b2WheelJoint.prototype.GetJointTranslation = function() {
    var a = this.m_bodyA, b = this.m_bodyB, c = a.GetWorldPoint(this.m_localAnchorA, new box2d.b2Vec2), b = b.GetWorldPoint(this.m_localAnchorB, new box2d.b2Vec2), c = box2d.b2SubVV(b, c, new box2d.b2Vec2), a = a.GetWorldVector(this.m_localXAxisA, new box2d.b2Vec2);
    return box2d.b2DotVV(c, a)
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetJointTranslation", box2d.b2WheelJoint.prototype.GetJointTranslation);
box2d.b2WheelJoint.prototype.GetJointSpeed = function() {
    return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetJointSpeed", box2d.b2WheelJoint.prototype.GetJointSpeed);
box2d.b2WheelJoint.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "IsMotorEnabled", box2d.b2WheelJoint.prototype.IsMotorEnabled);
box2d.b2WheelJoint.prototype.EnableMotor = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_enableMotor = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "EnableMotor", box2d.b2WheelJoint.prototype.EnableMotor);
box2d.b2WheelJoint.prototype.SetMotorSpeed = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_motorSpeed = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SetMotorSpeed", box2d.b2WheelJoint.prototype.SetMotorSpeed);
box2d.b2WheelJoint.prototype.SetMaxMotorTorque = function(a) {
    this.m_bodyA.SetAwake(!0);
    this.m_bodyB.SetAwake(!0);
    this.m_maxMotorTorque = a
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "SetMaxMotorTorque", box2d.b2WheelJoint.prototype.SetMaxMotorTorque);
box2d.b2WheelJoint.prototype.GetMotorTorque = function(a) {
    return a * this.m_motorImpulse
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "GetMotorTorque", box2d.b2WheelJoint.prototype.GetMotorTorque);
box2d.b2WheelJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2WheelJointDef*/ var jd = new box2d.b2WheelJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
        box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n",
                this.m_localAnchorB.x, this.m_localAnchorB.y);
        box2d.b2Log("  jd.localAxisA.Set(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y);
        box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false");
        box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
        box2d.b2Log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque);
        box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
        box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n",
                this.m_index)
    }
};
goog.exportProperty(box2d.b2WheelJoint.prototype, "Dump", box2d.b2WheelJoint.prototype.Dump);
box2d.b2MotorJointDef = function() {
    box2d.b2JointDef.call(this, box2d.b2JointType.e_motorJoint);
    this.linearOffset = new box2d.b2Vec2(0, 0)
};
goog.inherits(box2d.b2MotorJointDef, box2d.b2JointDef);
goog.exportSymbol("box2d.b2MotorJointDef", box2d.b2MotorJointDef);
box2d.b2MotorJointDef.prototype.linearOffset = null;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "linearOffset", box2d.b2MotorJointDef.prototype.linearOffset);
box2d.b2MotorJointDef.prototype.angularOffset = 0;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "angularOffset", box2d.b2MotorJointDef.prototype.angularOffset);
box2d.b2MotorJointDef.prototype.maxForce = 1;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "maxForce", box2d.b2MotorJointDef.prototype.maxForce);
box2d.b2MotorJointDef.prototype.maxTorque = 1;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "maxTorque", box2d.b2MotorJointDef.prototype.maxTorque);
box2d.b2MotorJointDef.prototype.correctionFactor = 0.3;
goog.exportProperty(box2d.b2MotorJointDef.prototype, "correctionFactor", box2d.b2MotorJointDef.prototype.correctionFactor);
box2d.b2MotorJointDef.prototype.Initialize = function(a, b) {
    this.bodyA = a;
    this.bodyB = b;
    this.bodyA.GetLocalPoint(this.bodyB.GetPosition(), this.linearOffset);
    var c = this.bodyA.GetAngleRadians();
    this.angularOffset = this.bodyB.GetAngleRadians() - c
};
goog.exportProperty(box2d.b2MotorJointDef.prototype, "Initialize", box2d.b2MotorJointDef.prototype.Initialize);
box2d.b2MotorJoint = function(a) {
    box2d.b2Joint.call(this, a);
    this.m_linearOffset = a.linearOffset.Clone();
    this.m_linearImpulse = new box2d.b2Vec2(0, 0);
    this.m_maxForce = a.maxForce;
    this.m_maxTorque = a.maxTorque;
    this.m_correctionFactor = a.correctionFactor;
    this.m_rA = new box2d.b2Vec2(0, 0);
    this.m_rB = new box2d.b2Vec2(0, 0);
    this.m_localCenterA = new box2d.b2Vec2(0, 0);
    this.m_localCenterB = new box2d.b2Vec2(0, 0);
    this.m_linearError = new box2d.b2Vec2(0, 0);
    this.m_linearMass = new box2d.b2Mat22;
    this.m_qA = new box2d.b2Rot;
    this.m_qB =
            new box2d.b2Rot;
    this.m_K = new box2d.b2Mat22
};
goog.inherits(box2d.b2MotorJoint, box2d.b2Joint);
goog.exportSymbol("box2d.b2MotorJoint", box2d.b2MotorJoint);
box2d.b2MotorJoint.prototype.m_linearOffset = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_linearOffset", box2d.b2MotorJoint.prototype.m_linearOffset);
box2d.b2MotorJoint.prototype.m_angularOffset = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_angularOffset", box2d.b2MotorJoint.prototype.m_angularOffset);
box2d.b2MotorJoint.prototype.m_linearImpulse = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_linearImpulse", box2d.b2MotorJoint.prototype.m_linearImpulse);
box2d.b2MotorJoint.prototype.m_angularImpulse = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_angularImpulse", box2d.b2MotorJoint.prototype.m_angularImpulse);
box2d.b2MotorJoint.prototype.m_maxForce = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_maxForce", box2d.b2MotorJoint.prototype.m_maxForce);
box2d.b2MotorJoint.prototype.m_maxTorque = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_maxTorque", box2d.b2MotorJoint.prototype.m_maxTorque);
box2d.b2MotorJoint.prototype.m_correctionFactor = 0.3;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_correctionFactor", box2d.b2MotorJoint.prototype.m_correctionFactor);
box2d.b2MotorJoint.prototype.m_indexA = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_indexA", box2d.b2MotorJoint.prototype.m_indexA);
box2d.b2MotorJoint.prototype.m_indexB = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_indexB", box2d.b2MotorJoint.prototype.m_indexB);
box2d.b2MotorJoint.prototype.m_rA = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_rA", box2d.b2MotorJoint.prototype.m_rA);
box2d.b2MotorJoint.prototype.m_rB = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_rB", box2d.b2MotorJoint.prototype.m_rB);
box2d.b2MotorJoint.prototype.m_localCenterA = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_localCenterA", box2d.b2MotorJoint.prototype.m_localCenterA);
box2d.b2MotorJoint.prototype.m_localCenterB = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_localCenterB", box2d.b2MotorJoint.prototype.m_localCenterB);
box2d.b2MotorJoint.prototype.m_linearError = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_linearError", box2d.b2MotorJoint.prototype.m_linearError);
box2d.b2MotorJoint.prototype.m_angularError = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_angularError", box2d.b2MotorJoint.prototype.m_angularError);
box2d.b2MotorJoint.prototype.m_invMassA = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_invMassA", box2d.b2MotorJoint.prototype.m_invMassA);
box2d.b2MotorJoint.prototype.m_invMassB = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_invMassB", box2d.b2MotorJoint.prototype.m_invMassB);
box2d.b2MotorJoint.prototype.m_invIA = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_invIA", box2d.b2MotorJoint.prototype.m_invIA);
box2d.b2MotorJoint.prototype.m_invIB = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_invIB", box2d.b2MotorJoint.prototype.m_invIB);
box2d.b2MotorJoint.prototype.m_linearMass = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_linearMass", box2d.b2MotorJoint.prototype.m_linearMass);
box2d.b2MotorJoint.prototype.m_angularMass = 0;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_angularMass", box2d.b2MotorJoint.prototype.m_angularMass);
box2d.b2MotorJoint.prototype.m_qA = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_qA", box2d.b2MotorJoint.prototype.m_qA);
box2d.b2MotorJoint.prototype.m_qB = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_qB", box2d.b2MotorJoint.prototype.m_qB);
box2d.b2MotorJoint.prototype.m_K = null;
goog.exportProperty(box2d.b2MotorJoint.prototype, "m_K", box2d.b2MotorJoint.prototype.m_K);
box2d.b2MotorJoint.prototype.GetAnchorA = function(a) {
    return this.m_bodyA.GetPosition(a)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetAnchorA", box2d.b2MotorJoint.prototype.GetAnchorA);
box2d.b2MotorJoint.prototype.GetAnchorB = function(a) {
    return this.m_bodyB.GetPosition(a)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetAnchorB", box2d.b2MotorJoint.prototype.GetAnchorB);
box2d.b2MotorJoint.prototype.GetReactionForce = function(a, b) {
    return box2d.b2MulSV(a, this.m_linearImpulse, b)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetReactionForce", box2d.b2MotorJoint.prototype.GetReactionForce);
box2d.b2MotorJoint.prototype.GetReactionTorque = function(a) {
    return a * this.m_angularImpulse
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetReactionTorque", box2d.b2MotorJoint.prototype.GetReactionTorque);
box2d.b2MotorJoint.prototype.SetLinearOffset = function(a) {
    box2d.b2IsEqualToV(a, this.m_linearOffset) || (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_linearOffset.Copy(a))
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SetLinearOffset", box2d.b2MotorJoint.prototype.SetLinearOffset);
box2d.b2MotorJoint.prototype.GetLinearOffset = function(a) {
    return a.Copy(this.m_linearOffset)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetLinearOffset", box2d.b2MotorJoint.prototype.GetLinearOffset);
box2d.b2MotorJoint.prototype.SetAngularOffset = function(a) {
    a != this.m_angularOffset && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_angularOffset = a)
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SetAngularOffset", box2d.b2MotorJoint.prototype.SetAngularOffset);
box2d.b2MotorJoint.prototype.GetAngularOffset = function() {
    return this.m_angularOffset
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetAngularOffset", box2d.b2MotorJoint.prototype.GetAngularOffset);
box2d.b2MotorJoint.prototype.SetMaxForce = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a) && 0 <= a);
    this.m_maxForce = a
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SetMaxForce", box2d.b2MotorJoint.prototype.SetMaxForce);
box2d.b2MotorJoint.prototype.GetMaxForce = function() {
    return this.m_maxForce
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetMaxForce", box2d.b2MotorJoint.prototype.GetMaxForce);
box2d.b2MotorJoint.prototype.SetMaxTorque = function(a) {
    box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(a) && 0 <= a);
    this.m_maxTorque = a
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SetMaxTorque", box2d.b2MotorJoint.prototype.SetMaxTorque);
box2d.b2MotorJoint.prototype.GetMaxTorque = function() {
    return this.m_maxTorque
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "GetMaxTorque", box2d.b2MotorJoint.prototype.GetMaxTorque);
box2d.b2MotorJoint.prototype.InitVelocityConstraints = function(a) {
    this.m_indexA = this.m_bodyA.m_islandIndex;
    this.m_indexB = this.m_bodyB.m_islandIndex;
    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
    this.m_invMassA = this.m_bodyA.m_invMass;
    this.m_invMassB = this.m_bodyB.m_invMass;
    this.m_invIA = this.m_bodyA.m_invI;
    this.m_invIB = this.m_bodyB.m_invI;
    var b = a.positions[this.m_indexA].c, c = a.positions[this.m_indexA].a, e = a.velocities[this.m_indexA].v,
            d = a.velocities[this.m_indexA].w, f = a.positions[this.m_indexB].c, g = a.positions[this.m_indexB].a, h = a.velocities[this.m_indexB].v, l = a.velocities[this.m_indexB].w, k = this.m_qA.SetAngleRadians(c), m = this.m_qB.SetAngleRadians(g), n = box2d.b2MulRV(k, box2d.b2NegV(this.m_localCenterA, box2d.b2Vec2.s_t0), this.m_rA), m = box2d.b2MulRV(m, box2d.b2NegV(this.m_localCenterB, box2d.b2Vec2.s_t0), this.m_rB), p = this.m_invMassA, q = this.m_invMassB, r = this.m_invIA, t = this.m_invIB, s = this.m_K;
    s.ex.x = p + q + r * n.y * n.y + t * m.y * m.y;
    s.ex.y = -r * n.x *
            n.y - t * m.x * m.y;
    s.ey.x = s.ex.y;
    s.ey.y = p + q + r * n.x * n.x + t * m.x * m.x;
    s.GetInverse(this.m_linearMass);
    this.m_angularMass = r + t;
    0 < this.m_angularMass && (this.m_angularMass = 1 / this.m_angularMass);
    box2d.b2SubVV(box2d.b2SubVV(box2d.b2AddVV(f, m, box2d.b2Vec2.s_t0), box2d.b2AddVV(b, n, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t2), box2d.b2MulRV(k, this.m_linearOffset, box2d.b2Vec2.s_t3), this.m_linearError);
    this.m_angularError = g - c - this.m_angularOffset;
    a.step.warmStarting ? (this.m_linearImpulse.SelfMul(a.step.dtRatio), this.m_angularImpulse *=
            a.step.dtRatio, b = this.m_linearImpulse, e.SelfMulSub(p, b), d -= r * (box2d.b2CrossVV(n, b) + this.m_angularImpulse), h.SelfMulAdd(q, b), l += t * (box2d.b2CrossVV(m, b) + this.m_angularImpulse)) : (this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0);
    a.velocities[this.m_indexA].w = d;
    a.velocities[this.m_indexB].w = l
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "InitVelocityConstraints", box2d.b2MotorJoint.prototype.InitVelocityConstraints);
box2d.b2MotorJoint.prototype.SolveVelocityConstraints = function(a) {
    var b = a.velocities[this.m_indexA].v, c = a.velocities[this.m_indexA].w, e = a.velocities[this.m_indexB].v, d = a.velocities[this.m_indexB].w, f = this.m_invMassA, g = this.m_invMassB, h = this.m_invIA, l = this.m_invIB, k = a.step.dt, m = a.step.inv_dt, n = d - c + m * this.m_correctionFactor * this.m_angularError, n = -this.m_angularMass * n, p = this.m_angularImpulse, q = k * this.m_maxTorque;
    this.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + n, -q, q);
    var n = this.m_angularImpulse -
            p, c = c - h * n, d = d + l * n, r = this.m_rA, t = this.m_rB, n = box2d.b2AddVV(box2d.b2SubVV(box2d.b2AddVV(e, box2d.b2CrossSV(d, t, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2AddVV(b, box2d.b2CrossSV(c, r, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t2), box2d.b2MulSV(m * this.m_correctionFactor, this.m_linearError, box2d.b2Vec2.s_t3), box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot), n = box2d.b2MulMV(this.m_linearMass, n, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg(), p = box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_linearImpulse);
    this.m_linearImpulse.SelfAdd(n);
    q = k * this.m_maxForce;
    this.m_linearImpulse.GetLengthSquared() > q * q && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.SelfMul(q));
    box2d.b2SubVV(this.m_linearImpulse, p, n);
    b.SelfMulSub(f, n);
    c -= h * box2d.b2CrossVV(r, n);
    e.SelfMulAdd(g, n);
    d += l * box2d.b2CrossVV(t, n);
    a.velocities[this.m_indexA].w = c;
    a.velocities[this.m_indexB].w = d
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SolveVelocityConstraints", box2d.b2MotorJoint.prototype.SolveVelocityConstraints);
box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2;
box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2;
box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2;
box2d.b2MotorJoint.prototype.SolvePositionConstraints = function(a) {
    return!0
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "SolvePositionConstraints", box2d.b2MotorJoint.prototype.SolvePositionConstraints);
box2d.b2MotorJoint.prototype.Dump = function() {
    if (box2d.DEBUG) {
        var a = this.m_bodyA.m_islandIndex, b = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2MotorJointDef*/ var jd = new box2d.b2MotorJointDef();\n");
        box2d.b2Log("  jd.bodyA = bodies[%d];\n", a);
        box2d.b2Log("  jd.bodyB = bodies[%d];\n", b);
        box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
        box2d.b2Log("  jd.linearOffset.SetXY(%.15f, %.15f);\n", this.m_linearOffset.x, this.m_linearOffset.y);
        box2d.b2Log("  jd.angularOffset = %.15f;\n",
                this.m_angularOffset);
        box2d.b2Log("  jd.maxForce = %.15f;\n", this.m_maxForce);
        box2d.b2Log("  jd.maxTorque = %.15f;\n", this.m_maxTorque);
        box2d.b2Log("  jd.correctionFactor = %.15f;\n", this.m_correctionFactor);
        box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index)
    }
};
goog.exportProperty(box2d.b2MotorJoint.prototype, "Dump", box2d.b2MotorJoint.prototype.Dump);
/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

goog.provide('box2d.Render');

goog.require('box2d');

goog.require('goog.string.format');

/** 
 * This class implements debug drawing callbacks that are 
 * invoked inside b2World::Step. 
 * @export 
 * @constructor
 * @extends {box2d.b2Draw} 
 * @param {object} opts
 */
box2d.b2DebugDraw = function (opts)
{
	goog.base(this);

    this.scale = opts.scale
	this.m_canvas = opts.canvas || false
	this.m_ctx = opts.ctx ||Â false
    this.m_settings = opts.flags || box2d.b2DrawFlags.e_shapeBit
    this.alpha = opts.alpha || 0.5
}

goog.inherits(box2d.b2DebugDraw, box2d.b2Draw);

/**
 * @export 
 * @type {HTMLCanvasElement} 
 */
box2d.b2DebugDraw.prototype.m_canvas = null;
/**
 * @export 
 * @type {CanvasRenderingContext2D} 
 */
box2d.b2DebugDraw.prototype.m_ctx = null;
/**
 * @export 
 * @type {box2d.Settings} 
 */
box2d.b2DebugDraw.prototype.m_settings = null;

box2d.b2DebugDraw.prototype.scale = 40;
box2d.b2DebugDraw.prototype.alpha = 0.5;


/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Transform} xf 
 */
box2d.b2DebugDraw.prototype.PushTransform = function (xf)
{
	var ctx = this.m_ctx;
	ctx.save();
    ctx.globalAlpha = this.alpha
	ctx.translate(xf.p.x * this.scale, xf.p.y * this.scale);
	ctx.rotate(xf.q.GetAngleRadians());
}

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Transform} xf 
 */
box2d.b2DebugDraw.prototype.PopTransform = function (xf)
{
	var ctx = this.m_ctx;
	ctx.restore();
}

/**
 * @export 
 * @return {void} 
 * @param {Array.<box2d.b2Vec2>} vertices 
 * @param {number} vertexCount 
 * @param {box2d.b2Color} color 
 */
box2d.b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color)
{
	if (!vertexCount) return;

	var ctx = this.m_ctx;

	ctx.beginPath();
	ctx.moveTo(vertices[0].x, vertices[0].y);
	for (var i = 1; i < vertexCount; i++)
	{
		ctx.lineTo(vertices[i].x * this.scale, vertices[i].y * this.scale);
	}
	ctx.closePath();
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {Array.<box2d.b2Vec2>} vertices 
 * @param {number} vertexCount 
 * @param {box2d.b2Color} color 
 */
box2d.b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color)
{
    if (!vertexCount) return;

	var ctx = this.m_ctx;

	ctx.beginPath();
	ctx.moveTo(vertices[0].x * this.scale, vertices[0].y * this.scale);
	for (var i = 1; i < vertexCount; i++)
	{
		ctx.lineTo(vertices[i].x * this.scale, vertices[i].y * this.scale);
	}
	ctx.closePath();
	ctx.fillStyle = color.MakeStyleString(0.5);
	ctx.fill();
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} center 
 * @param {number} radius 
 * @param {box2d.b2Color} color 
 */
box2d.b2DebugDraw.prototype.DrawCircle = function (center, radius, color)
{
    if (!radius) return;

	var ctx = this.m_ctx;

	ctx.beginPath();
	ctx.arc(center.x * this.scale, center.y * this.scale, radius * this.scale, 0, box2d.b2_pi * 2, true);
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} center 
 * @param {number} radius 
 * @param {box2d.b2Vec2} axis 
 * @param {box2d.b2Color} color 
 */
box2d.b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color)
{
	if (!radius) return;

	var ctx = this.m_ctx;

	var cx = center.x * this.scale;
	var cy = center.y * this.scale;
	ctx.beginPath();
	ctx.arc(cx, cy, radius, 0, box2d.b2_pi * 2, true);
	ctx.moveTo(cx, cy);
	ctx.lineTo((cx + axis.x * this.scale * radius), (cy + axis.y * this.scale * radius));
	ctx.fillStyle = color.MakeStyleString(0.5);
	ctx.fill();
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} p1 
 * @param {box2d.b2Vec2} p2 
 * @param {box2d.b2Color} color 
 */
box2d.b2DebugDraw.prototype.DrawSegment = function (p1, p2, color)
{
	var ctx = this.m_ctx;

	ctx.beginPath();
	ctx.moveTo(p1.x * this.scale, p1.y * this.scale);
	ctx.lineTo(p2.x * this.scale, p2.y * this.scale);
	ctx.strokeStyle = color.MakeStyleString(1);
	ctx.stroke();
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Transform} xf 
 */
box2d.b2DebugDraw.prototype.DrawTransform = function (xf)
{
	var ctx = this.m_ctx;

	this.PushTransform(xf);

	ctx.beginPath();
	ctx.moveTo(0, 0);
	ctx.lineTo(1, 0);
	ctx.strokeStyle = box2d.b2Color.RED.MakeStyleString(1);
	ctx.stroke();

	ctx.beginPath();
	ctx.moveTo(0, 0);
	ctx.lineTo(0, 1);
	ctx.strokeStyle = box2d.b2Color.GREEN.MakeStyleString(1);
	ctx.stroke();

	this.PopTransform(xf);
};

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2Vec2} p 
 * @param {number} size 
 * @param {box2d.b2Color} color 
 */
box2d.b2DebugDraw.prototype.DrawPoint = function (p, size, color)
{
	var ctx = this.m_ctx;

	ctx.fillStyle = color.MakeStyleString();
	size /= this.m_settings.viewZoom;
	size /= this.m_settings.canvasScale;
	var hsize = size / 2;
	ctx.fillRect(p.x * this.scale - hsize, p.y * this.scale - hsize, size, size);
}

/**
 * @export 
 * @param {number} x 
 * @param {number} y 
 * @param {string} format
 * @param {...string|number} var_args 
 */
box2d.b2DebugDraw.prototype.DrawString = function (x, y, format, var_args)
{
	var ctx = this.m_ctx;

	var args = Array.prototype.slice.call(arguments);
	var string = goog.string.format.apply(null, args.slice(2));

	ctx.save();
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.font = '18pt helvetica';//'9pt lucida console';
		var color = box2d.b2DebugDraw.prototype.DrawString.s_color;
		ctx.fillStyle = color.MakeStyleString();
		ctx.fillText(string, x * this.scale, y * this.scale);
	ctx.restore();
}
box2d.b2DebugDraw.prototype.DrawString.s_color = new box2d.b2Color(0.9, 0.6, 0.6);

/**
 * @export 
 * @param {number} x 
 * @param {number} y 
 * @param {string} format
 * @param {...string|number} var_args 
 */
box2d.b2DebugDraw.prototype.DrawStringWorld = function (x, y, format, var_args)
{
	var p = box2d.b2DebugDraw.prototype.DrawStringWorld.s_p.SetXY(x, y);

	// world -> viewport
	var vt = this.m_settings.viewCenter;
	box2d.b2SubVV(p, vt, p);
	var vr = this.m_settings.viewRotation;
	box2d.b2MulTRV(vr, p, p);
	var vs = this.m_settings.viewZoom;
	box2d.b2MulSV(vs, p, p);

	// viewport -> canvas
	var cs = this.m_settings.canvasScale;
	box2d.b2MulSV(cs, p, p);
	p.y *= -1;
	var cc = box2d.b2DebugDraw.prototype.DrawStringWorld.s_cc.SetXY(0.5 * this.m_canvas.width, 0.5 * this.m_canvas.height);
	box2d.b2AddVV(p, cc, p);

	var ctx = this.m_ctx;

	var args = Array.prototype.slice.call(arguments);
	var string = goog.string.format.apply(null, args.slice(2));

	ctx.save();
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.font = '18pt helvetica';//'9pt lucida console';
		var color = box2d.b2DebugDraw.prototype.DrawStringWorld.s_color;
		ctx.fillStyle = color.MakeStyleString();
		ctx.fillText(string, p.x * this.scale, p.y * this.scale);
	ctx.restore();
}
box2d.b2DebugDraw.prototype.DrawStringWorld.s_p = new box2d.b2Vec2();
box2d.b2DebugDraw.prototype.DrawStringWorld.s_cc = new box2d.b2Vec2();
box2d.b2DebugDraw.prototype.DrawStringWorld.s_color = new box2d.b2Color(0.5, 0.9, 0.5);

/**
 * @export 
 * @return {void} 
 * @param {box2d.b2AABB} aabb 
 * @param {box2d.b2Color} color 
 */
box2d.b2DebugDraw.prototype.DrawAABB = function (aabb, color)
{
	var ctx = this.m_ctx;

	ctx.strokeStyle = color.MakeStyleString();
	var x = aabb.lowerBound.x;
	var y = aabb.lowerBound.y;
	var w = aabb.upperBound.x - aabb.lowerBound.x;
	var h = aabb.upperBound.y - aabb.lowerBound.y;
	ctx.strokeRect(x * this.scale, y * this.scale, w * this.scale, h * this.scale);
}

box2d.b2DebugDraw.prototype.SetFlags = function (flags) {
    this.m_settings = flags
}

box2d.b2DebugDraw.prototype.GetFlags = function () {
    return this.m_settings
}
//'remove' namespace for less code writing ;o)
var b2AABB = box2d.b2AABB,
    b2Body = box2d.b2Body,
    b2BodyDef = box2d.b2BodyDef,
    b2ChainShape = box2d.b2ChainShape,
    b2CircleShape = box2d.b2CircleShape,
    b2ContactListener = box2d.b2ContactListener,
    b2DebugDraw = box2d.b2DebugDraw,
    b2EdgeChainDef = box2d.b2EdgeChainDef,
    b2EdgeShape = box2d.b2EdgeShape,
    b2Fixture = box2d.b2Fixture,
    b2FixtureDef = box2d.b2FixtureDef,
    b2Joint = box2d.b2Joint,
    b2MassData = box2d.b2MassData,
    b2Mat22 = box2d.b2Mat22,
    b2MouseJointDef = box2d.b2MouseJointDef,
    b2PolygonShape = box2d.b2PolygonShape,
    b2PrismaticJointDef = box2d.b2PrismaticJointDef,
    b2RevoluteJointDef = box2d.b2RevoluteJointDef,
    b2Settings = box2d.b2Settings,
    b2Shape = box2d.b2Shape,
    b2World = box2d.b2World,
    b2WorldManifold = box2d.b2WorldManifold,
    b2Vec2 = box2d.b2Vec2/**
 *  Â© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DEntity is the base class with properties for all B2D objects.
 * This class handles also the drawings for all classes.
 *
 * @class CG.B2DEntity
 * @extends CG.Entity
 */

CG.Entity.extend('B2DEntity', {
    /**
     * @method init
     * @constructor
     * @param name      {String}      id or name to identify
     * @param image     {mixed}       path to image, image or tpimage from asset
     * @param world     {object}      reference to world of B2DWorld
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param scale     {Number}     the world scale of B2DWorld
     * @return {*}
     */

    init:function (name, image, world, x, y, scale) {
        this._super()
        this.setImage(image)
        /**
         * @property body
         * @type {b2Body}
         */
        this.body = {}
        /**
         * @property x
         * @type {Number}
         */
        this.x = x
        /**
         * @property y
         * @type {Number}
         */
        this.y = y
        /**
         * @property scale
         * @type {Number}
         */
        this.scale = scale
        /**
         * @property id
         * @type {Object}
         */
        this.id = {name:name, uid:0}
        /**
         * @property world
         * @type {b2World}
         */
        this.world = world
        /**
         * @property xhandle
         * @type {Number}
         */
        this.xhandle = (this.width / 2)
        /**
         * @property yhandle
         * @type {Number}
         */
        this.yhandle = (this.height / 2)
        if(!this.bodyDef){
            /**
             * @property bodyDef
             * @type {b2BodyDef}
             */
            this.bodyDef = new b2BodyDef
            /**
             * @property bodyDef.alowSleep
             * @type {Boolean}
             */
            this.bodyDef.allowSleep = true
            /**
             * @property bodyDef.awake
             * @type {Boolean}
             */
            this.bodyDef.awake = true
        }

        if(!this.fixDef) {
            /**
             * @property fixDef
             * @type {b2FixtureDef}
             */
            this.fixDef = new b2FixtureDef
            /**
             * @property fixDef.density
             * @type {Number}
             */
            this.fixDef.density = 1.0
            /**
             * @property fixDef.friction
             * @type {Number}
             */
            this.fixDef.friction = 0.5
            /**
             * @property fixDef.restitution
             * @type {Number}
             */
            this.fixDef.restitution = 0.5
        }
        /**
         * @property isHit
         * @type {Boolean}
         */
        this.isHit = false;
        /**
         * @property strength
         * @type {Number}
         */
        this.strength = 100;
        /**
         * @property dead
         * @type {Boolean}
         */
        this.dead = false;

        return this
    },
    /**
     * @method hit
     * @param impulse
     * @param source
     */
    hit:function (impulse, source) {
        this.isHit = true;
        if (this.strength) {
            this.strength -= impulse;
            if (this.strength <= 0) {
                this.dead = true
            }
        }
    },
    update:function () {
    },
    draw:function () {
        Game.b_ctx.save()
        Game.b_ctx.globalAlpha = this.alpha
        Game.b_ctx.translate(this.body.GetPosition().x * this.scale, this.body.GetPosition().y * this.scale)
        if (this.atlasimage) {
            Game.b_ctx.rotate((this.body.GetAngleRadians() - this.imagerotation)) // * CG.Const_PI_180)
            Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - this.xhandle, 0 - this.yhandle, this.cutwidth, this.cutheight)
        } else {
            Game.b_ctx.rotate(this.body.GetAngleRadians()) // * CG.Const_PI_180)
            Game.b_ctx.drawImage(this.image, 0 - this.xhandle, 0 - this.yhandle, this.image.width, this.image.height)
        }
        Game.b_ctx.restore()
    }
})


/**
 *  Â© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DCircle is a simple b2CircleShape wrapper element with basic physics properties.
 *
 * @class CG.B2DCirlce
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DCircle', {
    /**
     * @method init
     * @constructor
     * @param world     {Object}      reference to world of B2DWorld
     * @param name      {String}      id or name to identify
     * @param image     {mixed}       path to image, image or tpimage from asset
     * @param radius    {Number}     json file from PhysicsEditor from asset
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param scale     {Number}     the world scale of B2DWorld
     * @param stat      {Boolean}     is the body static or dynamic
     * @return {*}
     */
    init:function (world, name, image, radius, x, y, scale, stat) {
        this._super(name, image, world, x, y, scale)
        /**
         * @property radius
         * @type {Number}
         */
        this.radius = this.width / 2
        /**
         * @property stat
         * @type {*}
         */
        this.stat = stat || false

        /**
         * @property bodyDef.type
         * @type {b2Body.b2_staticBody/b2Body.b2_dynamicBody}
         */
        if (this.stat) {
            this.bodyDef.type = box2d.b2BodyType.b2_staticBody
        } else {
            this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody
        }
        /**
         * @property bodyDef.position.x
         * @type {Number}
         */
        this.bodyDef.position.x = this.x / this.scale
        /**
         * @property bodyDef.position.y
         * @type {Number}
         */
        this.bodyDef.position.y = this.y / this.scale
        /**
         * @property bdyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property fixDef.shape
         * @type {b2CircleShape}
         */
        this.fixDef.shape = new b2CircleShape(this.radius / this.scale)

        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)
        this.body.CreateFixture(this.fixDef)

        return this

    }
})


/**
 *  Â© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DLine is a simple b2PolygonShape wrapper. There is no visible drawing
 * now in the canvas for now. It can be used to build walls, ground,. ,.
 *
 * @class CG.B2DLine
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DLine', {
    /**
     * @method init
     * @constructor
     * @param world     {Object}      reference to world of B2DWorld
     * @param name      {String}      id or name to identify
     * @param start     {b2Vec2}      start of line
     * @param end       {b2Vec2}      end of line
     * @param scale     {Number}     the world scale of B2DWorld
     * @return {*}
     */
    init:function (world, name, start, end, scale) {
        this._super(name, false, world, 0, 0, scale) //TODO clean arguments?
        /**
         * @property start
         * @type {b2Vec2}
         */
        this.start = start
        /**
         * @property end
         * @type {b2Vec2}
         */
        this.end = end
        /**
         * @property xhandle
         * @type {Number}
         */
        this.xhandle = 0
        /**
         * @property yhandle
         * @type {Number}
         */
        this.yhandle = 0
        /**
         * @property fixDef.shape
         * @type {b2PolygonShape}
         */
        this.fixDef.shape = new b2EdgeShape()
        this.fixDef.shape.Set(this.start, this.end)
        /**
         * @property bodyDef.type
         * @type {Number}
         */
        this.bodyDef.type = box2d.b2BodyType.b2_staticBody
        /**
         * @property bodyDef.position
         */
        this.bodyDef.position.SetXY(0 / this.scale, 0 / this.scale)
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)
        this.body.CreateFixture(this.fixDef)

        return this
    },
    update:function () {

    },
    draw:function () {

    }
})


/**
 *  Â© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DRectangle is a simple b2PolygonShape wrapper element with basic physics properties.
 *
 * @class CG.B2DRectangle
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DRectangle', {
    /**
     * @method init
     * @constructor
     * @param world     {Object}      reference to world of B2DWorld
     * @param name      {String}      id or name to identify
     * @param image     {mixed}     path to image, image or tpimage from asset
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param scale     {Number}     the world scale of B2DWorld
     * @param stat      {Boolean}     is the body static or dynamic
     * @return {*}
     */
    init:function (world, name, image, x, y, scale, stat) {
        this._super(name, image, world, x, y, scale)
        /**
         * @Ï€roperty stat
         * @type {*}
         */
        this.stat = stat
        /**
         * @property bodyDef.stat
         * @type {b2Body.b2_staticBody/b2Body.b2_dynamicBody}
         */
        if (this.stat) {
            this.bodyDef.type = box2d.b2BodyType.b2_staticBody
        } else {
            this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody
        }
        /**
         * @property fixDef.shape
         * @type {b2PolygonShape}
         */
        this.fixDef.shape = new b2PolygonShape
        this.fixDef.shape.SetAsBox(this.width / scale * 0.5, this.height / scale * 0.5)
        /**
         * @property bodyDef.position.x
         * @type {Number}
         */
        this.bodyDef.position.x = this.x / this.scale
        /**
         * @property bodyDef.position.y
         * @type {Number}
         */
        this.bodyDef.position.y = this.y / this.scale
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)
        this.body.CreateFixture(this.fixDef)

        return this
    }
})


/**
 *  Â© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DPolygon  is a simple b2PolygonShape wrapper element with basic physics properties.
 * It uses PhysicsEditor json files, use export Lime + Corona (json).
 * Supported options for now are friction, density and bounce and would be set to B2DPolygon.
 *
 * @class CG.B2DPolygon
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DPolygon', {
    /**
     * @method init
     * @constructor
     * @param world     {Object}      reference to world of B2DWorld
     * @param name      {String}      id or name to identify
     * @param image     {mixed}       path to image, image or tpimage from asset
     * @param jsonpoly  {string}      json file from PhysicsEditor from asset
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param scale     {Number}     the world scale of B2DWorld
     * @param stat      {Boolean}     is the body static or dynamic
     * @param bullet    {Boolean}     bullet option
     * @return {*}
     */
    init:function (world, name, image, jsonpoly, x, y, scale, stat, bullet) {
        this._super(name, image, world, x, y, scale)
        /**
         * @property stat
         * @type {*}
         */
        this.stat = stat || false
        /**
         * @property polys
         * @type {Array}
         */
        this.polys = new Array()
        /**
         * @property jsondata
         * @type {*}
         */
//        this.jsondata = jsonpoly.data[jsonpoly.name]
        this.jsondata = jsonpoly.data[name]
        /**
         * @property xhandle
          * @type {Number}
         */
        this.xhandle = 0
        /**
         * @property yhandle
         * @type {Number}
         */
        this.yhandle = 0
        /**
         * @property vecs
         * @type {Array}
         */
        this.vecs = new Array()
        this.vecs = this.getPolysFromJson(jsonpoly) // build grouped b2vecs from physicseditor

        /**
         * @property bodyDef.type
         * @type {b2Body.b2_staticBody/b2Body.b2_dynamicBody}
         */
        if (this.stat) {
            this.bodyDef.type = box2d.b2BodyType.b2_staticBody
        } else {
            this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody
        }
        /**
         * @property bodyDef.position
         */
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property bullet
         * @type {*}
         */
        this.bullet = bullet || false
        /**
         * @property bodyDef.bullet
         * @type {*}
         */
        this.bodyDef.bullet = this.bullet

        //this.bodyDef.linearDamping = options.linearDamping
        //this.bodyDef.angularDamping = options.angularDamping
        //this.bodyDef.fixedRotation = true

        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)

        for (var i = 0, l = this.vecs.length; i < l; i++) {
            this.bodyShapePoly = new b2PolygonShape
            this.bodyShapePoly.bounce = this.jsondata[i].restitution        //value from physics editor
            this.bodyShapePoly.SetAsArray(this.vecs[i], this.vecs[i].length)
            this.fixDef.density = this.jsondata[i].density                  //value from physics editor
            this.fixDef.friction = this.jsondata[i].friction                //value from physics editor
            //this.fixDef.restitution = 0
            //this.fixDef.density = 10

            this.fixDef.shape = this.bodyShapePoly
            this.body.CreateFixture(this.fixDef)
        }
        return this

    },
    /**
     * @description extract the polygons out of the PhysicsEditor json file and collect them into an array
     *
     * @method getPolysFromJson
     * @return {Array}
     */
    getPolysFromJson:function () {
        var vecs = []
        for (var i = 0, l = this.jsondata.length; i < l; i++) {
            poly = this.jsondata[i].shape
            var temp = []
            for (var i2 = 0, l2 = poly.length; i2 < l2; i2 = i2 + 2) {
                vec = new b2Vec2(poly[i2] / this.scale, poly[i2 + 1] / this.scale)
                temp.push(vec)
            }
            vecs.push(temp)
        }
        return vecs
    }
})


/**
 *  Â© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DTerrain
 *
 * @class CG.B2DPolygon
 * @extends CG.B2DEntity
 */

//@TODO add function for clipping and triangulating polygons
//@TODO box2d body handling
//@TODO handling for terrain bitmap

CG.B2DEntity.extend('B2DTerrain', {
    /**
     * @method init
     * @constructor
     * @param world     {Object}      reference to world of B2DWorld
     * @param name      {String}      id or name to identify
     * @param image     {mixed}       path to image, image or tpimage from asset
     * @param terrainPoly  {array}      array of vertices to start terrain building
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param scale     {Number}     the world scale of B2DWorld
     * @param stat      {Boolean}     is the body static or dynamic
     * @param bullet    {Boolean}     bullet option
     * @return {*}
     */
    init: function (world, name, image, terrainPoly, x, y, scale, stat, bullet) {
        this._super(name, image, world, x, y, scale)
        /**
         * @property stat
         * @type {*}
         */
        this.stat = stat || false
        /**
         * @property polys
         * @type {Array}
         */
        this.polys = new Array()
        /**
         * @property terrainpoly
         * @type {*}
         */
        this.terrainPoly = terrainPoly

        this.terrainTriangles = []

        /**
         * @property holes
         * @type {Array}
         */
        this.holes = []
        /**
         * @property xhandle
         * @type {Number}
         */
        this.xhandle = 0
        /**
         * @property yhandle
         * @type {Number}
         */
        this.yhandle = 0

        /**
         * @property bodyDef.type
         * @type {b2Body.b2_staticBody/b2Body.b2_dynamicBody}
         */
        if (this.stat) {
            this.bodyDef.type = box2d.b2BodyType.b2_staticBody
        } else {
            this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody
        }
        /**
         * @property bodyDef.position
         */
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property bullet
         * @type {*}
         */
        this.bullet = bullet || false
        /**
         * @property bodyDef.bullet
         * @type {*}
         */
        this.bodyDef.bullet = this.bullet


        /**
         * @property body
         * @type {b2Body}
         */

        this.createTerrain()

        return this

    },
    createTerrain: function () {
        // @TODO poly2tri
        this.body = this.world.CreateBody(this.bodyDef)

        for (var part = 0, len = this.terrainPoly.length; part < len; part++) {
            var swctx = new poly2tri.SweepContext(this.terrainPoly[part].outer, {cloneArrays: true})

            if (this.terrainPoly[part].holes.length > 0) {
                for (var i = 0, l = this.terrainPoly[part].holes.length; i < l; i++) {
                    swctx.addHole(this.terrainPoly[part].holes[i])
                }
            }

            swctx.triangulate();

            this.terrainTriangles = this.terrainTriangles.concat(swctx.getTriangles() || [])
        }

        for (var i = 0, l = this.terrainTriangles.length; i < l; i++) {
            this.bodyShapePoly = new b2PolygonShape
            this.bodyShapePoly.bounce = 0.5
            this.bodyShapePoly.SetAsArray(this.getPolysFromTriangulation(this.terrainTriangles[i].points_), this.terrainTriangles[i].points_.length)
            this.fixDef.density = 0.5
            this.fixDef.friction = 0.5
            //this.fixDef.restitution = 0
            //this.fixDef.density = 10

            this.fixDef.shape = this.bodyShapePoly
            this.body.CreateFixture(this.fixDef)
        }
    },
    deleteTerrain: function () {
        //remove triangles
        this.terrainTriangles = []
        //remove body from b2world
        this.world.DestroyBody(this.body)
    },
    clippTerrain: function (point) {
        var newhole = this.createCircle(20, point, 20)

        //add new hole to all contour terrainPolys
        for (var part = 0, len = this.terrainPoly.length; part < len; part++) {
            this.terrainPoly[part].holes.push(newhole)
        }


        //@TODO use clipper to calculate new terrainPolys
        var tempPolys = []
        for (var part = 0, len = this.terrainPoly.length; part < len; part++) {
            var subj_polygons = [this.terrainPoly[part].outer]
            console.log('outer')
            console.log(subj_polygons)
            var clip_polygons = []
            if (this.terrainPoly[part].holes.length > 0) {
                for (var i = 0, l = this.terrainPoly[part].holes.length; i < l; i++) {
                    clip_polygons.push(this.terrainPoly[part].holes[i])
                }
            }
            console.log('holes')
            console.log(clip_polygons)
            var cpr = new ClipperLib.Clipper()
            cpr.AddPolygons(subj_polygons, ClipperLib.PolyType.ptSubject)
            cpr.AddPolygons(clip_polygons, ClipperLib.PolyType.ptClip)

            var solution_polygons = new ClipperLib.ExPolygons()
            cpr.Execute(ClipperLib.ClipType.ctDifference, solution_polygons, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero)
            tempPolys.push(solution_polygons[0])
        }
        this.terrainPoly = tempPolys
        this.deleteTerrain()
        this.createTerrain()

        console.log('Clipper result')
        console.log(tempPolys)

        //@TODO save clipper result back to terrainPolys
    },
    pauseWorld: function () {
        this.world.framerate = 0
    },
    resumeWorld: function () {
        this.world.framerate = 1 / 60
    },
    /**
     * @description extract the triangles out of poly2tri array
     *
     * @method getPolysFromJson
     * @return {Array}
     */
    getPolysFromTriangulation: function (pointsArray) {
        var vecs = []
        for (var i = 0, l = pointsArray.length; i < l; i++) {
            var poly = pointsArray[i]
            vecs.push(new b2Vec2(poly.x / this.scale, poly.y / this.scale))
        }
        return vecs
    },
    createCircle: function (precision, origin, radius) {
        var angle = 2 * Math.PI / precision
        var circleArray = []
        for (var i = 0; i < precision; i++) {
            circleArray.push({x: origin.x + radius * Math.cos(angle * i), y: origin.y + radius * Math.sin(angle * i)})
        }
        return circleArray
    },
    update: function () {

    },
    draw: function () {

    }
})


/**
 *  Â© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DChainShape
 *
 * @class CG.B2DChainShape
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DChainShape', {
    /**
     * @method init
     * @constructor
     * @param world     {Object}      reference to world of B2DWorld
     * @param name      {String}      id or name to identify
     * @param vertices  {array}      vertices for chainshape CG.Point array
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param scale     {Number}     the world scale of B2DWorld
     * @param stat     {Boolean}     true if static body
     * @return {*}
     */
    init:function (world, name, vertices, x, y, scale, stat) {
        this._super(name, false, world, x, y, scale)
        /**
         * @property stat
         * @type {*}
         */
        this.stat = stat || false
        /**
         * @property polys
         * @type {Array}
         */
        this.vertices = this.convertRealWorldPointToBox2DVec2(vertices)
        /**
         * @property xhandle
          * @type {Number}
         */
        this.xhandle = 0
        /**
         * @property yhandle
         * @type {Number}
         */
        this.yhandle = 0
        /**
         * @property bodyDef.type
         * @type {b2Body.b2_staticBody/b2Body.b2_dynamicBody}
         */
        if (this.stat) {
            this.bodyDef.type = box2d.b2BodyType.b2_staticBody
        } else {
            this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody
        }
        /**
         * @property bodyDef.position
         */
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        /**
         * @property bodyDef.userData
         * @type {*}
         */
        this.bodyDef.userData = this.id
        /**
         * @property body
         * @type {b2Body}
         */
        /**
         * @property fixDef.shape
         * @type {b2CircleShape}
         */
        this.fixDef.shape = new b2ChainShape()
        this.fixDef.shape.CreateChain(this.vertices, this.vertices.length)

        /**
         * @property body
         * @type {b2Body}
         */
        this.body = this.world.CreateBody(this.bodyDef)
        this.body.CreateFixture(this.fixDef)

        return this

    },
    /**
     * @description
     *
     * convertRealWorldPointToBox2DVec2 converts real world vectors to box2d world vecs depending on scale
     *
     * @method convertRealWorldPointToBox2DVec2
     * @param {Array} vertices CG.Point array
     * @return {Array} vecs b2Vec2  with box2d world scale
     */
    convertRealWorldPointToBox2DVec2:function (vertices) {
        var vecs = []
        for (var i = 0, l = vertices.length; i < l; i++) {
            var vec = new b2Vec2(vertices[i].x / this.scale, vertices[i].y / this.scale)
            vecs.push(vec)
        }
        return vecs
    },
    update:function () {

    },
    draw:function () {

    }

})


/**
 *  Â© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DRope is a simple wrapper that creates a rope with segments.
 * Just play with the params to get a good result.
 *
 * @class CG.B2DRope
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DRope', {
    /**
     * @method init
     * @constructor
     * @param world         {Object}      reference to world of B2DWorld
     * @param name          {String}      id or name to identify
     * @param image         {mixed}       path to image, image or tpimage from asset
     * @param x             {Number}     the x position
     * @param y             {Number}     the y position
     * @param length        {Number}     the length/width of the bridge
     * @param segments      {Number}     segments of the bridge
     * @param segmentWidth  {Number}     width of a segment
     * @param scale         {Number}     the world scale of B2DWorld
     * @return {*}
     */
    init:function (world, name, image, x, y, length, segments, segmentWidth, scale) {
        this._super(name, image, world, x, y, scale)
        /**
         * @property length
         * @type {Number}
         */
        this.length = length
        /**
         * @property segments
         * @type {Number}
         */
        this.segments = segments
        /**
         * @property segmentHeight
         * @type {Number}
         */
        this.segmentHeight = ((this.length - this.y) / this.segments) / 2
        /**
         * @property segmentWidth
         * @type {*}
         */
        this.segmentWidth = segmentWidth
        /**
         * @property anchor
         * @type {b2Vec2}
         */
        this.anchor = new b2Vec2()
        /**
         * @property prevBody
         * @type {Object}
         */
        this.prevBody = {}
        /**
         * @property bodyGroup
         * @type {Array}
         */
        this.bodyGroup = []
        /**
         * @property bodyCount
         * @type {Number}
         */
        this.bodyCount = 0

        // RopeStart
        this.fixtureDef = new b2FixtureDef()
        this.bodyShapeCircle = new b2CircleShape()
        this.bodyDef = new b2BodyDef()
        this.bodyDef.userData = this.id
        this.bodyShapeCircle.m_radius = this.segmentWidth / this.scale
        this.fixtureDef.density = 1.0
        this.fixtureDef.restitution = 0.2
        this.fixtureDef.friction = 0.2
        this.fixtureDef.shape = this.bodyShapeCircle
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        this.body = this.bodyGroup[0] = this.world.CreateBody(this.bodyDef)
        this.bodyGroup[0].CreateFixture(this.fixtureDef)
        this.prevBody = this.bodyGroup[0]

        // RopeSegments
        this.fixtureDef = new b2FixtureDef()
        this.bodyShapePoly = new b2PolygonShape()
        this.bodyDef = new b2BodyDef()
        this.bodyDef.userData = this.id
        this.bodyShapePoly.SetAsBox(this.segmentWidth / this.scale, this.segmentHeight / this.scale)
        this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody
        this.fixtureDef.shape = this.bodyShapePoly
        this.fixtureDef.density = 20.0
        this.fixtureDef.restitution = 0.2
        this.fixtureDef.friction = 0.2
        this.jointDef = new b2RevoluteJointDef()
        this.jointDef.lowerAngle = -25 / (180 / Math.PI)
        this.jointDef.upperAngle = 25 / (180 / Math.PI)
        this.jointDef.enableLimit = true


        for (var i = 0, l = this.segments; i < l; i++) {
            this.bodyDef.position.SetXY(this.x / this.scale, ((this.y + this.segmentHeight) + (this.segmentHeight * 2) * i) / this.scale)
            this.bodyGroup[i + 1] = this.world.CreateBody(this.bodyDef)
            this.bodyGroup[i + 1].CreateFixture(this.fixtureDef)
            this.anchor.SetXY(this.x / this.scale, (this.y + (this.segmentHeight * 2) * i) / this.scale)
            this.jointDef.Initialize(this.prevBody, this.bodyGroup[i + 1], this.anchor)
            this.world.CreateJoint(this.jointDef)
            this.prevBody = this.bodyGroup[i + 1]
            this.bodyCount = i + 1
        }

        return this

    },

    draw:function () {
        for (var i = 1; i <= this.bodyCount; i++) {
            var x = this.bodyGroup[i].GetPosition().x
            var y = this.bodyGroup[i].GetPosition().y
            var r = this.bodyGroup[i].GetAngleRadians()
            Game.b_ctx.save()
            Game.b_ctx.globalAlpha = this.alpha
            Game.b_ctx.translate(x * this.scale, y * this.scale)
            if (this.atlasimage) {
                Game.b_ctx.rotate(r - this.imagerotation) // * CG.Const_PI_180)
                Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - this.xhandle, 0 - this.yhandle, this.cutwidth, this.cutheight)
            } else {
                Game.b_ctx.rotate(r) // * CG.Const_PI_180)
                Game.b_ctx.drawImage(this.image, 0 - this.xhandle, 0 - this.yhandle, this.image.width, this.image.height)
            }
            Game.b_ctx.restore()
        }
    }
})


/**
 *  Â© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DBridge is a simple wrapper that creates a bridge with segments.
 * Just play with the params to get a good result.
 *
 * @class CG.B2DBridge
 * @extends CG.B2DEntity
 */

CG.B2DEntity.extend('B2DBridge', {
    /**
     * @method init
     * @constructor
     * @param world         {Object}      reference to world of B2DWorld
     * @param name          {String}      id or name to identify
     * @param image         {mixed}       path to image, image or tpimage from asset
     * @param x             {Number}     the x position
     * @param y             {Number}     the y position
     * @param length        {Number}     the length/width of the bridge
     * @param segments      {Number}     segments of the bridge
     * @param segmentHeight {Number}     height of a segment
     * @param scale         {Number}     the world scale of B2DWorld
     * @return {*}
     */
    init: function (world, name, image, x, y, length, segments, segmentHeight, scale) {
        this._super(name, image, world, x, y, scale)
        /**
         * @property length
         * @type {Number}
         */
        this.length = length
        /**
         * @property segments
         * @type {Number}
         */
        this.segments = segments
        /**
         * @property segmentHeight
         * @type {Number}
         */
        this.segmentHeight = segmentHeight
        /**
         * @property segmentWidth
         * @type {Number}
         */
        this.segmentWidth = ((this.length - this.x) / this.segments) / 2
        /**
         * @property anchor
         * @type {b2Vec2}
         */
        this.anchor = new b2Vec2()
        /**
         * @property prevBodf
         * @type {Object}
         */
        this.prevBody = {}
        /**
         * @property bodyGroup
         * @type {Array}
         */
        this.bodyGroup = []
        /**
         * @property bodyCount
         * @type {Number}
         */
        this.bodyCount = 0

        // BridgeStart

        this.fixtureDef = new b2FixtureDef()
        this.bodyShapeCircle = new b2CircleShape()
        this.bodyDef = new b2BodyDef()
        this.bodyDef.userData = this.id
        this.bodyShapeCircle.m_radius = this.segmentHeight / this.scale
        this.fixtureDef.density = 20.0
        this.fixtureDef.restitution = 0.2
        this.fixtureDef.friction = 0.2
        this.fixtureDef.shape = this.bodyShapeCircle
        this.bodyDef.position.SetXY(this.x / this.scale, this.y / this.scale)
        this.body = this.bodyGroup[0] = this.world.CreateBody(this.bodyDef)
        this.bodyGroup[0].CreateFixture(this.fixtureDef)
        this.prevBody = this.bodyGroup[0]

        // BridgeEnd
        this.bodyDef.position.SetXY(this.length / this.scale, this.y / this.scale)
        this.bodyDef.userData = this.id
        this.bodyGroup[1] = this.world.CreateBody(this.bodyDef)
        this.bodyGroup[1].CreateFixture(this.fixtureDef)

        // bridge elements
        this.fixtureDef = new b2FixtureDef()
        this.bodyShapePoly = new b2PolygonShape()
        this.bodyDef = new b2BodyDef()
        this.bodyDef.userData = this.id
        this.bodyShapePoly.SetAsBox(this.segmentWidth / this.scale, this.segmentHeight / this.scale)
        this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody
        this.fixtureDef.shape = this.bodyShapePoly
        this.fixtureDef.density = 20.0
        this.fixtureDef.restitution = 0.2
        this.fixtureDef.friction = 0.2
        this.jointDef = new b2RevoluteJointDef()
        this.jointDef.lowerAngle = -25 / (180 / Math.PI)
        this.jointDef.upperAngle = 25 / (180 / Math.PI)
        this.jointDef.enableLimit = true

        for (var i = 0, l = this.segments; i < l; i++) {
            this.bodyDef.position.SetXY(((this.x + this.segmentWidth) + (this.segmentWidth * 2) * i) / this.scale, this.y / this.scale)
            this.bodyGroup[i + 2] = this.world.CreateBody(this.bodyDef)
            this.bodyGroup[i + 2].CreateFixture(this.fixtureDef)
            this.anchor.SetXY((this.x + (this.segmentWidth * 2) * i) / this.scale, this.y / this.scale)
            this.jointDef.Initialize(this.prevBody, this.bodyGroup[i + 2], this.anchor)
            this.world.CreateJoint(this.jointDef)
            this.prevBody = this.bodyGroup[i + 2]
            this.bodyCount = i + 2
        }

        this.anchor.SetXY((this.x + (this.segmentWidth * 2) * this.segments - 1) / this.scale, this.y / this.scale)
        this.jointDef.Initialize(this.prevBody, this.bodyGroup[1], this.anchor)
        this.world.CreateJoint(this.jointDef)

        return this
    },
    draw: function () {
        for (var i = 2; i <= this.bodyCount; i++) {
            var x = this.bodyGroup[i].GetPosition().x
            var y = this.bodyGroup[i].GetPosition().y
            var r = this.bodyGroup[i].GetAngleRadians()
            Game.b_ctx.save()
            Game.b_ctx.globalAlpha = this.alpha
            Game.b_ctx.translate(x * this.scale, y * this.scale)
            if (this.atlasimage) {
                Game.b_ctx.rotate(r - this.imagerotation) // * CG.Const_PI_180)
                Game.b_ctx.drawImage(this.image, this.xoffset, this.yoffset, this.cutwidth, this.cutheight, 0 - this.xhandle, 0 - this.yhandle, this.cutwidth, this.cutheight)
            } else {
                Game.b_ctx.rotate(r) // * CG.Const_PI_180)
                Game.b_ctx.drawImage(this.image, 0 - this.xhandle, 0 - this.yhandle, this.image.width, this.image.height)
            }
            Game.b_ctx.restore()
        }
    }
})


/**
 *  Â© 2012 by Christian Sonntag <info@motions-media.de>
 *  simple experimental Canvas Game JavaScript Framework
 */


/**
 * @description
 *
 * B2DWorld is a Box2dWeb wrapper with basic and easy methods for creating Box2d Objects like
 * lines, circles, rectangles, polybodies, ropes and bridges. Custom B2D Objects that extends
 * one of the basic B2D objects can added to the B2DWorld with the addCustom method.
 * The CG.B2DWorld can attached to an CG.Screen object as layer. The B2DWorld will handle
 * all physics and drawings.
 *
 * @class CG.B2DWorld
 * @xtend CG.Layer
 */

CG.Layer.extend('B2DWorld', {
    /**
     * @method init
     * @constructor
     * @param name {String} name of the b2dworld
     * @param opt {object} additional options
     */
    init: function (name, opt) {

        this.framerate = 1 / 60

        /**
         * @property opt
         * @type {object}
         */
        opt = opt || {}

        /**
         * @property name
         * @type {String}
         */
        this.name = name || ''
        /**
         * @property debug
         * @type {Boolean}
         */
        this.debug = false
        /**
         * @property x
         * @type {Number}
         */
        this.x = 0
        /**
         * @property y
         * @type {Number}
         */
        this.y = 0
        /**
         * @property elements
         * @type {Array}
         */
        this.elements = []

        /**
         * @property world
         * @type {b2World}
         */
        this.world = new b2World(
            new b2Vec2(0, 10), //gravity
            opt.sleep || true        //allow sleep
        )
        /**
         * @property uid
         * @type {Number}
         */
        this.uid = 0 //uid counter for elements
        /**
         * @property scale
         * @type {Number}
         */
        this.scale = 40

        /**
         * add m_groundBody for use with b2MouseJoint
         */
        this.world.m_groundBody = this.world.CreateBody(new b2BodyDef());


        //setup debug draw
        var debugDraw = new b2DebugDraw({
            scale: this.scale,
            canvas: Game.b_canvas,
            ctx: Game.b_ctx,
            flags: box2d.b2DrawFlags.e_shapeBit | box2d.b2DrawFlags.e_jointBit
        })
        this.world.SetDebugDraw(debugDraw)

    },
    update: function () {

        this.world.Step(
            this.framerate   //frame-rate
            , 10       //velocity iterations
            , 10       //position iterations
        )

        if (CG.mousedown) {
            this.mouseDownAt(mousex, mousey);
        } else if (this.isMouseDown()) {
            this.mouseUp();
        }

        for (var i = 0, l = this.elements.length; i < l; i++) {
            this.elements[i].update()
        }


    },
    draw: function () {
        Game.b_ctx.save()
        Game.b_ctx.translate(this.x, this.y)

        //TODO ? place for CanvasRenderer ?

        for (var i = 0, l = this.elements.length; i < l; i++) {
            this.elements[i].draw()
        }

        if (this.debug) {
            this.world.DrawDebugData()
            this.world.ClearForces()
        }

        Game.b_ctx.restore()
    },
    /**
     * @description
     *
     * Custom extended objects can be added to the B2DWork with this method.
     *
     * @method addCustom
     * @param obj      object    custom B2D object
     */
    addCustom: function (obj) {
        this.uid = this.uid + 1
        obj.id.uid = this.uid
        this.elements.push(obj)
    },
    /**
     * @description
     *
     * createBox creates a basic Box2D rectangle with some default settings.
     *
     * @method createBox
     * @param id      {String}      id or name to identify
     * @param image   {mixed}       path to image, image or tpimage from asset
     * @param x       {Number}     the x position
     * @param y       {Number}     the y position
     * @param stat    {Boolean}     is the body static or dynamic
     */
    createBox: function (id, image, x, y, stat) {
        this.uid = this.uid + 1
        var entity = new CG.B2DRectangle(this.world, id, image, x, y, this.scale, stat)
        entity.id.uid = this.uid
        this.elements.push(entity)
    },
    /**
     * @description
     *
     * createLine creates a basic Box2D line with some default settings.
     *
     * @method createLine
     * @param id      {String}    id or name to identify
     * @param start   {CG.Point}  start o fline
     * @param end     {CG.Point}  end of line
     */
    createLine: function (id, start, end) {
        this.uid = this.uid + 1
        var entity = new CG.B2DLine(this.world, id, new b2Vec2(start.x / this.scale, start.y / this.scale), new b2Vec2(end.x / this.scale, end.y / this.scale), this.scale)
        entity.id.uid = this.uid
        this.elements.push(entity)
    },
    /**
     * @description
     *
     * createCircle creates a basic Box2D circle with some default settings
     *
     * @method createCircle
     * @param id      {String}      id or name to identify
     * @param image   {mixed}       path to image, image or tpimage from asset
     * @param radius  {Number}     the radius
     * @param x       {Number}     the x position
     * @param y       {Number}     the y position
     * @param stat    {Boolean}     is the body static or dynamic
     */
    createCircle: function (id, image, radius, x, y, stat) {
        this.uid = this.uid + 1
        var entity = new CG.B2DCircle(this.world, id, image, radius, x, y, this.scale, stat)
        entity.id.uid = this.uid
        this.elements.push(entity)
    },
    /**
     * @description
     *
     * createPolyBody creates a Box2D polybody. A PhysicsEditor json (Lime + Corona JSON Exporter) file is needed for this
     * Box2D object. The polygonshape and some settings like density, bounce and friction are
     * taken from the json file at the moment.
     *
     * @method createPolyBody
     * @param id        {String}      id or name to identify
     * @param image     {mixed}       path to image, image or tpimage from asset
     * @param jsonpoly  {String}      json file from PhysicsEditor from asset
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param stat      {Boolean}     is the body static or dynamic
     * @param bullet    {Boolean}     bullet option
     */
    createPolyBody: function (id, image, jsonpoly, x, y, stat, bullet) {
        this.uid = this.uid + 1
        var entity = new CG.B2DPolygon(this.world, id, image, jsonpoly, x, y, this.scale, stat, bullet)
        entity.id.uid = this.uid
        this.elements.push(entity)
    },
    /**
     * @description
     *
     * createTerrain
     *
     * @method createPolyBody
     * @param id        {String}      id or name to identify
     * @param image     {mixed}       path to image, image or tpimage from asset
     * @param terrainpoly  {Array}      array of vertices to start terrain building
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     * @param stat      {Boolean}     is the body static or dynamic
     * @param bullet    {Boolean}     bullet option
     */
    createTerrain: function (id, image, terrainpoly, x, y, stat, bullet) {
        this.uid = this.uid + 1
        var entity = new CG.B2DTerrain(this.world, id, image, terrainpoly, x, y, this.scale, stat, bullet)
        entity.id.uid = this.uid
        this.elements.push(entity)
    },
    /**
     * @description
     *
     * createChainShape
     *
     * @method createChainShape
     * @param id        {String}      id or name to identify
     * @param vertices  {array}      vertices for chainshape CG.Point array
     * @param x         {Number}     the x position
     * @param y         {Number}     the y position
     */
    createChainShape: function (id, vertices, x, y, stat) {
        this.uid = this.uid + 1
        var entity = new CG.B2DChainShape(this.world, id, vertices, x, y, this.scale, stat)
        entity.id.uid = this.uid
        this.elements.push(entity)
    },
    /**
     * @description
     *
     * This method creates a B2D bridge. Just play with the params to get a good result!
     *
     * @method createBridge
     * @param id          {String}      id or name to identify
     * @param image         {mixed}       path to image, image or tpimage from asset
     * @param x             {Number}     the x position
     * @param y             {Number}     the y position
     * @param length        {Number}     the length/width of the bridge
     * @param segments      {Number}     segments of the bridge
     * @param segmentHeight {Number}     height of a segment
     * @return {*}
     */
    createBridge: function (id, image, x, y, length, segments, segmentHeight) {
        this.uid = this.uid + 1
        var entity = new CG.B2DBridge(this.world, id, image, x, y, length, segments, segmentHeight, this.scale)
        entity.id.uid = this.uid
        this.elements.push(entity)
    },
    /**
     * @description
     *
     * This method creates a B2D rope. Just play with the params to get a good result!
     *
     * @method createRope
     * @param id            {String}      id or name to identify
     * @param image         {mixed}       path to image, image or tpimage from asset
     * @param x             {Number}     the x position
     * @param y             {Number}     the y position
     * @param length        {Number}     the length/width of the bridge
     * @param segments      {Number}     segments of the bridge
     * @param segmentHeight {Number}     height of a segment
     * @return {*}
     */
    createRope: function (id, image, x, y, length, segments, segmentHeight) {
        this.uid = this.uid + 1
        var entity = new CG.B2DRope(this.world, id, image, x, y, length, segments, segmentHeight, this.scale)
        entity.id.uid = this.uid
        this.elements.push(entity)
    },
    /**
     * @description
     *
     * Enables dragging B2D objects with the mouse.
     *
     * @method mouseDownAt
     * @param x {Number}
     * @param y {Number}
     */
    mouseDownAt: function (x, y) {
        if (!this.mouseJoint) {
            var body = this.getBodyAt(x, y)
            console.log(body)
            if (body) {
                var md = new b2MouseJointDef()
                md.bodyA = this.world.m_groundBody
                md.bodyB = body
                md.target.SetXY((x - this.x) / this.scale, (y - this.y) / this.scale)
                md.collideConnected = true
                md.maxForce = 300.0 * body.GetMass()
                this.mouseJoint = this.world.CreateJoint(md)
                body.SetAwake(true);
            }
        } else {
            this.mouseJoint.SetTarget(new b2Vec2((x - this.x) / this.scale, (y - this.y) / this.scale))
        }
    },
    /**
     * @method mouseUp
     */
    mouseUp: function () {
        this.world.DestroyJoint(this.mouseJoint);
        this.mouseJoint = null;
    },
    /**
     * @description
     *
     * Get a B2D body at the give x, y position.
     *
     * @method getBodyAt
     * @param x {Number}
     * @param y {Number}
     * @return {*}
     */
    getBodyAt: function (x, y) {
        var worldx = (x - this.x) / this.scale;
        var worldy = (y - this.y) / this.scale

        var mousePVec = new b2Vec2(worldx, worldy)  //b2world offset for x and y!!!
        var aabb = new b2AABB()
        aabb.lowerBound.SetXY(worldx - 0.001, worldy - 0.001)
        aabb.upperBound.SetXY(worldx + 0.001, worldy + 0.001)

        // Query the world for overlapping shapes.

        var selectedBody = null;
        this.world.QueryAABB(function (fixture) {
            if (fixture.GetBody().GetType() != b2Body.b2_staticBody) {
                if (fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
                    selectedBody = fixture.GetBody();
                    return false;
                }
            }
            return true;
        }, aabb);
        return selectedBody;
    },
    /**
     * @description
     *
     * Deletes a B2D body at the given x, y position
     *
     * @method deleteBodyAt
     * @param x {Number}
     * @param y (Number)
     * @return {Boolean}
     */
    deleteBodyAt: function (x, y) {
        body = this.getBodyAt(x, y)
        if (body) {
            for (var i = 0, l = this.elements.length; i < l; i++) {
                //if b2entity found delete entity and b2body
                if (this.elements[i].body.m_userData.uid == body.m_userData.uid) {
                    this.removeElementByIndex(i)
                    this.world.DestroyBody(body)
                    return true
                }
            }
        }
        return false
    },
    /**
     * @method isMouseDown
     * @return {Boolean}
     */
    isMouseDown: function () {
        return (this.mouseJoint != null);
    },
    /**
     * @method removeElementByIndex
     * @param index
     */
    removeElementByIndex: function (index) {
        this.elements.splice(index, 1);
    },
    /**
     * @method applyImpulse
     * @param body
     * @param degrees
     * @param power
     */
    applyImpulse: function (body, degrees, power) {
        if (body) {
            body.ApplyLinearImpulse(new b2Vec2(Math.cos(degrees * (Math.PI / 180)) * power,
                Math.sin(degrees * (Math.PI / 180)) * power),
                body.GetWorldCenter());
        }
    },
    /**
     * @method addContactListener
     * @param callbacks
     */
    addContactListener: function (callbacks) {
        var listener = new box2d.b2ContactListener;
        if (callbacks.BeginContact) listener.BeginContact = function (contact) {
            callbacks.BeginContact(contact.GetFixtureA().GetBody().GetUserData(),
                contact.GetFixtureB().GetBody().GetUserData());
        }
        if (callbacks.EndContact) listener.EndContact = function (contact) {
            callbacks.EndContact(contact.GetFixtureA().GetBody().GetUserData(),
                contact.GetFixtureB().GetBody().GetUserData());
        }
        if (callbacks.PostSolve) listener.PostSolve = function (contact, impulse) {
            callbacks.PostSolve(contact.GetFixtureA().GetBody().GetUserData(),
                contact.GetFixtureB().GetBody().GetUserData(),
                impulse.normalImpulses[0]);
        }
        if (callbacks.PreSolve) listener.PreSolve = function (contact, oldManifold) {
            callbacks.PreSolve(contact, oldManifold);
        }
        this.world.SetContactListener(listener);
    },
    /**
     * @method getBodySpec
     * @param b
     * @return {Object}
     */
    getBodySpec: function (b) {
        return {x: b.GetPosition().x, y: b.GetPosition().y, a: b.GetAngle(), c: {x: b.GetWorldCenter().x, y: b.GetWorldCenter().y}};
    }

})


