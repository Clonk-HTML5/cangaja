<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>cangaja&#x2F;lib-ext&#x2F;spine.js - Cangaja API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="Cangaja API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/CG.Animation.html">CG.Animation</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DBridge.html">CG.B2DBridge</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DChainShape.html">CG.B2DChainShape</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DCirlce.html">CG.B2DCirlce</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DEntity.html">CG.B2DEntity</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DLine.html">CG.B2DLine</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DPolygon.html">CG.B2DPolygon</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DRectangle.html">CG.B2DRectangle</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DRope.html">CG.B2DRope</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DWorld.html">CG.B2DWorld</a></li>
            
                <li><a href="..&#x2F;classes/CG.Bitmap.html">CG.Bitmap</a></li>
            
                <li><a href="..&#x2F;classes/CG.Bound.html">CG.Bound</a></li>
            
                <li><a href="..&#x2F;classes/CG.Buffer.html">CG.Buffer</a></li>
            
                <li><a href="..&#x2F;classes/CG.Button.html">CG.Button</a></li>
            
                <li><a href="..&#x2F;classes/CG.CanvasRenderer.html">CG.CanvasRenderer</a></li>
            
                <li><a href="..&#x2F;classes/CG.Delta.html">CG.Delta</a></li>
            
                <li><a href="..&#x2F;classes/CG.Director.html">CG.Director</a></li>
            
                <li><a href="..&#x2F;classes/CG.Emitter.html">CG.Emitter</a></li>
            
                <li><a href="..&#x2F;classes/CG.Entity.html">CG.Entity</a></li>
            
                <li><a href="..&#x2F;classes/CG.Font.html">CG.Font</a></li>
            
                <li><a href="..&#x2F;classes/CG.Layer.html">CG.Layer</a></li>
            
                <li><a href="..&#x2F;classes/CG.Map.html">CG.Map</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapArea.html">CG.MapArea</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapPoint.html">CG.MapPoint</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapTileLayer.html">CG.MapTileLayer</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapTileProperties.html">CG.MapTileProperties</a></li>
            
                <li><a href="..&#x2F;classes/CG.MediaAsset.html">CG.MediaAsset</a></li>
            
                <li><a href="..&#x2F;classes/CG.Menu.html">CG.Menu</a></li>
            
                <li><a href="..&#x2F;classes/CG.Morph.html">CG.Morph</a></li>
            
                <li><a href="..&#x2F;classes/CG.Particle.html">CG.Particle</a></li>
            
                <li><a href="..&#x2F;classes/CG.Point.html">CG.Point</a></li>
            
                <li><a href="..&#x2F;classes/CG.Rectangle.html">CG.Rectangle</a></li>
            
                <li><a href="..&#x2F;classes/CG.Screen.html">CG.Screen</a></li>
            
                <li><a href="..&#x2F;classes/CG.Sequence.html">CG.Sequence</a></li>
            
                <li><a href="..&#x2F;classes/CG.Sprite.html">CG.Sprite</a></li>
            
                <li><a href="..&#x2F;classes/CG.Text.html">CG.Text</a></li>
            
                <li><a href="..&#x2F;classes/CG.TexturePacker.html">CG.TexturePacker</a></li>
            
                <li><a href="..&#x2F;classes/CG.TPImage.html">CG.TPImage</a></li>
            
                <li><a href="..&#x2F;classes/CG.Translate.html">CG.Translate</a></li>
            
                <li><a href="..&#x2F;classes/CG.Vector.html">CG.Vector</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/CG.html">CG</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: cangaja&#x2F;lib-ext&#x2F;spine.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;******************************************************************************
 * Spine Runtime Software License - Version 1.1
 * 
 * Copyright (c) 2013, Esoteric Software
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms in whole or in part, with
 * or without modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. A Spine Essential, Professional, Enterprise, or Education License must
 *    be purchased from Esoteric Software and the license must remain valid:
 *    http:&#x2F;&#x2F;esotericsoftware.com&#x2F;
 * 2. Redistributions of source code must retain this license, which is the
 *    above copyright notice, this declaration of conditions and the following
 *    disclaimer.
 * 3. Redistributions in binary form must reproduce this license, which is the
 *    above copyright notice, this declaration of conditions and the following
 *    disclaimer, in the documentation and&#x2F;or other materials provided with the
 *    distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************&#x2F;

var spine = {};

spine.BoneData = function (name, parent) {
	this.name = name;
	this.parent = parent;
};
spine.BoneData.prototype = {
	length: 0,
	x: 0, y: 0,
	rotation: 0,
	scaleX: 1, scaleY: 1,
	inheritScale: true,
	inheritRotation: true
};

spine.SlotData = function (name, boneData) {
	this.name = name;
	this.boneData = boneData;
};
spine.SlotData.prototype = {
	r: 1, g: 1, b: 1, a: 1,
	attachmentName: null,
	additiveBlending: false
};

spine.Bone = function (boneData, parent) {
	this.data = boneData;
	this.parent = parent;
	this.setToSetupPose();
};
spine.Bone.yDown = false;
spine.Bone.prototype = {
	x: 0, y: 0,
	rotation: 0,
	scaleX: 1, scaleY: 1,
	m00: 0, m01: 0, worldX: 0, &#x2F;&#x2F; a b x
	m10: 0, m11: 0, worldY: 0, &#x2F;&#x2F; c d y
	worldRotation: 0,
	worldScaleX: 1, worldScaleY: 1,
	updateWorldTransform: function (flipX, flipY) {
		var parent = this.parent;
		if (parent != null) {
			this.worldX = this.x * parent.m00 + this.y * parent.m01 + parent.worldX;
			this.worldY = this.x * parent.m10 + this.y * parent.m11 + parent.worldY;
			if (this.data.inheritScale) {
				this.worldScaleX = parent.worldScaleX * this.scaleX;
				this.worldScaleY = parent.worldScaleY * this.scaleY;
			} else {
				this.worldScaleX = this.scaleX;
				this.worldScaleY = this.scaleY;
			}
			this.worldRotation = this.data.inheritRotation ? parent.worldRotation + this.rotation : this.rotation;
		} else {
			this.worldX = this.x;
			this.worldY = this.y;
			this.worldScaleX = this.scaleX;
			this.worldScaleY = this.scaleY;
			this.worldRotation = this.rotation;
		}
		var radians = this.worldRotation * Math.PI &#x2F; 180;
		var cos = Math.cos(radians);
		var sin = Math.sin(radians);
		this.m00 = cos * this.worldScaleX;
		this.m10 = sin * this.worldScaleX;
		this.m01 = -sin * this.worldScaleY;
		this.m11 = cos * this.worldScaleY;
		if (flipX) {
			this.m00 = -this.m00;
			this.m01 = -this.m01;
		}
		if (flipY != spine.Bone.yDown) {
			this.m10 = -this.m10;
			this.m11 = -this.m11;
		}
	},
	setToSetupPose: function () {
		var data = this.data;
		this.x = data.x;
		this.y = data.y;
		this.rotation = data.rotation;
		this.scaleX = data.scaleX;
		this.scaleY = data.scaleY;
	}
};

spine.Slot = function (slotData, skeleton, bone) {
	this.data = slotData;
	this.skeleton = skeleton;
	this.bone = bone;
	this.setToSetupPose();
};
spine.Slot.prototype = {
	r: 1, g: 1, b: 1, a: 1,
	_attachmentTime: 0,
	attachment: null,
	setAttachment: function (attachment) {
		this.attachment = attachment;
		this._attachmentTime = this.skeleton.time;
	},
	setAttachmentTime: function (time) {
		this._attachmentTime = this.skeleton.time - time;
	},
	getAttachmentTime: function () {
		return this.skeleton.time - this._attachmentTime;
	},
	setToSetupPose: function () {
		var data = this.data;
		this.r = data.r;
		this.g = data.g;
		this.b = data.b;
		this.a = data.a;

		var slotDatas = this.skeleton.data.slots;
		for (var i = 0, n = slotDatas.length; i &lt; n; i++) {
			if (slotDatas[i] == data) {
				this.setAttachment(!data.attachmentName ? null : this.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));
				break;
			}
		}
	}
};

spine.Skin = function (name) {
	this.name = name;
	this.attachments = {};
};
spine.Skin.prototype = {
	addAttachment: function (slotIndex, name, attachment) {
		this.attachments[slotIndex + &quot;:&quot; + name] = attachment;
	},
	getAttachment: function (slotIndex, name) {
		return this.attachments[slotIndex + &quot;:&quot; + name];
	},
	_attachAll: function (skeleton, oldSkin) {
		for (var key in oldSkin.attachments) {
			var colon = key.indexOf(&quot;:&quot;);
			var slotIndex = parseInt(key.substring(0, colon));
			var name = key.substring(colon + 1);
			var slot = skeleton.slots[slotIndex];
			if (slot.attachment &amp;&amp; slot.attachment.name == name) {
				var attachment = this.getAttachment(slotIndex, name);
				if (attachment) slot.setAttachment(attachment);
			}
		}
	}
};

spine.Animation = function (name, timelines, duration) {
	this.name = name;
	this.timelines = timelines;
	this.duration = duration;
};
spine.Animation.prototype = {
	apply: function (skeleton, lastTime, time, loop, events) {
		if (loop &amp;&amp; this.duration != 0) {
			time %= this.duration;
			lastTime %= this.duration;
		}
		var timelines = this.timelines;
		for (var i = 0, n = timelines.length; i &lt; n; i++)
			timelines[i].apply(skeleton, lastTime, time, events, 1);
	},
	mix: function (skeleton, lastTime, time, loop, events, alpha) {
		if (loop &amp;&amp; this.duration != 0) {
			time %= this.duration;
			lastTime %= this.duration;
		}
		var timelines = this.timelines;
		for (var i = 0, n = timelines.length; i &lt; n; i++)
			timelines[i].apply(skeleton, lastTime, time, events, alpha);
	}
};

spine.binarySearch = function (values, target, step) {
	var low = 0;
	var high = Math.floor(values.length &#x2F; step) - 2;
	if (high == 0) return step;
	var current = high &gt;&gt;&gt; 1;
	while (true) {
		if (values[(current + 1) * step] &lt;= target)
			low = current + 1;
		else
			high = current;
		if (low == high) return (low + 1) * step;
		current = (low + high) &gt;&gt;&gt; 1;
	}
};
spine.linearSearch = function (values, target, step) {
	for (var i = 0, last = values.length - step; i &lt;= last; i += step)
		if (values[i] &gt; target) return i;
	return -1;
};

spine.Curves = function (frameCount) {
	this.curves = []; &#x2F;&#x2F; dfx, dfy, ddfx, ddfy, dddfx, dddfy, ...
	this.curves.length = (frameCount - 1) * 6;
};
spine.Curves.prototype = {
	setLinear: function (frameIndex) {
		this.curves[frameIndex * 6] = 0&#x2F;*LINEAR*&#x2F;;
	},
	setStepped: function (frameIndex) {
		this.curves[frameIndex * 6] = -1&#x2F;*STEPPED*&#x2F;;
	},
	&#x2F;** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.
	 * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of
	 * the difference between the keyframe&#x27;s values. *&#x2F;
	setCurve: function (frameIndex, cx1, cy1, cx2, cy2) {
		var subdiv_step = 1 &#x2F; 10&#x2F;*BEZIER_SEGMENTS*&#x2F;;
		var subdiv_step2 = subdiv_step * subdiv_step;
		var subdiv_step3 = subdiv_step2 * subdiv_step;
		var pre1 = 3 * subdiv_step;
		var pre2 = 3 * subdiv_step2;
		var pre4 = 6 * subdiv_step2;
		var pre5 = 6 * subdiv_step3;
		var tmp1x = -cx1 * 2 + cx2;
		var tmp1y = -cy1 * 2 + cy2;
		var tmp2x = (cx1 - cx2) * 3 + 1;
		var tmp2y = (cy1 - cy2) * 3 + 1;
		var i = frameIndex * 6;
		var curves = this.curves;
		curves[i] = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv_step3;
		curves[i + 1] = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv_step3;
		curves[i + 2] = tmp1x * pre4 + tmp2x * pre5;
		curves[i + 3] = tmp1y * pre4 + tmp2y * pre5;
		curves[i + 4] = tmp2x * pre5;
		curves[i + 5] = tmp2y * pre5;
	},
	getCurvePercent: function (frameIndex, percent) {
		percent = percent &lt; 0 ? 0 : (percent &gt; 1 ? 1 : percent);
		var curveIndex = frameIndex * 6;
		var curves = this.curves;
		var dfx = curves[curveIndex];
		if (!dfx&#x2F;*LINEAR*&#x2F;) return percent;
		if (dfx == -1&#x2F;*STEPPED*&#x2F;) return 0;
		var dfy = curves[curveIndex + 1];
		var ddfx = curves[curveIndex + 2];
		var ddfy = curves[curveIndex + 3];
		var dddfx = curves[curveIndex + 4];
		var dddfy = curves[curveIndex + 5];
		var x = dfx, y = dfy;
		var i = 10&#x2F;*BEZIER_SEGMENTS*&#x2F; - 2;
		while (true) {
			if (x &gt;= percent) {
				var lastX = x - dfx;
				var lastY = y - dfy;
				return lastY + (y - lastY) * (percent - lastX) &#x2F; (x - lastX);
			}
			if (i == 0) break;
			i--;
			dfx += ddfx;
			dfy += ddfy;
			ddfx += dddfx;
			ddfy += dddfy;
			x += dfx;
			y += dfy;
		}
		return y + (1 - y) * (percent - x) &#x2F; (1 - x); &#x2F;&#x2F; Last point is 1,1.
	}
};

spine.RotateTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; &#x2F;&#x2F; time, angle, ...
	this.frames.length = frameCount * 2;
};
spine.RotateTimeline.prototype = {
	boneIndex: 0,
	getFrameCount: function () {
		return this.frames.length &#x2F; 2;
	},
	setFrame: function (frameIndex, time, angle) {
		frameIndex *= 2;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = angle;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time &lt; frames[0]) return; &#x2F;&#x2F; Time is before first frame.

		var bone = skeleton.bones[this.boneIndex];

		if (time &gt;= frames[frames.length - 2]) { &#x2F;&#x2F; Time is after last frame.
			var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;
			while (amount &gt; 180)
				amount -= 360;
			while (amount &lt; -180)
				amount += 360;
			bone.rotation += amount * alpha;
			return;
		}

		&#x2F;&#x2F; Interpolate between the last frame and the current frame.
		var frameIndex = spine.binarySearch(frames, time, 2);
		var lastFrameValue = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) &#x2F; (frames[frameIndex - 2&#x2F;*LAST_FRAME_TIME*&#x2F;] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex &#x2F; 2 - 1, percent);

		var amount = frames[frameIndex + 1&#x2F;*FRAME_VALUE*&#x2F;] - lastFrameValue;
		while (amount &gt; 180)
			amount -= 360;
		while (amount &lt; -180)
			amount += 360;
		amount = bone.data.rotation + (lastFrameValue + amount * percent) - bone.rotation;
		while (amount &gt; 180)
			amount -= 360;
		while (amount &lt; -180)
			amount += 360;
		bone.rotation += amount * alpha;
	}
};

spine.TranslateTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; &#x2F;&#x2F; time, x, y, ...
	this.frames.length = frameCount * 3;
};
spine.TranslateTimeline.prototype = {
	boneIndex: 0,
	getFrameCount: function () {
		return this.frames.length &#x2F; 3;
	},
	setFrame: function (frameIndex, time, x, y) {
		frameIndex *= 3;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = x;
		this.frames[frameIndex + 2] = y;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time &lt; frames[0]) return; &#x2F;&#x2F; Time is before first frame.

		var bone = skeleton.bones[this.boneIndex];

		if (time &gt;= frames[frames.length - 3]) { &#x2F;&#x2F; Time is after last frame.
			bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;
			bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;
			return;
		}

		&#x2F;&#x2F; Interpolate between the last frame and the current frame.
		var frameIndex = spine.binarySearch(frames, time, 3);
		var lastFrameX = frames[frameIndex - 2];
		var lastFrameY = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) &#x2F; (frames[frameIndex + -3&#x2F;*LAST_FRAME_TIME*&#x2F;] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex &#x2F; 3 - 1, percent);

		bone.x += (bone.data.x + lastFrameX + (frames[frameIndex + 1&#x2F;*FRAME_X*&#x2F;] - lastFrameX) * percent - bone.x) * alpha;
		bone.y += (bone.data.y + lastFrameY + (frames[frameIndex + 2&#x2F;*FRAME_Y*&#x2F;] - lastFrameY) * percent - bone.y) * alpha;
	}
};

spine.ScaleTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; &#x2F;&#x2F; time, x, y, ...
	this.frames.length = frameCount * 3;
};
spine.ScaleTimeline.prototype = {
	boneIndex: 0,
	getFrameCount: function () {
		return this.frames.length &#x2F; 3;
	},
	setFrame: function (frameIndex, time, x, y) {
		frameIndex *= 3;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = x;
		this.frames[frameIndex + 2] = y;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time &lt; frames[0]) return; &#x2F;&#x2F; Time is before first frame.

		var bone = skeleton.bones[this.boneIndex];

		if (time &gt;= frames[frames.length - 3]) { &#x2F;&#x2F; Time is after last frame.
			bone.scaleX += (bone.data.scaleX - 1 + frames[frames.length - 2] - bone.scaleX) * alpha;
			bone.scaleY += (bone.data.scaleY - 1 + frames[frames.length - 1] - bone.scaleY) * alpha;
			return;
		}

		&#x2F;&#x2F; Interpolate between the last frame and the current frame.
		var frameIndex = spine.binarySearch(frames, time, 3);
		var lastFrameX = frames[frameIndex - 2];
		var lastFrameY = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) &#x2F; (frames[frameIndex + -3&#x2F;*LAST_FRAME_TIME*&#x2F;] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex &#x2F; 3 - 1, percent);

		bone.scaleX += (bone.data.scaleX - 1 + lastFrameX + (frames[frameIndex + 1&#x2F;*FRAME_X*&#x2F;] - lastFrameX) * percent - bone.scaleX) * alpha;
		bone.scaleY += (bone.data.scaleY - 1 + lastFrameY + (frames[frameIndex + 2&#x2F;*FRAME_Y*&#x2F;] - lastFrameY) * percent - bone.scaleY) * alpha;
	}
};

spine.ColorTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; &#x2F;&#x2F; time, r, g, b, a, ...
	this.frames.length = frameCount * 5;
};
spine.ColorTimeline.prototype = {
	slotIndex: 0,
	getFrameCount: function () {
		return this.frames.length &#x2F; 5;
	},
	setFrame: function (frameIndex, time, r, g, b, a) {
		frameIndex *= 5;
		this.frames[frameIndex] = time;
		this.frames[frameIndex + 1] = r;
		this.frames[frameIndex + 2] = g;
		this.frames[frameIndex + 3] = b;
		this.frames[frameIndex + 4] = a;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time &lt; frames[0]) return; &#x2F;&#x2F; Time is before first frame.

		var slot = skeleton.slots[this.slotIndex];

		if (time &gt;= frames[frames.length - 5]) { &#x2F;&#x2F; Time is after last frame.
			var i = frames.length - 1;
			slot.r = frames[i - 3];
			slot.g = frames[i - 2];
			slot.b = frames[i - 1];
			slot.a = frames[i];
			return;
		}

		&#x2F;&#x2F; Interpolate between the last frame and the current frame.
		var frameIndex = spine.binarySearch(frames, time, 5);
		var lastFrameR = frames[frameIndex - 4];
		var lastFrameG = frames[frameIndex - 3];
		var lastFrameB = frames[frameIndex - 2];
		var lastFrameA = frames[frameIndex - 1];
		var frameTime = frames[frameIndex];
		var percent = 1 - (time - frameTime) &#x2F; (frames[frameIndex - 5&#x2F;*LAST_FRAME_TIME*&#x2F;] - frameTime);
		percent = this.curves.getCurvePercent(frameIndex &#x2F; 5 - 1, percent);

		var r = lastFrameR + (frames[frameIndex + 1&#x2F;*FRAME_R*&#x2F;] - lastFrameR) * percent;
		var g = lastFrameG + (frames[frameIndex + 2&#x2F;*FRAME_G*&#x2F;] - lastFrameG) * percent;
		var b = lastFrameB + (frames[frameIndex + 3&#x2F;*FRAME_B*&#x2F;] - lastFrameB) * percent;
		var a = lastFrameA + (frames[frameIndex + 4&#x2F;*FRAME_A*&#x2F;] - lastFrameA) * percent;
		if (alpha &lt; 1) {
			slot.r += (r - slot.r) * alpha;
			slot.g += (g - slot.g) * alpha;
			slot.b += (b - slot.b) * alpha;
			slot.a += (a - slot.a) * alpha;
		} else {
			slot.r = r;
			slot.g = g;
			slot.b = b;
			slot.a = a;
		}
	}
};

spine.AttachmentTimeline = function (frameCount) {
	this.curves = new spine.Curves(frameCount);
	this.frames = []; &#x2F;&#x2F; time, ...
	this.frames.length = frameCount;
	this.attachmentNames = [];
	this.attachmentNames.length = frameCount;
};
spine.AttachmentTimeline.prototype = {
	slotIndex: 0,
	getFrameCount: function () {
		return this.frames.length;
	},
	setFrame: function (frameIndex, time, attachmentName) {
		this.frames[frameIndex] = time;
		this.attachmentNames[frameIndex] = attachmentName;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time &lt; frames[0]) return; &#x2F;&#x2F; Time is before first frame.

		var frameIndex;
		if (time &gt;= frames[frames.length - 1]) &#x2F;&#x2F; Time is after last frame.
			frameIndex = frames.length - 1;
		else
			frameIndex = spine.binarySearch(frames, time, 1) - 1;

		var attachmentName = this.attachmentNames[frameIndex];
		skeleton.slots[this.slotIndex].setAttachment(!attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));
	}
};

spine.EventTimeline = function (frameCount) {
	this.frames = []; &#x2F;&#x2F; time, ...
	this.frames.length = frameCount;
	this.events = [];
	this.events.length = frameCount;
};
spine.EventTimeline.prototype = {
	getFrameCount: function () {
		return this.frames.length;
	},
	setFrame: function (frameIndex, time, event) {
		this.frames[frameIndex] = time;
		this.events[frameIndex] = event;
	},
	&#x2F;** Fires events for frames &gt; lastTime and &lt;= time. *&#x2F;
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		if (!firedEvents) return;

		var frames = this.frames;
		var frameCount = frames.length;

		if (lastTime &gt; time) { &#x2F;&#x2F; Fire events after last time for looped animations.
			apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);
			lastTime = -1f;
		} else if (lastTime &gt;= frames[frameCount - 1]) &#x2F;&#x2F; Last time is after last frame.
			return;
		if (time &lt; frames[0]) return; &#x2F;&#x2F; Time is before first frame.

		var frameIndex;
		if (lastTime &lt; frames[0])
			frameIndex = 0;
		else {
			frameIndex = spine.binarySearch(frames, lastTime, 1);
			var frame = frames[frameIndex];
			while (frameIndex &gt; 0) { &#x2F;&#x2F; Fire multiple events with the same frame.
				if (frames[frameIndex - 1] != frame) break;
				frameIndex--;
			}
		}
		var events = this.events;
		for (; frameIndex &lt; frameCount &amp;&amp; time &gt;= frames[frameIndex]; frameIndex++)
			firedEvents.push(events[frameIndex]);
	}
};

spine.DrawOrderTimeline = function (frameCount) {
	this.frames = []; &#x2F;&#x2F; time, ...
	this.frames.length = frameCount;
	this.drawOrders = [];
	this.drawOrders.length = frameCount;
};
spine.DrawOrderTimeline.prototype = {
	getFrameCount: function () {
		return this.frames.length;
	},
	setFrame: function (frameIndex, time, drawOrder) {
		this.frames[frameIndex] = time;
		this.drawOrders[frameIndex] = drawOrder;
	},
	apply: function (skeleton, lastTime, time, firedEvents, alpha) {
		var frames = this.frames;
		if (time &lt; frames[0]) return; &#x2F;&#x2F; Time is before first frame.

		var frameIndex;
		if (time &gt;= frames[frames.length - 1]) &#x2F;&#x2F; Time is after last frame.
			frameIndex = frames.length - 1;
		else
			frameIndex = spine.binarySearch(frames, time, 1) - 1;

		var drawOrder = skeleton.drawOrder;
		var slots = skeleton.slots;
		var drawOrderToSetupIndex = this.drawOrders[frameIndex];
		if (!drawOrderToSetupIndex) {
			for (var i = 0, n = slots.length; i &lt; n; i++)
				drawOrder[i] = slots[i];
		} else {
			for (var i = 0, n = drawOrderToSetupIndex.length; i &lt; n; i++)
				drawOrder[i] = skeleton.slots[drawOrderToSetupIndex[i]];
		}

	}
};

spine.SkeletonData = function () {
	this.bones = [];
	this.slots = [];
	this.skins = [];
	this.events = [];
	this.animations = [];
};
spine.SkeletonData.prototype = {
	defaultSkin: null,
	&#x2F;** @return May be null. *&#x2F;
	findBone: function (boneName) {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i &lt; n; i++)
			if (bones[i].name == boneName) return bones[i];
		return null;
	},
	&#x2F;** @return -1 if the bone was not found. *&#x2F;
	findBoneIndex: function (boneName) {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i &lt; n; i++)
			if (bones[i].name == boneName) return i;
		return -1;
	},
	&#x2F;** @return May be null. *&#x2F;
	findSlot: function (slotName) {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i &lt; n; i++) {
			if (slots[i].name == slotName) return slot[i];
		}
		return null;
	},
	&#x2F;** @return -1 if the bone was not found. *&#x2F;
	findSlotIndex: function (slotName) {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i &lt; n; i++)
			if (slots[i].name == slotName) return i;
		return -1;
	},
	&#x2F;** @return May be null. *&#x2F;
	findSkin: function (skinName) {
		var skins = this.skins;
		for (var i = 0, n = skins.length; i &lt; n; i++)
			if (skins[i].name == skinName) return skins[i];
		return null;
	},
	&#x2F;** @return May be null. *&#x2F;
	findEvent: function (eventName) {
		var events = this.events;
		for (var i = 0, n = events.length; i &lt; n; i++)
			if (events[i].name == eventName) return events[i];
		return null;
	},
	&#x2F;** @return May be null. *&#x2F;
	findAnimation: function (animationName) {
		var animations = this.animations;
		for (var i = 0, n = animations.length; i &lt; n; i++)
			if (animations[i].name == animationName) return animations[i];
		return null;
	}
};

spine.Skeleton = function (skeletonData) {
	this.data = skeletonData;

	this.bones = [];
	for (var i = 0, n = skeletonData.bones.length; i &lt; n; i++) {
		var boneData = skeletonData.bones[i];
		var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];
		this.bones.push(new spine.Bone(boneData, parent));
	}

	this.slots = [];
	this.drawOrder = [];
	for (var i = 0, n = skeletonData.slots.length; i &lt; n; i++) {
		var slotData = skeletonData.slots[i];
		var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];
		var slot = new spine.Slot(slotData, this, bone);
		this.slots.push(slot);
		this.drawOrder.push(slot);
	}
};
spine.Skeleton.prototype = {
	x: 0, y: 0,
	skin: null,
	r: 1, g: 1, b: 1, a: 1,
	time: 0,
	flipX: false, flipY: false,
	&#x2F;** Updates the world transform for each bone. *&#x2F;
	updateWorldTransform: function () {
		var flipX = this.flipX;
		var flipY = this.flipY;
		var bones = this.bones;
		for (var i = 0, n = bones.length; i &lt; n; i++)
			bones[i].updateWorldTransform(flipX, flipY);
	},
	&#x2F;** Sets the bones and slots to their setup pose values. *&#x2F;
	setToSetupPose: function () {
		this.setBonesToSetupPose();
		this.setSlotsToSetupPose();
	},
	setBonesToSetupPose: function () {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i &lt; n; i++)
			bones[i].setToSetupPose();
	},
	setSlotsToSetupPose: function () {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i &lt; n; i++)
			slots[i].setToSetupPose(i);
	},
	&#x2F;** @return May return null. *&#x2F;
	getRootBone: function () {
		return this.bones.length == 0 ? null : this.bones[0];
	},
	&#x2F;** @return May be null. *&#x2F;
	findBone: function (boneName) {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i &lt; n; i++)
			if (bones[i].data.name == boneName) return bones[i];
		return null;
	},
	&#x2F;** @return -1 if the bone was not found. *&#x2F;
	findBoneIndex: function (boneName) {
		var bones = this.bones;
		for (var i = 0, n = bones.length; i &lt; n; i++)
			if (bones[i].data.name == boneName) return i;
		return -1;
	},
	&#x2F;** @return May be null. *&#x2F;
	findSlot: function (slotName) {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i &lt; n; i++)
			if (slots[i].data.name == slotName) return slots[i];
		return null;
	},
	&#x2F;** @return -1 if the bone was not found. *&#x2F;
	findSlotIndex: function (slotName) {
		var slots = this.slots;
		for (var i = 0, n = slots.length; i &lt; n; i++)
			if (slots[i].data.name == slotName) return i;
		return -1;
	},
	setSkinByName: function (skinName) {
		var skin = this.data.findSkin(skinName);
		if (!skin) throw &quot;Skin not found: &quot; + skinName;
		this.setSkin(skin);
	},
	&#x2F;** Sets the skin used to look up attachments not found in the {@link SkeletonData#getDefaultSkin() default skin}. Attachments
	 * from the new skin are attached if the corresponding attachment from the old skin was attached.
	 * @param newSkin May be null. *&#x2F;
	setSkin: function (newSkin) {
		if (this.skin &amp;&amp; newSkin) newSkin._attachAll(this, this.skin);
		this.skin = newSkin;
	},
	&#x2F;** @return May be null. *&#x2F;
	getAttachmentBySlotName: function (slotName, attachmentName) {
		return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);
	},
	&#x2F;** @return May be null. *&#x2F;
	getAttachmentBySlotIndex: function (slotIndex, attachmentName) {
		if (this.skin) {
			var attachment = this.skin.getAttachment(slotIndex, attachmentName);
			if (attachment) return attachment;
		}
		if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
		return null;
	},
	&#x2F;** @param attachmentName May be null. *&#x2F;
	setAttachment: function (slotName, attachmentName) {
		var slots = this.slots;
		for (var i = 0, n = slots.size; i &lt; n; i++) {
			var slot = slots[i];
			if (slot.data.name == slotName) {
				var attachment = null;
				if (attachmentName) {
					attachment = this.getAttachment(i, attachmentName);
					if (!attachment) throw &quot;Attachment not found: &quot; + attachmentName + &quot;, for slot: &quot; + slotName;
				}
				slot.setAttachment(attachment);
				return;
			}
		}
		throw &quot;Slot not found: &quot; + slotName;
	},
	update: function (delta) {
		time += delta;
	}
};

spine.EventData = function (name) {
	this.name = name;
}
spine.EventData.prototype = {
	intValue: 0,
	floatValue: 0,
	stringValue: null
};

spine.Event = function (data) {
	this.data = data;
}
spine.Event.prototype = {
	intValue: 0,
	floatValue: 0,
	stringValue: null
};

spine.AttachmentType = {
	region: 0,
	boundingbox: 1
};

spine.RegionAttachment = function (name) {
	this.name = name;
	this.offset = [];
	this.offset.length = 8;
	this.uvs = [];
	this.uvs.length = 8;
};
spine.RegionAttachment.prototype = {
	type: spine.AttachmentType.region,
	x: 0, y: 0,
	rotation: 0,
	scaleX: 1, scaleY: 1,
	width: 0, height: 0,
	rendererObject: null,
	regionOffsetX: 0, regionOffsetY: 0,
	regionWidth: 0, regionHeight: 0,
	regionOriginalWidth: 0, regionOriginalHeight: 0,
	setUVs: function (u, v, u2, v2, rotate) {
		var uvs = this.uvs;
		if (rotate) {
			uvs[2&#x2F;*X2*&#x2F;] = u;
			uvs[3&#x2F;*Y2*&#x2F;] = v2;
			uvs[4&#x2F;*X3*&#x2F;] = u;
			uvs[5&#x2F;*Y3*&#x2F;] = v;
			uvs[6&#x2F;*X4*&#x2F;] = u2;
			uvs[7&#x2F;*Y4*&#x2F;] = v;
			uvs[0&#x2F;*X1*&#x2F;] = u2;
			uvs[1&#x2F;*Y1*&#x2F;] = v2;
		} else {
			uvs[0&#x2F;*X1*&#x2F;] = u;
			uvs[1&#x2F;*Y1*&#x2F;] = v2;
			uvs[2&#x2F;*X2*&#x2F;] = u;
			uvs[3&#x2F;*Y2*&#x2F;] = v;
			uvs[4&#x2F;*X3*&#x2F;] = u2;
			uvs[5&#x2F;*Y3*&#x2F;] = v;
			uvs[6&#x2F;*X4*&#x2F;] = u2;
			uvs[7&#x2F;*Y4*&#x2F;] = v2;
		}
	},
	updateOffset: function () {
		var regionScaleX = this.width &#x2F; this.regionOriginalWidth * this.scaleX;
		var regionScaleY = this.height &#x2F; this.regionOriginalHeight * this.scaleY;
		var localX = -this.width &#x2F; 2 * this.scaleX + this.regionOffsetX * regionScaleX;
		var localY = -this.height &#x2F; 2 * this.scaleY + this.regionOffsetY * regionScaleY;
		var localX2 = localX + this.regionWidth * regionScaleX;
		var localY2 = localY + this.regionHeight * regionScaleY;
		var radians = this.rotation * Math.PI &#x2F; 180;
		var cos = Math.cos(radians);
		var sin = Math.sin(radians);
		var localXCos = localX * cos + this.x;
		var localXSin = localX * sin;
		var localYCos = localY * cos + this.y;
		var localYSin = localY * sin;
		var localX2Cos = localX2 * cos + this.x;
		var localX2Sin = localX2 * sin;
		var localY2Cos = localY2 * cos + this.y;
		var localY2Sin = localY2 * sin;
		var offset = this.offset;
		offset[0&#x2F;*X1*&#x2F;] = localXCos - localYSin;
		offset[1&#x2F;*Y1*&#x2F;] = localYCos + localXSin;
		offset[2&#x2F;*X2*&#x2F;] = localXCos - localY2Sin;
		offset[3&#x2F;*Y2*&#x2F;] = localY2Cos + localXSin;
		offset[4&#x2F;*X3*&#x2F;] = localX2Cos - localY2Sin;
		offset[5&#x2F;*Y3*&#x2F;] = localY2Cos + localX2Sin;
		offset[6&#x2F;*X4*&#x2F;] = localX2Cos - localYSin;
		offset[7&#x2F;*Y4*&#x2F;] = localYCos + localX2Sin;
	},
	computeVertices: function (x, y, bone, vertices) {
		x += bone.worldX;
		y += bone.worldY;
		var m00 = bone.m00;
		var m01 = bone.m01;
		var m10 = bone.m10;
		var m11 = bone.m11;
		var offset = this.offset;
		vertices[0&#x2F;*X1*&#x2F;] = offset[0&#x2F;*X1*&#x2F;] * m00 + offset[1&#x2F;*Y1*&#x2F;] * m01 + x;
		vertices[1&#x2F;*Y1*&#x2F;] = offset[0&#x2F;*X1*&#x2F;] * m10 + offset[1&#x2F;*Y1*&#x2F;] * m11 + y;
		vertices[2&#x2F;*X2*&#x2F;] = offset[2&#x2F;*X2*&#x2F;] * m00 + offset[3&#x2F;*Y2*&#x2F;] * m01 + x;
		vertices[3&#x2F;*Y2*&#x2F;] = offset[2&#x2F;*X2*&#x2F;] * m10 + offset[3&#x2F;*Y2*&#x2F;] * m11 + y;
		vertices[4&#x2F;*X3*&#x2F;] = offset[4&#x2F;*X3*&#x2F;] * m00 + offset[5&#x2F;*X3*&#x2F;] * m01 + x;
		vertices[5&#x2F;*X3*&#x2F;] = offset[4&#x2F;*X3*&#x2F;] * m10 + offset[5&#x2F;*X3*&#x2F;] * m11 + y;
		vertices[6&#x2F;*X4*&#x2F;] = offset[6&#x2F;*X4*&#x2F;] * m00 + offset[7&#x2F;*Y4*&#x2F;] * m01 + x;
		vertices[7&#x2F;*Y4*&#x2F;] = offset[6&#x2F;*X4*&#x2F;] * m10 + offset[7&#x2F;*Y4*&#x2F;] * m11 + y;
	}
};

spine.BoundingBoxAttachment = function (name) {
	this.name = name;
	this.vertices = [];
};
spine.BoundingBoxAttachment.prototype = {
	type: spine.AttachmentType.boundingBox,
	computeWorldVertices: function (x, y, bone, worldVertices) {
		x += bone.worldX;
		y += bone.worldY;
		var m00 = bone.m00;
		var m01 = bone.m01;
		var m10 = bone.m10;
		var m11 = bone.m11;
		var vertices = this.vertices;
		for (var i = 0, n = vertices.length; i &lt; n; i += 2) {
			var px = vertices[i];
			var py = vertices[i + 1];
			worldVertices[i] = px * m00 + py * m01 + x;
			worldVertices[i + 1] = px * m10 + py * m11 + y;
		}
	}
};

spine.AnimationStateData = function (skeletonData) {
	this.skeletonData = skeletonData;
	this.animationToMixTime = {};
};
spine.AnimationStateData.prototype = {
	defaultMix: 0,
	setMixByName: function (fromName, toName, duration) {
		var from = this.skeletonData.findAnimation(fromName);
		if (!from) throw &quot;Animation not found: &quot; + fromName;
		var to = this.skeletonData.findAnimation(toName);
		if (!to) throw &quot;Animation not found: &quot; + toName;
		this.setMix(from, to, duration);
	},
	setMix: function (from, to, duration) {
		this.animationToMixTime[from.name + &quot;:&quot; + to.name] = duration;
	},
	getMix: function (from, to) {
		var time = this.animationToMixTime[from.name + &quot;:&quot; + to.name];
		return time ? time : this.defaultMix;
	}
};

spine.TrackEntry = function () {};
spine.TrackEntry.prototype = {
	next: null, previous: null,
	animation: null,
	loop: false,
	delay: 0, time: 0, lastTime: -1, endTime: 0,
	timeScale: 1,
	mixTime: 0, mixDuration: 0,
	onStart: null, onEnd: null, onComplete: null, onEvent: null
}

spine.AnimationState = function (stateData) {
	this.data = stateData;
	this.tracks = [];
	this.events = [];
};
spine.AnimationState.prototype = {
	onStart: null,
	onEnd: null,
	onComplete: null,
	onEvent: null,
	timeScale: 1,
	update: function (delta) {
		delta *= this.timeScale;
		for (var i = 0; i &lt; this.tracks.length; i++) {
			var current = this.tracks[i];
			if (!current) continue;

			var trackDelta = delta * current.timeScale;
			current.time += trackDelta;
			if (current.previous) {
				current.previous.time += trackDelta;
				current.mixTime += trackDelta;
			}

			var next = current.next;
			if (next) {
				if (current.lastTime &gt;= next.delay) this.setCurrent(i, next);
			} else {
				&#x2F;&#x2F; End non-looping animation when it reaches its end time and there is no next entry.
				if (!current.loop &amp;&amp; current.lastTime &gt;= current.endTime) this.clearTrack(i);
			}
		}
	},
	apply: function (skeleton) {
		for (var i = 0; i &lt; this.tracks.length; i++) {
			var current = this.tracks[i];
			if (!current) continue;

			this.events.length = 0;

			var time = current.time;
			var lastTime = current.lastTime;
			var endTime = current.endTime;
			var loop = current.loop;
			if (!loop &amp;&amp; time &gt; endTime) time = endTime;

			var previous = current.previous;
			if (!previous)
				current.animation.apply(skeleton, current.lastTime, time, loop, this.events);
			else {
				var previousTime = previous.time;
				if (!previous.loop &amp;&amp; previousTime &gt; previous.endTime) previousTime = previous.endTime;
				previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);

				var alpha = current.mixTime &#x2F; current.mixDuration;
				if (alpha &gt;= 1) {
					alpha = 1;
					current.previous = null;
				}
				current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);
			}

			for (var ii = 0, nn = this.events.length; ii &lt; nn; ii++) {
				var event = this.events[ii];
				if (current.onEvent != null) current.onEvent(i, event);
				if (this.onEvent != null) this.onEvent(i, event);
			}

			&#x2F;&#x2F; Check if completed the animation or a loop iteration.
			if (loop ? (lastTime % endTime &gt; time % endTime) : (lastTime &lt; endTime &amp;&amp; time &gt;= endTime)) {
				var count = Math.floor(time &#x2F; endTime);
				if (current.onComplete) current.onComplete(i, count);
				if (this.onComplete) this.onComplete(i, count);
			}

			current.lastTime = current.time;
		}
	},
	clearTracks: function () {
		for (var i = 0, n = this.tracks.length; i &lt; n; i++)
			this.clearTrack(i);
		this.tracks.length = 0; 
	},
	clearTrack: function (trackIndex) {
		if (trackIndex &gt;= this.tracks.length) return;
		var current = this.tracks[trackIndex];
		if (!current) return;

		if (current.onEnd != null) current.onEnd(trackIndex);
		if (this.onEnd != null) this.onEnd(trackIndex);

		this.tracks[trackIndex] = null;
	},
	_expandToIndex: function (index) {
		if (index &lt; this.tracks.length) return this.tracks[index];
		while (index &gt;= this.tracks.length)
			this.tracks.push(null);
		return null;
	},
	setCurrent: function (index, entry) {
		var current = this._expandToIndex(index);
		if (current) {
			current.previous = null;

			if (current.onEnd != null) current.onEnd(index);
			if (this.onEnd != null) this.onEnd(index);

			entry.mixDuration = this.data.getMix(current.animation, entry.animation);
			if (entry.mixDuration &gt; 0) {
				entry.mixTime = 0;
				entry.previous = current;
			}
		}

		this.tracks[index] = entry;

		if (entry.onStart != null) entry.onStart(index);
		if (this.onStart != null) this.onStart(index);
	},
	setAnimationByName: function (trackIndex, animationName, loop) {
		var animation = this.data.skeletonData.findAnimation(animationName);
		if (!animation) throw &quot;Animation not found: &quot; + animationName;
		return this.setAnimation(trackIndex, animation, loop);
	},
	&#x2F;** Set the current animation. Any queued animations are cleared. *&#x2F;
	setAnimation: function (trackIndex, animation, loop) {
		var entry = new spine.TrackEntry();
		entry.animation = animation;
		entry.loop = loop;
		entry.endTime = animation.duration;
		this.setCurrent(trackIndex, entry);
		return entry;
	},
	addAnimationByName: function (trackIndex, animationName, loop, delay) {
		var animation = this.data.skeletonData.findAnimation(animationName);
		if (!animation) throw &quot;Animation not found: &quot; + animationName;
		return this.addAnimation(trackIndex, animation, loop, delay);
	},
	&#x2F;** Adds an animation to be played delay seconds after the current or last queued animation.
	 * @param delay May be &lt;= 0 to use duration of previous animation minus any mix duration plus the negative delay. *&#x2F;
	addAnimation: function (trackIndex, animation, loop, delay) {
		var entry = new spine.TrackEntry();
		entry.animation = animation;
		entry.loop = loop;
		entry.endTime = animation.duration;

		var last = this._expandToIndex(trackIndex);
		if (last) {
			while (last.next)
				last = last.next;
			last.next = entry;
		} else
			this.tracks[trackIndex] = entry;

		if (delay &lt;= 0) {
			if (last)
				delay += last.endTime - this.data.getMix(last.animation, animation);
			else
				delay = 0;
		}
		entry.delay = delay;

		return entry;
	},
	&#x2F;** May be null. *&#x2F;
	getCurrent: function (trackIndex) {
		if (trackIndex &gt;= this.tracks.length) return null;
		return this.tracks[trackIndex];
	}
};

spine.SkeletonJson = function (attachmentLoader) {
	this.attachmentLoader = attachmentLoader;
};
spine.SkeletonJson.prototype = {
	scale: 1,
	readSkeletonData: function (root) {
		var skeletonData = new spine.SkeletonData();

		&#x2F;&#x2F; Bones.
		var bones = root[&quot;bones&quot;];
		for (var i = 0, n = bones.length; i &lt; n; i++) {
			var boneMap = bones[i];
			var parent = null;
			if (boneMap[&quot;parent&quot;]) {
				parent = skeletonData.findBone(boneMap[&quot;parent&quot;]);
				if (!parent) throw &quot;Parent bone not found: &quot; + boneMap[&quot;parent&quot;];
			}
			var boneData = new spine.BoneData(boneMap[&quot;name&quot;], parent);
			boneData.length = (boneMap[&quot;length&quot;] || 0) * this.scale;
			boneData.x = (boneMap[&quot;x&quot;] || 0) * this.scale;
			boneData.y = (boneMap[&quot;y&quot;] || 0) * this.scale;
			boneData.rotation = (boneMap[&quot;rotation&quot;] || 0);
			boneData.scaleX = boneMap[&quot;scaleX&quot;] || 1;
			boneData.scaleY = boneMap[&quot;scaleY&quot;] || 1;
			boneData.inheritScale = boneMap[&quot;inheritScale&quot;] || true;
			boneData.inheritRotation = boneMap[&quot;inheritRotation&quot;] || true;
			skeletonData.bones.push(boneData);
		}

		&#x2F;&#x2F; Slots.
		var slots = root[&quot;slots&quot;];
		for (var i = 0, n = slots.length; i &lt; n; i++) {
			var slotMap = slots[i];
			var boneData = skeletonData.findBone(slotMap[&quot;bone&quot;]);
			if (!boneData) throw &quot;Slot bone not found: &quot; + slotMap[&quot;bone&quot;];
			var slotData = new spine.SlotData(slotMap[&quot;name&quot;], boneData);

			var color = slotMap[&quot;color&quot;];
			if (color) {
				slotData.r = spine.SkeletonJson.toColor(color, 0);
				slotData.g = spine.SkeletonJson.toColor(color, 1);
				slotData.b = spine.SkeletonJson.toColor(color, 2);
				slotData.a = spine.SkeletonJson.toColor(color, 3);
			}

			slotData.attachmentName = slotMap[&quot;attachment&quot;];
			slotData.additiveBlending = slotMap[&quot;additive&quot;];

			skeletonData.slots.push(slotData);
		}

		&#x2F;&#x2F; Skins.
		var skins = root[&quot;skins&quot;];
		for (var skinName in skins) {
			if (!skins.hasOwnProperty(skinName)) continue;
			var skinMap = skins[skinName];
			var skin = new spine.Skin(skinName);
			for (var slotName in skinMap) {
				if (!skinMap.hasOwnProperty(slotName)) continue;
				var slotIndex = skeletonData.findSlotIndex(slotName);
				var slotEntry = skinMap[slotName];
				for (var attachmentName in slotEntry) {
					if (!slotEntry.hasOwnProperty(attachmentName)) continue;
					var attachment = this.readAttachment(skin, attachmentName, slotEntry[attachmentName]);
					if (attachment != null) skin.addAttachment(slotIndex, attachmentName, attachment);
				}
			}
			skeletonData.skins.push(skin);
			if (skin.name == &quot;default&quot;) skeletonData.defaultSkin = skin;
		}

		&#x2F;&#x2F; Events.
		var events = root[&quot;events&quot;];
		for (var eventName in events) {
			if (!events.hasOwnProperty(eventName)) continue;
			var eventMap = events[eventName];
			var eventData = new spine.EventData(eventName);
			eventData.intValue = eventMap[&quot;int&quot;] || 0;
			eventData.floatValue = eventMap[&quot;float&quot;] || 0;
			eventData.stringValue = eventMap[&quot;string&quot;] || null;
			skeletonData.events.push(eventData);
		}

		&#x2F;&#x2F; Animations.
		var animations = root[&quot;animations&quot;];
		for (var animationName in animations) {
			if (!animations.hasOwnProperty(animationName)) continue;
			this.readAnimation(animationName, animations[animationName], skeletonData);
		}

		return skeletonData;
	},
	readAttachment: function (skin, name, map) {
		name = map[&quot;name&quot;] || name;

		var type = spine.AttachmentType[map[&quot;type&quot;] || &quot;region&quot;];
		var attachment = this.attachmentLoader.newAttachment(skin, type, name);

		if (type == spine.AttachmentType.region) {
			attachment.x = (map[&quot;x&quot;] || 0) * this.scale;
			attachment.y = (map[&quot;y&quot;] || 0) * this.scale;
			attachment.scaleX = map[&quot;scaleX&quot;] || 1;
			attachment.scaleY = map[&quot;scaleY&quot;] || 1;
			attachment.rotation = map[&quot;rotation&quot;] || 0;
			attachment.width = (map[&quot;width&quot;] || 32) * this.scale;
			attachment.height = (map[&quot;height&quot;] || 32) * this.scale;
			attachment.updateOffset();
		} else if (type == spine.AttachmentType.boundingBox) {
			var vertices = map[&quot;vertices&quot;];
			for (var i = 0, n = vertices.length; i &lt; n; i++)
				attachment.vertices.push(vertices[i] * scale);
		}

		return attachment;
	},
	readAnimation: function (name, map, skeletonData) {
		var timelines = [];
		var duration = 0;

		var bones = map[&quot;bones&quot;];
		for (var boneName in bones) {
			if (!bones.hasOwnProperty(boneName)) continue;
			var boneIndex = skeletonData.findBoneIndex(boneName);
			if (boneIndex == -1) throw &quot;Bone not found: &quot; + boneName;
			var boneMap = bones[boneName];

			for (var timelineName in boneMap) {
				if (!boneMap.hasOwnProperty(timelineName)) continue;
				var values = boneMap[timelineName];
				if (timelineName == &quot;rotate&quot;) {
					var timeline = new spine.RotateTimeline(values.length);
					timeline.boneIndex = boneIndex;

					var frameIndex = 0;
					for (var i = 0, n = values.length; i &lt; n; i++) {
						var valueMap = values[i];
						timeline.setFrame(frameIndex, valueMap[&quot;time&quot;], valueMap[&quot;angle&quot;]);
						spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);

				} else if (timelineName == &quot;translate&quot; || timelineName == &quot;scale&quot;) {
					var timeline;
					var timelineScale = 1;
					if (timelineName == &quot;scale&quot;)
						timeline = new spine.ScaleTimeline(values.length);
					else {
						timeline = new spine.TranslateTimeline(values.length);
						timelineScale = this.scale;
					}
					timeline.boneIndex = boneIndex;

					var frameIndex = 0;
					for (var i = 0, n = values.length; i &lt; n; i++) {
						var valueMap = values[i];
						var x = (valueMap[&quot;x&quot;] || 0) * timelineScale;
						var y = (valueMap[&quot;y&quot;] || 0) * timelineScale;
						timeline.setFrame(frameIndex, valueMap[&quot;time&quot;], x, y);
						spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);

				} else
					throw &quot;Invalid timeline type for a bone: &quot; + timelineName + &quot; (&quot; + boneName + &quot;)&quot;;
			}
		}

		var slots = map[&quot;slots&quot;];
		for (var slotName in slots) {
			if (!slots.hasOwnProperty(slotName)) continue;
			var slotMap = slots[slotName];
			var slotIndex = skeletonData.findSlotIndex(slotName);

			for (var timelineName in slotMap) {
				if (!slotMap.hasOwnProperty(timelineName)) continue;
				var values = slotMap[timelineName];
				if (timelineName == &quot;color&quot;) {
					var timeline = new spine.ColorTimeline(values.length);
					timeline.slotIndex = slotIndex;

					var frameIndex = 0;
					for (var i = 0, n = values.length; i &lt; n; i++) {
						var valueMap = values[i];
						var color = valueMap[&quot;color&quot;];
						var r = spine.SkeletonJson.toColor(color, 0);
						var g = spine.SkeletonJson.toColor(color, 1);
						var b = spine.SkeletonJson.toColor(color, 2);
						var a = spine.SkeletonJson.toColor(color, 3);
						timeline.setFrame(frameIndex, valueMap[&quot;time&quot;], r, g, b, a);
						spine.SkeletonJson.readCurve(timeline, frameIndex, valueMap);
						frameIndex++;
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);

				} else if (timelineName == &quot;attachment&quot;) {
					var timeline = new spine.AttachmentTimeline(values.length);
					timeline.slotIndex = slotIndex;

					var frameIndex = 0;
					for (var i = 0, n = values.length; i &lt; n; i++) {
						var valueMap = values[i];
						timeline.setFrame(frameIndex++, valueMap[&quot;time&quot;], valueMap[&quot;name&quot;]);
					}
					timelines.push(timeline);
					duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);

				} else
					throw &quot;Invalid timeline type for a slot: &quot; + timelineName + &quot; (&quot; + slotName + &quot;)&quot;;
			}
		}

		var events = map[&quot;events&quot;];
		if (events) {
			var timeline = new spine.EventTimeline(events.length);
			var frameIndex = 0;
			for (var i = 0, n = events.length; i &lt; n; i++) {
				var eventMap = events[i];
				var eventData = skeletonData.findEvent(eventMap[&quot;name&quot;]);
				if (!eventData) throw &quot;Event not found: &quot; + eventMap[&quot;name&quot;];
				var event = new spine.Event(eventData);
				event.intValue = eventMap.hasOwnProperty(&quot;int&quot;) ? eventMap[&quot;int&quot;] : eventData.intValue;
				event.floatValue = eventMap.hasOwnProperty(&quot;float&quot;) ? eventMap[&quot;float&quot;] : eventData.floatValue;
				event.stringValue = eventMap.hasOwnProperty(&quot;string&quot;) ? eventMap[&quot;string&quot;] : eventData.stringValue;
				timeline.setFrame(frameIndex++, eventMap[&quot;time&quot;], event);
			}
			timelines.push(timeline);
			duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
		}

		var drawOrderValues = map[&quot;draworder&quot;];
		if (drawOrderValues) {
			var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);
			var slotCount = skeletonData.slots.length;
			var frameIndex = 0;
			for (var i = 0, n = drawOrderValues.length; i &lt; n; i++) {
				var drawOrderMap = drawOrderValues[i];
				var drawOrder = null;
				if (drawOrderMap[&quot;offsets&quot;]) {
					drawOrder = [];
					drawOrder.length = slotCount;
					for (var ii = slotCount - 1; ii &gt;= 0; ii--)
						drawOrder[ii] = -1;
					var offsets = drawOrderMap[&quot;offsets&quot;];
					var unchanged = [];
					unchanged.length = slotCount - offsets.length;
					var originalIndex = 0, unchangedIndex = 0;
					for (var ii = 0, nn = offsets.length; ii &lt; nn; ii++) {
						var offsetMap = offsets[ii];
						var slotIndex = skeletonData.findSlotIndex(offsetMap[&quot;slot&quot;]);
						if (slotIndex == -1) throw &quot;Slot not found: &quot; + offsetMap[&quot;slot&quot;];
						&#x2F;&#x2F; Collect unchanged items.
						while (originalIndex != slotIndex)
							unchanged[unchangedIndex++] = originalIndex++;
						&#x2F;&#x2F; Set changed items.
						drawOrder[originalIndex + offsetMap[&quot;offset&quot;]] = originalIndex++;
					}
					&#x2F;&#x2F; Collect remaining unchanged items.
					while (originalIndex &lt; slotCount)
						unchanged[unchangedIndex++] = originalIndex++;
					&#x2F;&#x2F; Fill in unchanged items.
					for (var ii = slotCount - 1; ii &gt;= 0; ii--)
						if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];
				}
				timeline.setFrame(frameIndex++, drawOrderMap[&quot;time&quot;], drawOrder);
			}
			timelines.push(timeline);
			duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
		}

		skeletonData.animations.push(new spine.Animation(name, timelines, duration));
	}
};
spine.SkeletonJson.readCurve = function (timeline, frameIndex, valueMap) {
	var curve = valueMap[&quot;curve&quot;];
	if (!curve) return;
	if (curve == &quot;stepped&quot;)
		timeline.curves.setStepped(frameIndex);
	else if (curve instanceof Array)
		timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
};
spine.SkeletonJson.toColor = function (hexString, colorIndex) {
	if (hexString.length != 8) throw &quot;Color hexidecimal length must be 8, recieved: &quot; + hexString;
	return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) &#x2F; 255;
};

spine.Atlas = function (atlasText, textureLoader) {
	this.textureLoader = textureLoader;
	this.pages = [];
	this.regions = [];

	var reader = new spine.AtlasReader(atlasText);
	var tuple = [];
	tuple.length = 4;
	var page = null;
	while (true) {
		var line = reader.readLine();
		if (line == null) break;
		line = reader.trim(line);
		if (line.length == 0)
			page = null;
		else if (!page) {
			page = new spine.AtlasPage();
			page.name = line;

			page.format = spine.Atlas.Format[reader.readValue()];

			reader.readTuple(tuple);
			page.minFilter = spine.Atlas.TextureFilter[tuple[0]];
			page.magFilter = spine.Atlas.TextureFilter[tuple[1]];

			var direction = reader.readValue();
			page.uWrap = spine.Atlas.TextureWrap.clampToEdge;
			page.vWrap = spine.Atlas.TextureWrap.clampToEdge;
			if (direction == &quot;x&quot;)
				page.uWrap = spine.Atlas.TextureWrap.repeat;
			else if (direction == &quot;y&quot;)
				page.vWrap = spine.Atlas.TextureWrap.repeat;
			else if (direction == &quot;xy&quot;)
				page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;

			textureLoader.load(page, line);

			this.pages.push(page);

		} else {
			var region = new spine.AtlasRegion();
			region.name = line;
			region.page = page;

			region.rotate = reader.readValue() == &quot;true&quot;;

			reader.readTuple(tuple);
			var x = parseInt(tuple[0]);
			var y = parseInt(tuple[1]);

			reader.readTuple(tuple);
			var width = parseInt(tuple[0]);
			var height = parseInt(tuple[1]);

			region.u = x &#x2F; page.width;
			region.v = y &#x2F; page.height;
			if (region.rotate) {
				region.u2 = (x + height) &#x2F; page.width;
				region.v2 = (y + width) &#x2F; page.height;
			} else {
				region.u2 = (x + width) &#x2F; page.width;
				region.v2 = (y + height) &#x2F; page.height;
			}
			region.x = x;
			region.y = y;
			region.width = Math.abs(width);
			region.height = Math.abs(height);

			if (reader.readTuple(tuple) == 4) { &#x2F;&#x2F; split is optional
				region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];

				if (reader.readTuple(tuple) == 4) { &#x2F;&#x2F; pad is optional, but only present with splits
					region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];

					reader.readTuple(tuple);
				}
			}

			region.originalWidth = parseInt(tuple[0]);
			region.originalHeight = parseInt(tuple[1]);

			reader.readTuple(tuple);
			region.offsetX = parseInt(tuple[0]);
			region.offsetY = parseInt(tuple[1]);

			region.index = parseInt(reader.readValue());

			this.regions.push(region);
		}
	}
};
spine.Atlas.prototype = {
	findRegion: function (name) {
		var regions = this.regions;
		for (var i = 0, n = regions.length; i &lt; n; i++)
			if (regions[i].name == name) return regions[i];
		return null;
	},
	dispose: function () {
		var pages = this.pages;
		for (var i = 0, n = pages.length; i &lt; n; i++)
			this.textureLoader.unload(pages[i].rendererObject);
	},
	updateUVs: function (page) {
		var regions = this.regions;
		for (var i = 0, n = regions.length; i &lt; n; i++) {
			var region = regions[i];
			if (region.page != page) continue;
			region.u = region.x &#x2F; page.width;
			region.v = region.y &#x2F; page.height;
			if (region.rotate) {
				region.u2 = (region.x + region.height) &#x2F; page.width;
				region.v2 = (region.y + region.width) &#x2F; page.height;
			} else {
				region.u2 = (region.x + region.width) &#x2F; page.width;
				region.v2 = (region.y + region.height) &#x2F; page.height;
			}
		}
	}
};

spine.Atlas.Format = {
	alpha: 0,
	intensity: 1,
	luminanceAlpha: 2,
	rgb565: 3,
	rgba4444: 4,
	rgb888: 5,
	rgba8888: 6
};

spine.Atlas.TextureFilter = {
	nearest: 0,
	linear: 1,
	mipMap: 2,
	mipMapNearestNearest: 3,
	mipMapLinearNearest: 4,
	mipMapNearestLinear: 5,
	mipMapLinearLinear: 6
};

spine.Atlas.TextureWrap = {
	mirroredRepeat: 0,
	clampToEdge: 1,
	repeat: 2
};

spine.AtlasPage = function () {};
spine.AtlasPage.prototype = {
	name: null,
	format: null,
	minFilter: null,
	magFilter: null,
	uWrap: null,
	vWrap: null,
	rendererObject: null,
	width: 0,
	height: 0
};

spine.AtlasRegion = function () {};
spine.AtlasRegion.prototype = {
	page: null,
	name: null,
	x: 0, y: 0,
	width: 0, height: 0,
	u: 0, v: 0, u2: 0, v2: 0,
	offsetX: 0, offsetY: 0,
	originalWidth: 0, originalHeight: 0,
	index: 0,
	rotate: false,
	splits: null,
	pads: null,
};

spine.AtlasReader = function (text) {
	this.lines = text.split(&#x2F;\r\n|\r|\n&#x2F;);
};
spine.AtlasReader.prototype = {
	index: 0,
	trim: function (value) {
		return value.replace(&#x2F;^\s+|\s+$&#x2F;g, &quot;&quot;);
	},
	readLine: function () {
		if (this.index &gt;= this.lines.length) return null;
		return this.lines[this.index++];
	},
	readValue: function () {
		var line = this.readLine();
		var colon = line.indexOf(&quot;:&quot;);
		if (colon == -1) throw &quot;Invalid line: &quot; + line;
		return this.trim(line.substring(colon + 1));
	},
	&#x2F;** Returns the number of tuple values read (2 or 4). *&#x2F;
	readTuple: function (tuple) {
		var line = this.readLine();
		var colon = line.indexOf(&quot;:&quot;);
		if (colon == -1) throw &quot;Invalid line: &quot; + line;
		var i = 0, lastMatch= colon + 1;
		for (; i &lt; 3; i++) {
			var comma = line.indexOf(&quot;,&quot;, lastMatch);
			if (comma == -1) {
				if (i == 0) throw &quot;Invalid line: &quot; + line;
				break;
			}
			tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));
			lastMatch = comma + 1;
		}
		tuple[i] = this.trim(line.substring(lastMatch));
		return i + 1;
	}
};

spine.AtlasAttachmentLoader = function (atlas) {
	this.atlas = atlas;
};
spine.AtlasAttachmentLoader.prototype = {
	newAttachment: function (skin, type, name) {
		switch (type) {
		case spine.AttachmentType.boundingbox:
			return new spine.BoundingBoxAttachment(name);
		case spine.AttachmentType.region:
			var region = this.atlas.findRegion(name);
			if (!region) throw &quot;Region not found in atlas: &quot; + name + &quot; (&quot; + type + &quot;)&quot;;
			var attachment = new spine.RegionAttachment(name);
			attachment.rendererObject = region;
			attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);
			attachment.regionOffsetX = region.offsetX;
			attachment.regionOffsetY = region.offsetY;
			attachment.regionWidth = region.width;
			attachment.regionHeight = region.height;
			attachment.regionOriginalWidth = region.originalWidth;
			attachment.regionOriginalHeight = region.originalHeight;
			return attachment;
		}
		throw &quot;Unknown attachment type: &quot; + type;
	}
};

spine.SkeletonBounds = function () {
	this.polygonPool = [];
	this.polygons = [];
	this.boundingBoxes = [];
};
spine.SkeletonBounds.prototype = {
	minX: 0, minY: 0, maxX: 0, maxY: 0,
	update: function (skeleton, updateAabb) {
		var slots = skeleton.slots;
		var slotCount = slots.length;
		var x = skeleton.x, y = skeleton.y;
		var boundingBoxes = this.boundingBoxes;
		var polygonPool = this.polygonPool;
		var polygons = this.polygons;

		boundingBoxes.length = 0;
		for (var i = 0, n = polygons.length; i &lt; n; i++)
			polygonPool.push(polygons[i]);
		polygons.length = 0;

		for (var i = 0; i &lt; slotCount; i++) {
			var slot = slots[i];
			var boundingBox = slot.attachment;
			if (boundingBox.type != spine.AttachmentType.boundingBox) continue;
			boundingBoxes.push(boundingBox);

			var poolCount = polygonPool.length;
			if (poolCount &gt; 0) {
				polygon = polygonPool[poolCount - 1];
				polygonPool.splice(poolCount - 1, 1);
			} else
				polygon = [];
			polygons.push(polygon);

			polygon.length = boundingBox.vertices.length;
			boundingBox.computeWorldVertices(x, y, slot.bone, polygon);
		}

		if (updateAabb) this.aabbCompute();
	},
	aabbCompute: function () {
		var polygons = this.polygons;
		var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;
		for (var i = 0, n = polygons.length; i &lt; n; i++) {
			var vertices = polygons[i];
			for (var ii = 0, nn = vertices.length; ii &lt; nn; ii += 2) {
				var x = vertices[ii];
				var y = vertices[ii + 1];
				minX = Math.min(minX, x);
				minY = Math.min(minY, y);
				maxX = Math.max(maxX, x);
				maxY = Math.max(maxY, y);
			}
		}
		this.minX = minX;
		this.minY = minY;
		this.maxX = maxX;
		this.maxY = maxY;
	},
	&#x2F;** Returns true if the axis aligned bounding box contains the point. *&#x2F;
	aabbContainsPoint: function (x, y) {
		return x &gt;= this.minX &amp;&amp; x &lt;= this.maxX &amp;&amp; y &gt;= this.minY &amp;&amp; y &lt;= this.maxY;
	},
	&#x2F;** Returns true if the axis aligned bounding box intersects the line segment. *&#x2F;
	aabbIntersectsSegment: function (x1, y1, x2, y2) {
		var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
		if ((x1 &lt;= minX &amp;&amp; x2 &lt;= minX) || (y1 &lt;= minY &amp;&amp; y2 &lt;= minY) || (x1 &gt;= maxX &amp;&amp; x2 &gt;= maxX) || (y1 &gt;= maxY &amp;&amp; y2 &gt;= maxY))
			return false;
		var m = (y2 - y1) &#x2F; (x2 - x1);
		var y = m * (minX - x1) + y1;
		if (y &gt; minY &amp;&amp; y &lt; maxY) return true;
		y = m * (maxX - x1) + y1;
		if (y &gt; minY &amp;&amp; y &lt; maxY) return true;
		var x = (minY - y1) &#x2F; m + x1;
		if (x &gt; minX &amp;&amp; x &lt; maxX) return true;
		x = (maxY - y1) &#x2F; m + x1;
		if (x &gt; minX &amp;&amp; x &lt; maxX) return true;
		return false;
	},
	&#x2F;** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. *&#x2F;
	aabbIntersectsSkeleton: function (bounds) {
		return this.minX &lt; bounds.maxX &amp;&amp; this.maxX &gt; bounds.minX &amp;&amp; this.minY &lt; bounds.maxY &amp;&amp; this.maxY &gt; bounds.minY;
	},
	&#x2F;** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
	 * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. *&#x2F;
	containsPoint: function (x, y) {
		var polygons = this.polygons;
		for (var i = 0, n = polygons.length; i &lt; n; i++)
			if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];
		return null;
	},
	&#x2F;** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually
	 * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. *&#x2F;
	intersectsSegment: function (x1, y1, x2, y2) {
		var polygons = this.polygons;
		for (var i = 0, n = polygons.length; i &lt; n; i++)
			if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return boundingBoxes[i];
		return null;
	},
	&#x2F;** Returns true if the polygon contains the point. *&#x2F;
	polygonContainsPoint: function (polygon, x, y) {
		var nn = polygon.length;
		var prevIndex = nn - 2;
		var inside = false;
		for (var ii = 0; ii &lt; nn; ii += 2) {
			var vertexY = polygon[ii + 1];
			var prevY = polygon[prevIndex + 1];
			if ((vertexY &lt; y &amp;&amp; prevY &gt;= y) || (prevY &lt; y &amp;&amp; vertexY &gt;= y)) {
				var vertexX = polygon[ii];
				if (vertexX + (y - vertexY) &#x2F; (prevY - vertexY) * (polygon[prevIndex] - vertexX) &lt; x) inside = !inside;
			}
			prevIndex = ii;
		}
		return inside;
	},
	&#x2F;** Returns true if the polygon contains the line segment. *&#x2F;
	intersectsSegment: function (polygon, x1, y1, x2, y2) {
		var nn = polygon.length;
		var width12 = x1 - x2, height12 = y1 - y2;
		var det1 = x1 * y2 - y1 * x2;
		var x3 = polygon[nn - 2], y3 = polygon[nn - 1];
		for (var ii = 0; ii &lt; nn; ii += 2) {
			var x4 = polygon[ii], y4 = polygon[ii + 1];
			var det2 = x3 * y4 - y3 * x4;
			var width34 = x3 - x4, height34 = y3 - y4;
			var det3 = width12 * height34 - height12 * width34;
			var x = (det1 * width34 - width12 * det2) &#x2F; det3;
			if (((x &gt;= x3 &amp;&amp; x &lt;= x4) || (x &gt;= x4 &amp;&amp; x &lt;= x3)) &amp;&amp; ((x &gt;= x1 &amp;&amp; x &lt;= x2) || (x &gt;= x2 &amp;&amp; x &lt;= x1))) {
				var y = (det1 * height34 - height12 * det2) &#x2F; det3;
				if (((y &gt;= y3 &amp;&amp; y &lt;= y4) || (y &gt;= y4 &amp;&amp; y &lt;= y3)) &amp;&amp; ((y &gt;= y1 &amp;&amp; y &lt;= y2) || (y &gt;= y2 &amp;&amp; y &lt;= y1))) return true;
			}
			x3 = x4;
			y3 = y4;
		}
		return false;
	},
	getPolygon: function (attachment) {
		var index = this.boundingBoxes.indexOf(attachment);
		return index == -1 ? null : this.polygons[index];
	},
	getWidth: function () {
		return this.maxX - this.minX;
	},
	getHeight: function () {
		return this.maxY - this.minY;
	}
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
