<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>cangaja&#x2F;lib-ext&#x2F;hammer.js - Cangaja API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="Cangaja API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/CG.Animation.html">CG.Animation</a></li>
            
                <li><a href="..&#x2F;classes/CG.AtlasImage.html">CG.AtlasImage</a></li>
            
                <li><a href="..&#x2F;classes/CG.AtlasTexturePacker.html">CG.AtlasTexturePacker</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DBridge.html">CG.B2DBridge</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DChainShape.html">CG.B2DChainShape</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DCirlce.html">CG.B2DCirlce</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DEntity.html">CG.B2DEntity</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DLine.html">CG.B2DLine</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DPolygon.html">CG.B2DPolygon</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DRectangle.html">CG.B2DRectangle</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DRope.html">CG.B2DRope</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DWorld.html">CG.B2DWorld</a></li>
            
                <li><a href="..&#x2F;classes/CG.Bitmap.html">CG.Bitmap</a></li>
            
                <li><a href="..&#x2F;classes/CG.Bound.html">CG.Bound</a></li>
            
                <li><a href="..&#x2F;classes/CG.Buffer.html">CG.Buffer</a></li>
            
                <li><a href="..&#x2F;classes/CG.Button.html">CG.Button</a></li>
            
                <li><a href="..&#x2F;classes/CG.CanvasRenderer.html">CG.CanvasRenderer</a></li>
            
                <li><a href="..&#x2F;classes/CG.Delta.html">CG.Delta</a></li>
            
                <li><a href="..&#x2F;classes/CG.Director.html">CG.Director</a></li>
            
                <li><a href="..&#x2F;classes/CG.Emitter.html">CG.Emitter</a></li>
            
                <li><a href="..&#x2F;classes/CG.Entity.html">CG.Entity</a></li>
            
                <li><a href="..&#x2F;classes/CG.Font.html">CG.Font</a></li>
            
                <li><a href="..&#x2F;classes/CG.Layer.html">CG.Layer</a></li>
            
                <li><a href="..&#x2F;classes/CG.Map.html">CG.Map</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapArea.html">CG.MapArea</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapPoint.html">CG.MapPoint</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapTileLayer.html">CG.MapTileLayer</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapTileProperties.html">CG.MapTileProperties</a></li>
            
                <li><a href="..&#x2F;classes/CG.MediaAsset.html">CG.MediaAsset</a></li>
            
                <li><a href="..&#x2F;classes/CG.Menu.html">CG.Menu</a></li>
            
                <li><a href="..&#x2F;classes/CG.Morph.html">CG.Morph</a></li>
            
                <li><a href="..&#x2F;classes/CG.Particle.html">CG.Particle</a></li>
            
                <li><a href="..&#x2F;classes/CG.Point.html">CG.Point</a></li>
            
                <li><a href="..&#x2F;classes/CG.Rectangle.html">CG.Rectangle</a></li>
            
                <li><a href="..&#x2F;classes/CG.Screen.html">CG.Screen</a></li>
            
                <li><a href="..&#x2F;classes/CG.Sequence.html">CG.Sequence</a></li>
            
                <li><a href="..&#x2F;classes/CG.Sprite.html">CG.Sprite</a></li>
            
                <li><a href="..&#x2F;classes/CG.Text.html">CG.Text</a></li>
            
                <li><a href="..&#x2F;classes/CG.Translate.html">CG.Translate</a></li>
            
                <li><a href="..&#x2F;classes/CG.Vector.html">CG.Vector</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/CG.html">CG</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: cangaja&#x2F;lib-ext&#x2F;hammer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*! Hammer.JS - v1.0.5 - 2013-04-07
 * http:&#x2F;&#x2F;eightmedia.github.com&#x2F;hammer.js
 *
 * Copyright (c) 2013 Jorik Tangelder &lt;j.tangelder@gmail.com&gt;;
 * Licensed under the MIT license *&#x2F;

(function(window, undefined) {
    &#x27;use strict&#x27;;

&#x2F;**
 * Hammer
 * use this to create instances
 * @param   {HTMLElement}   element
 * @param   {Object}        options
 * @returns {Hammer.Instance}
 * @constructor
 *&#x2F;
var Hammer = function(element, options) {
    return new Hammer.Instance(element, options || {});
};

&#x2F;&#x2F; default settings
Hammer.defaults = {
    &#x2F;&#x2F; add styles and attributes to the element to prevent the browser from doing
    &#x2F;&#x2F; its native behavior. this doesnt prevent the scrolling, but cancels
    &#x2F;&#x2F; the contextmenu, tap highlighting etc
    &#x2F;&#x2F; set to false to disable this
    stop_browser_behavior: {
		&#x2F;&#x2F; this also triggers onselectstart=false for IE
        userSelect: &#x27;none&#x27;,
		&#x2F;&#x2F; this makes the element blocking in IE10 &gt;, you could experiment with the value
		&#x2F;&#x2F; see for more options this issue; https:&#x2F;&#x2F;github.com&#x2F;EightMedia&#x2F;hammer.js&#x2F;issues&#x2F;241
        touchAction: &#x27;none&#x27;,
		touchCallout: &#x27;none&#x27;,
        contentZooming: &#x27;none&#x27;,
        userDrag: &#x27;none&#x27;,
        tapHighlightColor: &#x27;rgba(0,0,0,0)&#x27;
    }

    &#x2F;&#x2F; more settings are defined per gesture at gestures.js
};

&#x2F;&#x2F; detect touchevents
Hammer.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;
Hammer.HAS_TOUCHEVENTS = (&#x27;ontouchstart&#x27; in window);

&#x2F;&#x2F; dont use mouseevents on mobile devices
Hammer.MOBILE_REGEX = &#x2F;mobile|tablet|ip(ad|hone|od)|android&#x2F;i;
Hammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS &amp;&amp; navigator.userAgent.match(Hammer.MOBILE_REGEX);

&#x2F;&#x2F; eventtypes per touchevent (start, move, end)
&#x2F;&#x2F; are filled by Hammer.event.determineEventTypes on setup
Hammer.EVENT_TYPES = {};

&#x2F;&#x2F; direction defines
Hammer.DIRECTION_DOWN = &#x27;down&#x27;;
Hammer.DIRECTION_LEFT = &#x27;left&#x27;;
Hammer.DIRECTION_UP = &#x27;up&#x27;;
Hammer.DIRECTION_RIGHT = &#x27;right&#x27;;

&#x2F;&#x2F; pointer type
Hammer.POINTER_MOUSE = &#x27;mouse&#x27;;
Hammer.POINTER_TOUCH = &#x27;touch&#x27;;
Hammer.POINTER_PEN = &#x27;pen&#x27;;

&#x2F;&#x2F; touch event defines
Hammer.EVENT_START = &#x27;start&#x27;;
Hammer.EVENT_MOVE = &#x27;move&#x27;;
Hammer.EVENT_END = &#x27;end&#x27;;

&#x2F;&#x2F; hammer document where the base events are added at
Hammer.DOCUMENT = document;

&#x2F;&#x2F; plugins namespace
Hammer.plugins = {};

&#x2F;&#x2F; if the window events are set...
Hammer.READY = false;

&#x2F;**
 * setup events to detect gestures on the document
 *&#x2F;
function setup() {
    if(Hammer.READY) {
        return;
    }

    &#x2F;&#x2F; find what eventtypes we add listeners to
    Hammer.event.determineEventTypes();

    &#x2F;&#x2F; Register all gestures inside Hammer.gestures
    for(var name in Hammer.gestures) {
        if(Hammer.gestures.hasOwnProperty(name)) {
            Hammer.detection.register(Hammer.gestures[name]);
        }
    }

    &#x2F;&#x2F; Add touch events on the document
    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_MOVE, Hammer.detection.detect);
    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_END, Hammer.detection.detect);

    &#x2F;&#x2F; Hammer is ready...!
    Hammer.READY = true;
}

&#x2F;**
 * create new hammer instance
 * all methods should return the instance itself, so it is chainable.
 * @param   {HTMLElement}       element
 * @param   {Object}            [options={}]
 * @returns {Hammer.Instance}
 * @constructor
 *&#x2F;
Hammer.Instance = function(element, options) {
    var self = this;

    &#x2F;&#x2F; setup HammerJS window events and register all gestures
    &#x2F;&#x2F; this also sets up the default options
    setup();

    this.element = element;

    &#x2F;&#x2F; start&#x2F;stop detection option
    this.enabled = true;

    &#x2F;&#x2F; merge options
    this.options = Hammer.utils.extend(
        Hammer.utils.extend({}, Hammer.defaults),
        options || {});

    &#x2F;&#x2F; add some css to the element to prevent the browser from doing its native behavoir
    if(this.options.stop_browser_behavior) {
        Hammer.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
    }

    &#x2F;&#x2F; start detection on touchstart
    Hammer.event.onTouch(element, Hammer.EVENT_START, function(ev) {
        if(self.enabled) {
            Hammer.detection.startDetect(self, ev);
        }
    });

    &#x2F;&#x2F; return instance
    return this;
};


Hammer.Instance.prototype = {
    &#x2F;**
     * bind events to the instance
     * @param   {String}      gesture
     * @param   {Function}    handler
     * @returns {Hammer.Instance}
     *&#x2F;
    on: function onEvent(gesture, handler){
        var gestures = gesture.split(&#x27; &#x27;);
        for(var t=0; t&lt;gestures.length; t++) {
            this.element.addEventListener(gestures[t], handler, false);
        }
        return this;
    },


    &#x2F;**
     * unbind events to the instance
     * @param   {String}      gesture
     * @param   {Function}    handler
     * @returns {Hammer.Instance}
     *&#x2F;
    off: function offEvent(gesture, handler){
        var gestures = gesture.split(&#x27; &#x27;);
        for(var t=0; t&lt;gestures.length; t++) {
            this.element.removeEventListener(gestures[t], handler, false);
        }
        return this;
    },


    &#x2F;**
     * trigger gesture event
     * @param   {String}      gesture
     * @param   {Object}      eventData
     * @returns {Hammer.Instance}
     *&#x2F;
    trigger: function triggerEvent(gesture, eventData){
        &#x2F;&#x2F; create DOM event
        var event = Hammer.DOCUMENT.createEvent(&#x27;Event&#x27;);
		event.initEvent(gesture, true, true);
		event.gesture = eventData;

        &#x2F;&#x2F; trigger on the target if it is in the instance element,
        &#x2F;&#x2F; this is for event delegation tricks
        var element = this.element;
        if(Hammer.utils.hasParent(eventData.target, element)) {
            element = eventData.target;
        }

        element.dispatchEvent(event);
        return this;
    },


    &#x2F;**
     * enable of disable hammer.js detection
     * @param   {Boolean}   state
     * @returns {Hammer.Instance}
     *&#x2F;
    enable: function enable(state) {
        this.enabled = state;
        return this;
    }
};

&#x2F;**
 * this holds the last move event,
 * used to fix empty touchend issue
 * see the onTouch event for an explanation
 * @type {Object}
 *&#x2F;
var last_move_event = null;


&#x2F;**
 * when the mouse is hold down, this is true
 * @type {Boolean}
 *&#x2F;
var enable_detect = false;


&#x2F;**
 * when touch events have been fired, this is true
 * @type {Boolean}
 *&#x2F;
var touch_triggered = false;


Hammer.event = {
    &#x2F;**
     * simple addEventListener
     * @param   {HTMLElement}   element
     * @param   {String}        type
     * @param   {Function}      handler
     *&#x2F;
    bindDom: function(element, type, handler) {
        var types = type.split(&#x27; &#x27;);
        for(var t=0; t&lt;types.length; t++) {
            element.addEventListener(types[t], handler, false);
        }
    },


    &#x2F;**
     * touch events with mouse fallback
     * @param   {HTMLElement}   element
     * @param   {String}        eventType        like Hammer.EVENT_MOVE
     * @param   {Function}      handler
     *&#x2F;
    onTouch: function onTouch(element, eventType, handler) {
		var self = this;

        this.bindDom(element, Hammer.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
            var sourceEventType = ev.type.toLowerCase();

            &#x2F;&#x2F; onmouseup, but when touchend has been fired we do nothing.
            &#x2F;&#x2F; this is for touchdevices which also fire a mouseup on touchend
            if(sourceEventType.match(&#x2F;mouse&#x2F;) &amp;&amp; touch_triggered) {
                return;
            }

            &#x2F;&#x2F; mousebutton must be down or a touch event
            else if( sourceEventType.match(&#x2F;touch&#x2F;) ||   &#x2F;&#x2F; touch events are always on screen
                sourceEventType.match(&#x2F;pointerdown&#x2F;) || &#x2F;&#x2F; pointerevents touch
                (sourceEventType.match(&#x2F;mouse&#x2F;) &amp;&amp; ev.which === 1)   &#x2F;&#x2F; mouse is pressed
            ){
                enable_detect = true;
            }

            &#x2F;&#x2F; we are in a touch event, set the touch triggered bool to true,
            &#x2F;&#x2F; this for the conflicts that may occur on ios and android
            if(sourceEventType.match(&#x2F;touch|pointer&#x2F;)) {
                touch_triggered = true;
            }

            &#x2F;&#x2F; count the total touches on the screen
            var count_touches = 0;

            &#x2F;&#x2F; when touch has been triggered in this detection session
            &#x2F;&#x2F; and we are now handling a mouse event, we stop that to prevent conflicts
            if(enable_detect) {
                &#x2F;&#x2F; update pointerevent
                if(Hammer.HAS_POINTEREVENTS &amp;&amp; eventType != Hammer.EVENT_END) {
                    count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
                }
                &#x2F;&#x2F; touch
                else if(sourceEventType.match(&#x2F;touch&#x2F;)) {
                    count_touches = ev.touches.length;
                }
                &#x2F;&#x2F; mouse
                else if(!touch_triggered) {
                    count_touches = sourceEventType.match(&#x2F;up&#x2F;) ? 0 : 1;
                }

                &#x2F;&#x2F; if we are in a end event, but when we remove one touch and
                &#x2F;&#x2F; we still have enough, set eventType to move
                if(count_touches &gt; 0 &amp;&amp; eventType == Hammer.EVENT_END) {
                    eventType = Hammer.EVENT_MOVE;
                }
                &#x2F;&#x2F; no touches, force the end event
                else if(!count_touches) {
                    eventType = Hammer.EVENT_END;
                }

                &#x2F;&#x2F; because touchend has no touches, and we often want to use these in our gestures,
                &#x2F;&#x2F; we send the last move event as our eventData in touchend
                if(!count_touches &amp;&amp; last_move_event !== null) {
                    ev = last_move_event;
                }
                &#x2F;&#x2F; store the last move event
                else {
                    last_move_event = ev;
                }

                &#x2F;&#x2F; trigger the handler
                handler.call(Hammer.detection, self.collectEventData(element, eventType, ev));

                &#x2F;&#x2F; remove pointerevent from list
                if(Hammer.HAS_POINTEREVENTS &amp;&amp; eventType == Hammer.EVENT_END) {
                    count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
                }
            }

            &#x2F;&#x2F;debug(sourceEventType +&quot; &quot;+ eventType);

            &#x2F;&#x2F; on the end we reset everything
            if(!count_touches) {
                last_move_event = null;
                enable_detect = false;
                touch_triggered = false;
                Hammer.PointerEvent.reset();
            }
        });
    },


    &#x2F;**
     * we have different events for each device&#x2F;browser
     * determine what we need and set them in the Hammer.EVENT_TYPES constant
     *&#x2F;
    determineEventTypes: function determineEventTypes() {
        &#x2F;&#x2F; determine the eventtype we want to set
        var types;

        &#x2F;&#x2F; pointerEvents magic
        if(Hammer.HAS_POINTEREVENTS) {
            types = Hammer.PointerEvent.getEvents();
        }
        &#x2F;&#x2F; on Android, iOS, blackberry, windows mobile we dont want any mouseevents
        else if(Hammer.NO_MOUSEEVENTS) {
            types = [
                &#x27;touchstart&#x27;,
                &#x27;touchmove&#x27;,
                &#x27;touchend touchcancel&#x27;];
        }
        &#x2F;&#x2F; for non pointer events browsers and mixed browsers,
        &#x2F;&#x2F; like chrome on windows8 touch laptop
        else {
            types = [
                &#x27;touchstart mousedown&#x27;,
                &#x27;touchmove mousemove&#x27;,
                &#x27;touchend touchcancel mouseup&#x27;];
        }

        Hammer.EVENT_TYPES[Hammer.EVENT_START]  = types[0];
        Hammer.EVENT_TYPES[Hammer.EVENT_MOVE]   = types[1];
        Hammer.EVENT_TYPES[Hammer.EVENT_END]    = types[2];
    },


    &#x2F;**
     * create touchlist depending on the event
     * @param   {Object}    ev
     * @param   {String}    eventType   used by the fakemultitouch plugin
     *&#x2F;
    getTouchList: function getTouchList(ev&#x2F;*, eventType*&#x2F;) {
        &#x2F;&#x2F; get the fake pointerEvent touchlist
        if(Hammer.HAS_POINTEREVENTS) {
            return Hammer.PointerEvent.getTouchList();
        }
        &#x2F;&#x2F; get the touchlist
        else if(ev.touches) {
            return ev.touches;
        }
        &#x2F;&#x2F; make fake touchlist from mouse position
        else {
            return [{
                identifier: 1,
                pageX: ev.pageX,
                pageY: ev.pageY,
                target: ev.target
            }];
        }
    },


    &#x2F;**
     * collect event data for Hammer js
     * @param   {HTMLElement}   element
     * @param   {String}        eventType        like Hammer.EVENT_MOVE
     * @param   {Object}        eventData
     *&#x2F;
    collectEventData: function collectEventData(element, eventType, ev) {
        var touches = this.getTouchList(ev, eventType);

        &#x2F;&#x2F; find out pointerType
        var pointerType = Hammer.POINTER_TOUCH;
        if(ev.type.match(&#x2F;mouse&#x2F;) || Hammer.PointerEvent.matchType(Hammer.POINTER_MOUSE, ev)) {
            pointerType = Hammer.POINTER_MOUSE;
        }

        return {
            center      : Hammer.utils.getCenter(touches),
            timeStamp   : new Date().getTime(),
            target      : ev.target,
            touches     : touches,
            eventType   : eventType,
            pointerType : pointerType,
            srcEvent    : ev,

            &#x2F;**
             * prevent the browser default actions
             * mostly used to disable scrolling of the browser
             *&#x2F;
            preventDefault: function() {
                if(this.srcEvent.preventManipulation) {
                    this.srcEvent.preventManipulation();
                }

                if(this.srcEvent.preventDefault) {
                    this.srcEvent.preventDefault();
                }
            },

            &#x2F;**
             * stop bubbling the event up to its parents
             *&#x2F;
            stopPropagation: function() {
                this.srcEvent.stopPropagation();
            },

            &#x2F;**
             * immediately stop gesture detection
             * might be useful after a swipe was detected
             * @return {*}
             *&#x2F;
            stopDetect: function() {
                return Hammer.detection.stopDetect();
            }
        };
    }
};

Hammer.PointerEvent = {
    &#x2F;**
     * holds all pointers
     * @type {Object}
     *&#x2F;
    pointers: {},

    &#x2F;**
     * get a list of pointers
     * @returns {Array}     touchlist
     *&#x2F;
    getTouchList: function() {
        var self = this;
        var touchlist = [];

        &#x2F;&#x2F; we can use forEach since pointerEvents only is in IE10
        Object.keys(self.pointers).sort().forEach(function(id) {
            touchlist.push(self.pointers[id]);
        });
        return touchlist;
    },

    &#x2F;**
     * update the position of a pointer
     * @param   {String}   type             Hammer.EVENT_END
     * @param   {Object}   pointerEvent
     *&#x2F;
    updatePointer: function(type, pointerEvent) {
        if(type == Hammer.EVENT_END) {
            this.pointers = {};
        }
        else {
            pointerEvent.identifier = pointerEvent.pointerId;
            this.pointers[pointerEvent.pointerId] = pointerEvent;
        }

        return Object.keys(this.pointers).length;
    },

    &#x2F;**
     * check if ev matches pointertype
     * @param   {String}        pointerType     Hammer.POINTER_MOUSE
     * @param   {PointerEvent}  ev
     *&#x2F;
    matchType: function(pointerType, ev) {
        if(!ev.pointerType) {
            return false;
        }

        var types = {};
        types[Hammer.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == Hammer.POINTER_MOUSE);
        types[Hammer.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == Hammer.POINTER_TOUCH);
        types[Hammer.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == Hammer.POINTER_PEN);
        return types[pointerType];
    },


    &#x2F;**
     * get events
     *&#x2F;
    getEvents: function() {
        return [
            &#x27;pointerdown MSPointerDown&#x27;,
            &#x27;pointermove MSPointerMove&#x27;,
            &#x27;pointerup pointercancel MSPointerUp MSPointerCancel&#x27;
        ];
    },

    &#x2F;**
     * reset the list
     *&#x2F;
    reset: function() {
        this.pointers = {};
    }
};


Hammer.utils = {
    &#x2F;**
     * extend method,
     * also used for cloning when dest is an empty object
     * @param   {Object}    dest
     * @param   {Object}    src
	 * @parm	{Boolean}	merge		do a merge
     * @returns {Object}    dest
     *&#x2F;
    extend: function extend(dest, src, merge) {
        for (var key in src) {
			if(dest[key] !== undefined &amp;&amp; merge) {
				continue;
			}
            dest[key] = src[key];
        }
        return dest;
    },


    &#x2F;**
     * find if a node is in the given parent
     * used for event delegation tricks
     * @param   {HTMLElement}   node
     * @param   {HTMLElement}   parent
     * @returns {boolean}       has_parent
     *&#x2F;
    hasParent: function(node, parent) {
        while(node){
            if(node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    },


    &#x2F;**
     * get the center of all the touches
     * @param   {Array}     touches
     * @returns {Object}    center
     *&#x2F;
    getCenter: function getCenter(touches) {
        var valuesX = [], valuesY = [];

        for(var t= 0,len=touches.length; t&lt;len; t++) {
            valuesX.push(touches[t].pageX);
            valuesY.push(touches[t].pageY);
        }

        return {
            pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) &#x2F; 2),
            pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) &#x2F; 2)
        };
    },


    &#x2F;**
     * calculate the velocity between two points
     * @param   {Number}    delta_time
     * @param   {Number}    delta_x
     * @param   {Number}    delta_y
     * @returns {Object}    velocity
     *&#x2F;
    getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
        return {
            x: Math.abs(delta_x &#x2F; delta_time) || 0,
            y: Math.abs(delta_y &#x2F; delta_time) || 0
        };
    },


    &#x2F;**
     * calculate the angle between two coordinates
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {Number}    angle
     *&#x2F;
    getAngle: function getAngle(touch1, touch2) {
        var y = touch2.pageY - touch1.pageY,
            x = touch2.pageX - touch1.pageX;
        return Math.atan2(y, x) * 180 &#x2F; Math.PI;
    },


    &#x2F;**
     * angle to direction define
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {String}    direction constant, like Hammer.DIRECTION_LEFT
     *&#x2F;
    getDirection: function getDirection(touch1, touch2) {
        var x = Math.abs(touch1.pageX - touch2.pageX),
            y = Math.abs(touch1.pageY - touch2.pageY);

        if(x &gt;= y) {
            return touch1.pageX - touch2.pageX &gt; 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
        }
        else {
            return touch1.pageY - touch2.pageY &gt; 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
        }
    },


    &#x2F;**
     * calculate the distance between two touches
     * @param   {Touch}     touch1
     * @param   {Touch}     touch2
     * @returns {Number}    distance
     *&#x2F;
    getDistance: function getDistance(touch1, touch2) {
        var x = touch2.pageX - touch1.pageX,
            y = touch2.pageY - touch1.pageY;
        return Math.sqrt((x*x) + (y*y));
    },


    &#x2F;**
     * calculate the scale factor between two touchLists (fingers)
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param   {Array}     start
     * @param   {Array}     end
     * @returns {Number}    scale
     *&#x2F;
    getScale: function getScale(start, end) {
        &#x2F;&#x2F; need two fingers...
        if(start.length &gt;= 2 &amp;&amp; end.length &gt;= 2) {
            return this.getDistance(end[0], end[1]) &#x2F;
                this.getDistance(start[0], start[1]);
        }
        return 1;
    },


    &#x2F;**
     * calculate the rotation degrees between two touchLists (fingers)
     * @param   {Array}     start
     * @param   {Array}     end
     * @returns {Number}    rotation
     *&#x2F;
    getRotation: function getRotation(start, end) {
        &#x2F;&#x2F; need two fingers
        if(start.length &gt;= 2 &amp;&amp; end.length &gt;= 2) {
            return this.getAngle(end[1], end[0]) -
                this.getAngle(start[1], start[0]);
        }
        return 0;
    },


    &#x2F;**
     * boolean if the direction is vertical
     * @param    {String}    direction
     * @returns  {Boolean}   is_vertical
     *&#x2F;
    isVertical: function isVertical(direction) {
        return (direction == Hammer.DIRECTION_UP || direction == Hammer.DIRECTION_DOWN);
    },


    &#x2F;**
     * stop browser default behavior with css props
     * @param   {HtmlElement}   element
     * @param   {Object}        css_props
     *&#x2F;
    stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_props) {
        var prop,
            vendors = [&#x27;webkit&#x27;,&#x27;khtml&#x27;,&#x27;moz&#x27;,&#x27;ms&#x27;,&#x27;o&#x27;,&#x27;&#x27;];

        if(!css_props || !element.style) {
            return;
        }

        &#x2F;&#x2F; with css properties for modern browsers
        for(var i = 0; i &lt; vendors.length; i++) {
            for(var p in css_props) {
                if(css_props.hasOwnProperty(p)) {
                    prop = p;

                    &#x2F;&#x2F; vender prefix at the property
                    if(vendors[i]) {
                        prop = vendors[i] + prop.substring(0, 1).toUpperCase() + prop.substring(1);
                    }

                    &#x2F;&#x2F; set the style
                    element.style[prop] = css_props[p];
                }
            }
        }

        &#x2F;&#x2F; also the disable onselectstart
        if(css_props.userSelect == &#x27;none&#x27;) {
            element.onselectstart = function() {
                return false;
            };
        }
    }
};

Hammer.detection = {
    &#x2F;&#x2F; contains all registred Hammer.gestures in the correct order
    gestures: [],

    &#x2F;&#x2F; data of the current Hammer.gesture detection session
    current: null,

    &#x2F;&#x2F; the previous Hammer.gesture session data
    &#x2F;&#x2F; is a full clone of the previous gesture.current object
    previous: null,

    &#x2F;&#x2F; when this becomes true, no gestures are fired
    stopped: false,


    &#x2F;**
     * start Hammer.gesture detection
     * @param   {Hammer.Instance}   inst
     * @param   {Object}            eventData
     *&#x2F;
    startDetect: function startDetect(inst, eventData) {
        &#x2F;&#x2F; already busy with a Hammer.gesture detection on an element
        if(this.current) {
            return;
        }

        this.stopped = false;

        this.current = {
            inst        : inst, &#x2F;&#x2F; reference to HammerInstance we&#x27;re working for
            startEvent  : Hammer.utils.extend({}, eventData), &#x2F;&#x2F; start eventData for distances, timing etc
            lastEvent   : false, &#x2F;&#x2F; last eventData
            name        : &#x27;&#x27; &#x2F;&#x2F; current gesture we&#x27;re in&#x2F;detected, can be &#x27;tap&#x27;, &#x27;hold&#x27; etc
        };

        this.detect(eventData);
    },


    &#x2F;**
     * Hammer.gesture detection
     * @param   {Object}    eventData
     * @param   {Object}    eventData
     *&#x2F;
    detect: function detect(eventData) {
        if(!this.current || this.stopped) {
            return;
        }

        &#x2F;&#x2F; extend event data with calculations about scale, distance etc
        eventData = this.extendEventData(eventData);

        &#x2F;&#x2F; instance options
        var inst_options = this.current.inst.options;

        &#x2F;&#x2F; call Hammer.gesture handlers
        for(var g=0,len=this.gestures.length; g&lt;len; g++) {
            var gesture = this.gestures[g];

            &#x2F;&#x2F; only when the instance options have enabled this gesture
            if(!this.stopped &amp;&amp; inst_options[gesture.name] !== false) {
                &#x2F;&#x2F; if a handler returns false, we stop with the detection
                if(gesture.handler.call(gesture, eventData, this.current.inst) === false) {
                    this.stopDetect();
                    break;
                }
            }
        }

        &#x2F;&#x2F; store as previous event event
        if(this.current) {
            this.current.lastEvent = eventData;
        }

        &#x2F;&#x2F; endevent, but not the last touch, so dont stop
        if(eventData.eventType == Hammer.EVENT_END &amp;&amp; !eventData.touches.length-1) {
            this.stopDetect();
        }

        return eventData;
    },


    &#x2F;**
     * clear the Hammer.gesture vars
     * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
     * to stop other Hammer.gestures from being fired
     *&#x2F;
    stopDetect: function stopDetect() {
        &#x2F;&#x2F; clone current data to the store as the previous gesture
        &#x2F;&#x2F; used for the double tap gesture, since this is an other gesture detect session
        this.previous = Hammer.utils.extend({}, this.current);

        &#x2F;&#x2F; reset the current
        this.current = null;

        &#x2F;&#x2F; stopped!
        this.stopped = true;
    },


    &#x2F;**
     * extend eventData for Hammer.gestures
     * @param   {Object}   ev
     * @returns {Object}   ev
     *&#x2F;
    extendEventData: function extendEventData(ev) {
        var startEv = this.current.startEvent;

        &#x2F;&#x2F; if the touches change, set the new touches over the startEvent touches
        &#x2F;&#x2F; this because touchevents don&#x27;t have all the touches on touchstart, or the
        &#x2F;&#x2F; user must place his fingers at the EXACT same time on the screen, which is not realistic
        &#x2F;&#x2F; but, sometimes it happens that both fingers are touching at the EXACT same time
        if(startEv &amp;&amp; (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
            &#x2F;&#x2F; extend 1 level deep to get the touchlist with the touch objects
            startEv.touches = [];
            for(var i=0,len=ev.touches.length; i&lt;len; i++) {
                startEv.touches.push(Hammer.utils.extend({}, ev.touches[i]));
            }
        }

        var delta_time = ev.timeStamp - startEv.timeStamp,
            delta_x = ev.center.pageX - startEv.center.pageX,
            delta_y = ev.center.pageY - startEv.center.pageY,
            velocity = Hammer.utils.getVelocity(delta_time, delta_x, delta_y);

        Hammer.utils.extend(ev, {
            deltaTime   : delta_time,

            deltaX      : delta_x,
            deltaY      : delta_y,

            velocityX   : velocity.x,
            velocityY   : velocity.y,

            distance    : Hammer.utils.getDistance(startEv.center, ev.center),
            angle       : Hammer.utils.getAngle(startEv.center, ev.center),
            direction   : Hammer.utils.getDirection(startEv.center, ev.center),

            scale       : Hammer.utils.getScale(startEv.touches, ev.touches),
            rotation    : Hammer.utils.getRotation(startEv.touches, ev.touches),

            startEvent  : startEv
        });

        return ev;
    },


    &#x2F;**
     * register new gesture
     * @param   {Object}    gesture object, see gestures.js for documentation
     * @returns {Array}     gestures
     *&#x2F;
    register: function register(gesture) {
        &#x2F;&#x2F; add an enable gesture options if there is no given
        var options = gesture.defaults || {};
        if(options[gesture.name] === undefined) {
            options[gesture.name] = true;
        }

        &#x2F;&#x2F; extend Hammer default options with the Hammer.gesture options
        Hammer.utils.extend(Hammer.defaults, options, true);

        &#x2F;&#x2F; set its index
        gesture.index = gesture.index || 1000;

        &#x2F;&#x2F; add Hammer.gesture to the list
        this.gestures.push(gesture);

        &#x2F;&#x2F; sort the list by index
        this.gestures.sort(function(a, b) {
            if (a.index &lt; b.index) {
                return -1;
            }
            if (a.index &gt; b.index) {
                return 1;
            }
            return 0;
        });

        return this.gestures;
    }
};


Hammer.gestures = Hammer.gestures || {};

&#x2F;**
 * Custom gestures
 * ==============================
 *
 * Gesture object
 * --------------------
 * The object structure of a gesture:
 *
 * { name: &#x27;mygesture&#x27;,
 *   index: 1337,
 *   defaults: {
 *     mygesture_option: true
 *   }
 *   handler: function(type, ev, inst) {
 *     &#x2F;&#x2F; trigger gesture event
 *     inst.trigger(this.name, ev);
 *   }
 * }

 * @param   {String}    name
 * this should be the name of the gesture, lowercase
 * it is also being used to disable&#x2F;enable the gesture per instance config.
 *
 * @param   {Number}    [index=1000]
 * the index of the gesture, where it is going to be in the stack of gestures detection
 * like when you build an gesture that depends on the drag gesture, it is a good
 * idea to place it after the index of the drag gesture.
 *
 * @param   {Object}    [defaults={}]
 * the default settings of the gesture. these are added to the instance settings,
 * and can be overruled per instance. you can also add the name of the gesture,
 * but this is also added by default (and set to true).
 *
 * @param   {Function}  handler
 * this handles the gesture detection of your custom gesture and receives the
 * following arguments:
 *
 *      @param  {Object}    eventData
 *      event data containing the following properties:
 *          timeStamp   {Number}        time the event occurred
 *          target      {HTMLElement}   target element
 *          touches     {Array}         touches (fingers, pointers, mouse) on the screen
 *          pointerType {String}        kind of pointer that was used. matches Hammer.POINTER_MOUSE|TOUCH
 *          center      {Object}        center position of the touches. contains pageX and pageY
 *          deltaTime   {Number}        the total time of the touches in the screen
 *          deltaX      {Number}        the delta on x axis we haved moved
 *          deltaY      {Number}        the delta on y axis we haved moved
 *          velocityX   {Number}        the velocity on the x
 *          velocityY   {Number}        the velocity on y
 *          angle       {Number}        the angle we are moving
 *          direction   {String}        the direction we are moving. matches Hammer.DIRECTION_UP|DOWN|LEFT|RIGHT
 *          distance    {Number}        the distance we haved moved
 *          scale       {Number}        scaling of the touches, needs 2 touches
 *          rotation    {Number}        rotation of the touches, needs 2 touches *
 *          eventType   {String}        matches Hammer.EVENT_START|MOVE|END
 *          srcEvent    {Object}        the source event, like TouchStart or MouseDown *
 *          startEvent  {Object}        contains the same properties as above,
 *                                      but from the first touch. this is used to calculate
 *                                      distances, deltaTime, scaling etc
 *
 *      @param  {Hammer.Instance}    inst
 *      the instance we are doing the detection for. you can get the options from
 *      the inst.options object and trigger the gesture event by calling inst.trigger
 *
 *
 * Handle gestures
 * --------------------
 * inside the handler you can get&#x2F;set Hammer.detection.current. This is the current
 * detection session. It has the following properties
 *      @param  {String}    name
 *      contains the name of the gesture we have detected. it has not a real function,
 *      only to check in other gestures if something is detected.
 *      like in the drag gesture we set it to &#x27;drag&#x27; and in the swipe gesture we can
 *      check if the current gesture is &#x27;drag&#x27; by accessing Hammer.detection.current.name
 *
 *      @readonly
 *      @param  {Hammer.Instance}    inst
 *      the instance we do the detection for
 *
 *      @readonly
 *      @param  {Object}    startEvent
 *      contains the properties of the first gesture detection in this session.
 *      Used for calculations about timing, distance, etc.
 *
 *      @readonly
 *      @param  {Object}    lastEvent
 *      contains all the properties of the last gesture detect in this session.
 *
 * after the gesture detection session has been completed (user has released the screen)
 * the Hammer.detection.current object is copied into Hammer.detection.previous,
 * this is usefull for gestures like doubletap, where you need to know if the
 * previous gesture was a tap
 *
 * options that have been set by the instance can be received by calling inst.options
 *
 * You can trigger a gesture event by calling inst.trigger(&quot;mygesture&quot;, event).
 * The first param is the name of your gesture, the second the event argument
 *
 *
 * Register gestures
 * --------------------
 * When an gesture is added to the Hammer.gestures object, it is auto registered
 * at the setup of the first Hammer instance. You can also call Hammer.detection.register
 * manually and pass your gesture object as a param
 *
 *&#x2F;

&#x2F;**
 * Hold
 * Touch stays at the same place for x time
 * @events  hold
 *&#x2F;
Hammer.gestures.Hold = {
    name: &#x27;hold&#x27;,
    index: 10,
    defaults: {
        hold_timeout	: 500,
        hold_threshold	: 1
    },
    timer: null,
    handler: function holdGesture(ev, inst) {
        switch(ev.eventType) {
            case Hammer.EVENT_START:
                &#x2F;&#x2F; clear any running timers
                clearTimeout(this.timer);

                &#x2F;&#x2F; set the gesture so we can check in the timeout if it still is
                Hammer.detection.current.name = this.name;

                &#x2F;&#x2F; set timer and if after the timeout it still is hold,
                &#x2F;&#x2F; we trigger the hold event
                this.timer = setTimeout(function() {
                    if(Hammer.detection.current.name == &#x27;hold&#x27;) {
                        inst.trigger(&#x27;hold&#x27;, ev);
                    }
                }, inst.options.hold_timeout);
                break;

            &#x2F;&#x2F; when you move or end we clear the timer
            case Hammer.EVENT_MOVE:
                if(ev.distance &gt; inst.options.hold_threshold) {
                    clearTimeout(this.timer);
                }
                break;

            case Hammer.EVENT_END:
                clearTimeout(this.timer);
                break;
        }
    }
};


&#x2F;**
 * Tap&#x2F;DoubleTap
 * Quick touch at a place or double at the same place
 * @events  tap, doubletap
 *&#x2F;
Hammer.gestures.Tap = {
    name: &#x27;tap&#x27;,
    index: 100,
    defaults: {
        tap_max_touchtime	: 250,
        tap_max_distance	: 10,
		tap_always			: true,
        doubletap_distance	: 20,
        doubletap_interval	: 300
    },
    handler: function tapGesture(ev, inst) {
        if(ev.eventType == Hammer.EVENT_END) {
            &#x2F;&#x2F; previous gesture, for the double tap since these are two different gesture detections
            var prev = Hammer.detection.previous,
				did_doubletap = false;

            &#x2F;&#x2F; when the touchtime is higher then the max touch time
            &#x2F;&#x2F; or when the moving distance is too much
            if(ev.deltaTime &gt; inst.options.tap_max_touchtime ||
                ev.distance &gt; inst.options.tap_max_distance) {
                return;
            }

            &#x2F;&#x2F; check if double tap
            if(prev &amp;&amp; prev.name == &#x27;tap&#x27; &amp;&amp;
                (ev.timeStamp - prev.lastEvent.timeStamp) &lt; inst.options.doubletap_interval &amp;&amp;
                ev.distance &lt; inst.options.doubletap_distance) {
				inst.trigger(&#x27;doubletap&#x27;, ev);
				did_doubletap = true;
            }

			&#x2F;&#x2F; do a single tap
			if(!did_doubletap || inst.options.tap_always) {
				Hammer.detection.current.name = &#x27;tap&#x27;;
				inst.trigger(Hammer.detection.current.name, ev);
			}
        }
    }
};


&#x2F;**
 * Swipe
 * triggers swipe events when the end velocity is above the threshold
 * @events  swipe, swipeleft, swiperight, swipeup, swipedown
 *&#x2F;
Hammer.gestures.Swipe = {
    name: &#x27;swipe&#x27;,
    index: 40,
    defaults: {
        &#x2F;&#x2F; set 0 for unlimited, but this can conflict with transform
        swipe_max_touches  : 1,
        swipe_velocity     : 0.7
    },
    handler: function swipeGesture(ev, inst) {
        if(ev.eventType == Hammer.EVENT_END) {
            &#x2F;&#x2F; max touches
            if(inst.options.swipe_max_touches &gt; 0 &amp;&amp;
                ev.touches.length &gt; inst.options.swipe_max_touches) {
                return;
            }

            &#x2F;&#x2F; when the distance we moved is too small we skip this gesture
            &#x2F;&#x2F; or we can be already in dragging
            if(ev.velocityX &gt; inst.options.swipe_velocity ||
                ev.velocityY &gt; inst.options.swipe_velocity) {
                &#x2F;&#x2F; trigger swipe events
                inst.trigger(this.name, ev);
                inst.trigger(this.name + ev.direction, ev);
            }
        }
    }
};


&#x2F;**
 * Drag
 * Move with x fingers (default 1) around on the page. Blocking the scrolling when
 * moving left and right is a good practice. When all the drag events are blocking
 * you disable scrolling on that area.
 * @events  drag, drapleft, dragright, dragup, dragdown
 *&#x2F;
Hammer.gestures.Drag = {
    name: &#x27;drag&#x27;,
    index: 50,
    defaults: {
        drag_min_distance : 10,
        &#x2F;&#x2F; set 0 for unlimited, but this can conflict with transform
        drag_max_touches  : 1,
        &#x2F;&#x2F; prevent default browser behavior when dragging occurs
        &#x2F;&#x2F; be careful with it, it makes the element a blocking element
        &#x2F;&#x2F; when you are using the drag gesture, it is a good practice to set this true
        drag_block_horizontal   : false,
        drag_block_vertical     : false,
        &#x2F;&#x2F; drag_lock_to_axis keeps the drag gesture on the axis that it started on,
        &#x2F;&#x2F; It disallows vertical directions if the initial direction was horizontal, and vice versa.
        drag_lock_to_axis       : false,
        &#x2F;&#x2F; drag lock only kicks in when distance &gt; drag_lock_min_distance
        &#x2F;&#x2F; This way, locking occurs only when the distance has become large enough to reliably determine the direction
        drag_lock_min_distance : 25
    },
    triggered: false,
    handler: function dragGesture(ev, inst) {
        &#x2F;&#x2F; current gesture isnt drag, but dragged is true
        &#x2F;&#x2F; this means an other gesture is busy. now call dragend
        if(Hammer.detection.current.name != this.name &amp;&amp; this.triggered) {
            inst.trigger(this.name +&#x27;end&#x27;, ev);
            this.triggered = false;
            return;
        }

        &#x2F;&#x2F; max touches
        if(inst.options.drag_max_touches &gt; 0 &amp;&amp;
            ev.touches.length &gt; inst.options.drag_max_touches) {
            return;
        }

        switch(ev.eventType) {
            case Hammer.EVENT_START:
                this.triggered = false;
                break;

            case Hammer.EVENT_MOVE:
                &#x2F;&#x2F; when the distance we moved is too small we skip this gesture
                &#x2F;&#x2F; or we can be already in dragging
                if(ev.distance &lt; inst.options.drag_min_distance &amp;&amp;
                    Hammer.detection.current.name != this.name) {
                    return;
                }

                &#x2F;&#x2F; we are dragging!
                Hammer.detection.current.name = this.name;

                &#x2F;&#x2F; lock drag to axis?
                if(Hammer.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis &amp;&amp; inst.options.drag_lock_min_distance&lt;=ev.distance)) {
                    ev.drag_locked_to_axis = true;
                }
                var last_direction = Hammer.detection.current.lastEvent.direction;
                if(ev.drag_locked_to_axis &amp;&amp; last_direction !== ev.direction) {
                    &#x2F;&#x2F; keep direction on the axis that the drag gesture started on
                    if(Hammer.utils.isVertical(last_direction)) {
                        ev.direction = (ev.deltaY &lt; 0) ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
                    }
                    else {
                        ev.direction = (ev.deltaX &lt; 0) ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
                    }
                }

                &#x2F;&#x2F; first time, trigger dragstart event
                if(!this.triggered) {
                    inst.trigger(this.name +&#x27;start&#x27;, ev);
                    this.triggered = true;
                }

                &#x2F;&#x2F; trigger normal event
                inst.trigger(this.name, ev);

                &#x2F;&#x2F; direction event, like dragdown
                inst.trigger(this.name + ev.direction, ev);

                &#x2F;&#x2F; block the browser events
                if( (inst.options.drag_block_vertical &amp;&amp; Hammer.utils.isVertical(ev.direction)) ||
                    (inst.options.drag_block_horizontal &amp;&amp; !Hammer.utils.isVertical(ev.direction))) {
                    ev.preventDefault();
                }
                break;

            case Hammer.EVENT_END:
                &#x2F;&#x2F; trigger dragend
                if(this.triggered) {
                    inst.trigger(this.name +&#x27;end&#x27;, ev);
                }

                this.triggered = false;
                break;
        }
    }
};


&#x2F;**
 * Transform
 * User want to scale or rotate with 2 fingers
 * @events  transform, pinch, pinchin, pinchout, rotate
 *&#x2F;
Hammer.gestures.Transform = {
    name: &#x27;transform&#x27;,
    index: 45,
    defaults: {
        &#x2F;&#x2F; factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
        transform_min_scale     : 0.01,
        &#x2F;&#x2F; rotation in degrees
        transform_min_rotation  : 1,
        &#x2F;&#x2F; prevent default browser behavior when two touches are on the screen
        &#x2F;&#x2F; but it makes the element a blocking element
        &#x2F;&#x2F; when you are using the transform gesture, it is a good practice to set this true
        transform_always_block  : false
    },
    triggered: false,
    handler: function transformGesture(ev, inst) {
        &#x2F;&#x2F; current gesture isnt drag, but dragged is true
        &#x2F;&#x2F; this means an other gesture is busy. now call dragend
        if(Hammer.detection.current.name != this.name &amp;&amp; this.triggered) {
            inst.trigger(this.name +&#x27;end&#x27;, ev);
            this.triggered = false;
            return;
        }

        &#x2F;&#x2F; atleast multitouch
        if(ev.touches.length &lt; 2) {
            return;
        }

        &#x2F;&#x2F; prevent default when two fingers are on the screen
        if(inst.options.transform_always_block) {
            ev.preventDefault();
        }

        switch(ev.eventType) {
            case Hammer.EVENT_START:
                this.triggered = false;
                break;

            case Hammer.EVENT_MOVE:
                var scale_threshold = Math.abs(1-ev.scale);
                var rotation_threshold = Math.abs(ev.rotation);

                &#x2F;&#x2F; when the distance we moved is too small we skip this gesture
                &#x2F;&#x2F; or we can be already in dragging
                if(scale_threshold &lt; inst.options.transform_min_scale &amp;&amp;
                    rotation_threshold &lt; inst.options.transform_min_rotation) {
                    return;
                }

                &#x2F;&#x2F; we are transforming!
                Hammer.detection.current.name = this.name;

                &#x2F;&#x2F; first time, trigger dragstart event
                if(!this.triggered) {
                    inst.trigger(this.name +&#x27;start&#x27;, ev);
                    this.triggered = true;
                }

                inst.trigger(this.name, ev); &#x2F;&#x2F; basic transform event

                &#x2F;&#x2F; trigger rotate event
                if(rotation_threshold &gt; inst.options.transform_min_rotation) {
                    inst.trigger(&#x27;rotate&#x27;, ev);
                }

                &#x2F;&#x2F; trigger pinch event
                if(scale_threshold &gt; inst.options.transform_min_scale) {
                    inst.trigger(&#x27;pinch&#x27;, ev);
                    inst.trigger(&#x27;pinch&#x27;+ ((ev.scale &lt; 1) ? &#x27;in&#x27; : &#x27;out&#x27;), ev);
                }
                break;

            case Hammer.EVENT_END:
                &#x2F;&#x2F; trigger dragend
                if(this.triggered) {
                    inst.trigger(this.name +&#x27;end&#x27;, ev);
                }

                this.triggered = false;
                break;
        }
    }
};


&#x2F;**
 * Touch
 * Called as first, tells the user has touched the screen
 * @events  touch
 *&#x2F;
Hammer.gestures.Touch = {
    name: &#x27;touch&#x27;,
    index: -Infinity,
    defaults: {
        &#x2F;&#x2F; call preventDefault at touchstart, and makes the element blocking by
        &#x2F;&#x2F; disabling the scrolling of the page, but it improves gestures like
        &#x2F;&#x2F; transforming and dragging.
        &#x2F;&#x2F; be careful with using this, it can be very annoying for users to be stuck
        &#x2F;&#x2F; on the page
        prevent_default: false,

        &#x2F;&#x2F; disable mouse events, so only touch (or pen!) input triggers events
        prevent_mouseevents: false
    },
    handler: function touchGesture(ev, inst) {
        if(inst.options.prevent_mouseevents &amp;&amp; ev.pointerType == Hammer.POINTER_MOUSE) {
            ev.stopDetect();
            return;
        }

        if(inst.options.prevent_default) {
            ev.preventDefault();
        }

        if(ev.eventType ==  Hammer.EVENT_START) {
            inst.trigger(this.name, ev);
        }
    }
};


&#x2F;**
 * Release
 * Called as last, tells the user has released the screen
 * @events  release
 *&#x2F;
Hammer.gestures.Release = {
    name: &#x27;release&#x27;,
    index: Infinity,
    handler: function releaseGesture(ev, inst) {
        if(ev.eventType ==  Hammer.EVENT_END) {
            inst.trigger(this.name, ev);
        }
    }
};

&#x2F;&#x2F; node export
if(typeof module === &#x27;object&#x27; &amp;&amp; typeof module.exports === &#x27;object&#x27;){
    module.exports = Hammer;
}
&#x2F;&#x2F; just window export
else {
    window.Hammer = Hammer;

    &#x2F;&#x2F; requireJS module definition
    if(typeof window.define === &#x27;function&#x27; &amp;&amp; window.define.amd) {
        window.define(&#x27;hammer&#x27;, [], function() {
            return Hammer;
        });
    }
}
})(this);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
