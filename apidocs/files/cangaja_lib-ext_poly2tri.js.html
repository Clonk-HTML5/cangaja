<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>cangaja&#x2F;lib-ext&#x2F;poly2tri.js - Cangaja API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="Cangaja API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/CG.Animation.html">CG.Animation</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DBridge.html">CG.B2DBridge</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DChainShape.html">CG.B2DChainShape</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DCirlce.html">CG.B2DCirlce</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DEntity.html">CG.B2DEntity</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DLine.html">CG.B2DLine</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DPolygon.html">CG.B2DPolygon</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DRectangle.html">CG.B2DRectangle</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DRope.html">CG.B2DRope</a></li>
            
                <li><a href="..&#x2F;classes/CG.B2DWorld.html">CG.B2DWorld</a></li>
            
                <li><a href="..&#x2F;classes/CG.Bitmap.html">CG.Bitmap</a></li>
            
                <li><a href="..&#x2F;classes/CG.Bound.html">CG.Bound</a></li>
            
                <li><a href="..&#x2F;classes/CG.Buffer.html">CG.Buffer</a></li>
            
                <li><a href="..&#x2F;classes/CG.Button.html">CG.Button</a></li>
            
                <li><a href="..&#x2F;classes/CG.CanvasRenderer.html">CG.CanvasRenderer</a></li>
            
                <li><a href="..&#x2F;classes/CG.Delta.html">CG.Delta</a></li>
            
                <li><a href="..&#x2F;classes/CG.Director.html">CG.Director</a></li>
            
                <li><a href="..&#x2F;classes/CG.Emitter.html">CG.Emitter</a></li>
            
                <li><a href="..&#x2F;classes/CG.Entity.html">CG.Entity</a></li>
            
                <li><a href="..&#x2F;classes/CG.Font.html">CG.Font</a></li>
            
                <li><a href="..&#x2F;classes/CG.Layer.html">CG.Layer</a></li>
            
                <li><a href="..&#x2F;classes/CG.Map.html">CG.Map</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapArea.html">CG.MapArea</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapPoint.html">CG.MapPoint</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapTileLayer.html">CG.MapTileLayer</a></li>
            
                <li><a href="..&#x2F;classes/CG.MapTileProperties.html">CG.MapTileProperties</a></li>
            
                <li><a href="..&#x2F;classes/CG.MediaAsset.html">CG.MediaAsset</a></li>
            
                <li><a href="..&#x2F;classes/CG.Menu.html">CG.Menu</a></li>
            
                <li><a href="..&#x2F;classes/CG.Morph.html">CG.Morph</a></li>
            
                <li><a href="..&#x2F;classes/CG.Particle.html">CG.Particle</a></li>
            
                <li><a href="..&#x2F;classes/CG.Point.html">CG.Point</a></li>
            
                <li><a href="..&#x2F;classes/CG.Rectangle.html">CG.Rectangle</a></li>
            
                <li><a href="..&#x2F;classes/CG.Screen.html">CG.Screen</a></li>
            
                <li><a href="..&#x2F;classes/CG.Sequence.html">CG.Sequence</a></li>
            
                <li><a href="..&#x2F;classes/CG.Sprite.html">CG.Sprite</a></li>
            
                <li><a href="..&#x2F;classes/CG.Text.html">CG.Text</a></li>
            
                <li><a href="..&#x2F;classes/CG.TexturePacker.html">CG.TexturePacker</a></li>
            
                <li><a href="..&#x2F;classes/CG.TPImage.html">CG.TPImage</a></li>
            
                <li><a href="..&#x2F;classes/CG.Translate.html">CG.Translate</a></li>
            
                <li><a href="..&#x2F;classes/CG.Vector.html">CG.Vector</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/CG.html">CG</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: cangaja&#x2F;lib-ext&#x2F;poly2tri.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
 * Poly2Tri Copyright (c) 2009-2013, Poly2Tri Contributors
 * http:&#x2F;&#x2F;code.google.com&#x2F;p&#x2F;poly2tri&#x2F;
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and&#x2F;or other materials provided with the distribution.
 * * Neither the name of Poly2Tri nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *&#x2F;

&#x2F;* jshint browser:false, forin:true, noarg:true, noempty:true, eqeqeq:true, bitwise:true, 
   strict:true, undef:true, unused:true, curly:true, immed:true, latedef:true, 
   newcap:true, trailing:true, maxcomplexity:11, indent:4 
 *&#x2F;


&#x2F;*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionnaly follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 *&#x2F;


&#x2F;**
 * Module encapsulation
 * @param {Object} global a reference to the global object :
 *                      window in the browser, global on the server
 *&#x2F;
(function(global) {
    &quot;use strict&quot;;

&#x2F;&#x2F; --------------------------------------------------------------poly2tri module

    &#x2F;&#x2F; Save the previous value of the poly2tri variable, 
    &#x2F;&#x2F; so that it can be restored later on, if noConflict is used.
    var previousPoly2tri = global.poly2tri;

    &#x2F;&#x2F; The top-level namespace. All public poly2tri classes and functions will
    &#x2F;&#x2F; be attached to it. Exported for both the browser and the server (Node.js).
    var poly2tri;
    &#x2F;* global exports *&#x2F;
    if (typeof exports !== &#x27;undefined&#x27;) {
        poly2tri = exports;
    } else {
        poly2tri = global.poly2tri = {};
    }

    &#x2F;&#x2F; Runs the library in noConflict mode, returning the poly2tri variable 
    &#x2F;&#x2F; to its previous owner. Returns a reference to this library object.
    poly2tri.noConflict = function() {
        global.poly2tri = previousPoly2tri;
        return this;
    };

&#x2F;&#x2F; -------------------------------------------------------------------PointError

    &#x2F;**
     * Custom exception class to indicate invalid Point values
     * @param {String} message          error message
     * @param {array&lt;Point&gt;} points     invalid points
     *&#x2F;
    &#x2F;&#x2F; Class added in the JavaScript version (was not present in the c++ version)
    var PointError = function (message, points) {
        this.name    = &quot;PointError&quot;;
        this.points  = points = points || [];
        this.message = message || &quot;Invalid Points!&quot;;
        for (var i = 0; i &lt; points.length; i++) {
            this.message += &quot; &quot; + Point.toString(points[i]);
        }
    };
    PointError.prototype = new Error();
    PointError.prototype.constructor = PointError;


&#x2F;&#x2F; ------------------------------------------------------------------------Point
    &#x2F;**
     * Construct a point
     * @param {Number} x    coordinate (0 if undefined)
     * @param {Number} y    coordinate (0 if undefined)
     *&#x2F;
    var Point = function(x, y) {
        this.x = +x || 0;
        this.y = +y || 0;

        &#x2F;&#x2F; All extra fields added to Point are prefixed with _p2t_
        &#x2F;&#x2F; to avoid collisions if custom Point class is used.

        &#x2F;&#x2F; The edges this point constitutes an upper ending point
        this._p2t_edge_list = null;
    };

    &#x2F;**
     * For pretty printing ex. &lt;i&gt;&quot;(5;42)&quot;&lt;&#x2F;i&gt;)
     *&#x2F;
    Point.prototype.toString = function() {
        return (&quot;(&quot; + this.x + &quot;;&quot; + this.y + &quot;)&quot;);
    };

    &#x2F;**
     * Creates a copy of this Point object.
     * @returns Point
     *&#x2F;
    Point.prototype.clone = function() {
        return new Point(this.x, this.y);
    };

    &#x2F;**
     * Set this Point instance to the origo. &lt;code&gt;(0; 0)&lt;&#x2F;code&gt;
     *&#x2F;
    Point.prototype.set_zero = function() {
        this.x = 0.0;
        this.y = 0.0;
        return this; &#x2F;&#x2F; for chaining
    };

    &#x2F;**
     * Set the coordinates of this instance.
     * @param   x   number.
     * @param   y   number;
     *&#x2F;
    Point.prototype.set = function(x, y) {
        this.x = +x || 0;
        this.y = +y || 0;
        return this; &#x2F;&#x2F; for chaining
    };

    &#x2F;**
     * Negate this Point instance. (component-wise)
     *&#x2F;
    Point.prototype.negate = function() {
        this.x = -this.x;
        this.y = -this.y;
        return this; &#x2F;&#x2F; for chaining
    };

    &#x2F;**
     * Add another Point object to this instance. (component-wise)
     * @param   n   Point object.
     *&#x2F;
    Point.prototype.add = function(n) {
        this.x += n.x;
        this.y += n.y;
        return this; &#x2F;&#x2F; for chaining
    };

    &#x2F;**
     * Subtract this Point instance with another point given. (component-wise)
     * @param   n   Point object.
     *&#x2F;
    Point.prototype.sub = function(n) {
        this.x -= n.x;
        this.y -= n.y;
        return this; &#x2F;&#x2F; for chaining
    };

    &#x2F;**
     * Multiply this Point instance by a scalar. (component-wise)
     * @param   s   scalar.
     *&#x2F;
    Point.prototype.mul = function(s) {
        this.x *= s;
        this.y *= s;
        return this; &#x2F;&#x2F; for chaining
    };

    &#x2F;**
     * Return the distance of this Point instance from the origo.
     *&#x2F;
    Point.prototype.length = function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    };

    &#x2F;**
     * Normalize this Point instance (as a vector).
     * @return The original distance of this instance from the origo.
     *&#x2F;
    Point.prototype.normalize = function() {
        var len = this.length();
        this.x &#x2F;= len;
        this.y &#x2F;= len;
        return len;
    };

    &#x2F;**
     * Test this Point object with another for equality.
     * @param   p   any &quot;Point like&quot; object with {x,y} (duck typing)
     * @return &lt;code&gt;True&lt;&#x2F;code&gt; if &lt;code&gt;this == p&lt;&#x2F;code&gt;, &lt;code&gt;false&lt;&#x2F;code&gt; otherwise.
     *&#x2F;
    Point.prototype.equals = function(p) {
        return this.x === p.x &amp;&amp; this.y === p.y;
    };

&#x2F;&#x2F; -----------------------------------------------------Point (&quot;static&quot; methods)

    &#x2F;**
     * Negate a point component-wise and return the result as a new Point object.
     * @param   p   Point object.
     * @return the resulting Point object.
     *&#x2F;
    Point.negate = function(p) {
        return new Point(-p.x, -p.y);
    };

    &#x2F;**
     * Add two points component-wise and return the result as a new Point object.
     * @param   a   Point object.
     * @param   b   Point object.
     * @return the resulting Point object.
     *&#x2F;
    Point.add = function(a, b) {
        return new Point(a.x + b.x, a.y + b.y);
    };

    &#x2F;**
     * Subtract two points component-wise and return the result as a new Point object.
     * @param   a   Point object.
     * @param   b   Point object.
     * @return the resulting Point object.
     *&#x2F;
    Point.sub = function(a, b) {
        return new Point(a.x - b.x, a.y - b.y);
    };

    &#x2F;**
     * Multiply a point by a scalar and return the result as a new Point object.
     * @param   s   the scalar (a number).
     * @param   p   Point object.
     * @return the resulting Point object.
     *&#x2F;
    Point.mul = function(s, p) {
        return new Point(s * p.x, s * p.y);
    };

    &#x2F;**
     * Perform the cross product on either two points (this produces a scalar)
     * or a point and a scalar (this produces a point).
     * This function requires two parameters, either may be a Point object or a
     * number.
     * @param   a   Point object or scalar.
     * @param   b   Point object or scalar.
     * @return  a   Point object or a number, depending on the parameters.
     *&#x2F;
    Point.cross = function(a, b) {
        if (typeof(a) === &#x27;number&#x27;) {
            if (typeof(b) === &#x27;number&#x27;) {
                return a * b;
            } else {
                return new Point(-a * b.y, a * b.x);
            }
        } else {
            if (typeof(b) === &#x27;number&#x27;) {
                return new Point(b * a.y, -b * a.x);
            } else {
                return a.x * b.y - a.y * b.x;
            }
        }
    };


&#x2F;&#x2F; -----------------------------------------------------------------&quot;Point-Like&quot;
    &#x2F;*
     * The following functions operate on &quot;Point&quot; or any &quot;Point like&quot; object 
     * with {x,y} (duck typing).
     *&#x2F;


    &#x2F;**
     * Point pretty printing ex. &lt;i&gt;&quot;(5;42)&quot;&lt;&#x2F;i&gt;)
     * @param   p   any &quot;Point like&quot; object with {x,y} 
     * @returns {String}
     *&#x2F;
    Point.toString = function(p) {
        &#x2F;&#x2F; Try a custom toString first, and fallback to Point.prototype.toString if none
        var s = p.toString();
        return (s === &#x27;[object Object]&#x27; ? Point.prototype.toString.call(p) : s);
    };

    &#x2F;**
     * Compare two points component-wise.
     * @param   a,b   any &quot;Point like&quot; objects with {x,y} 
     * @return &lt;code&gt;&amp;lt; 0&lt;&#x2F;code&gt; if &lt;code&gt;a &amp;lt; b&lt;&#x2F;code&gt;, 
     *         &lt;code&gt;&amp;gt; 0&lt;&#x2F;code&gt; if &lt;code&gt;a &amp;gt; b&lt;&#x2F;code&gt;, 
     *         &lt;code&gt;0&lt;&#x2F;code&gt; otherwise.
     *&#x2F;
    Point.compare = function(a, b) {
        if (a.y === b.y) {
            return a.x - b.x;
        } else {
            return a.y - b.y;
        }
    };
    Point.cmp = Point.compare; &#x2F;&#x2F; backward compatibility

    &#x2F;**
     * Test two Point objects for equality.
     * @param   a,b   any &quot;Point like&quot; objects with {x,y} 
     * @return &lt;code&gt;True&lt;&#x2F;code&gt; if &lt;code&gt;a == b&lt;&#x2F;code&gt;, &lt;code&gt;false&lt;&#x2F;code&gt; otherwise.
     *&#x2F;
    Point.equals = function(a, b) {
        return a.x === b.x &amp;&amp; a.y === b.y;
    };

    &#x2F;**
     * Peform the dot product on two vectors.
     * @param   a,b   any &quot;Point like&quot; objects with {x,y} 
     * @return The dot product (as a number).
     *&#x2F;
    Point.dot = function(a, b) {
        return a.x * b.x + a.y * b.y;
    };


&#x2F;&#x2F; -------------------------------------------------------------------------Edge
    &#x2F;**
     * Represents a simple polygon&#x27;s edge
     * @param {Point} p1
     * @param {Point} p2
     *&#x2F;
    var Edge = function(p1, p2) {
        this.p = p1;
        this.q = p2;

        if (p1.y &gt; p2.y) {
            this.q = p1;
            this.p = p2;
        } else if (p1.y === p2.y) {
            if (p1.x &gt; p2.x) {
                this.q = p1;
                this.p = p2;
            } else if (p1.x === p2.x) {
                throw new PointError(&#x27;poly2tri Invalid Edge constructor: repeated points!&#x27;, [p1]);
            }
        }

        if (! this.q._p2t_edge_list) {
            this.q._p2t_edge_list = [];
        }
        this.q._p2t_edge_list.push(this);
    };

&#x2F;&#x2F; ---------------------------------------------------------------------Triangle
    &#x2F;**
     * Triangle class.&lt;br&gt;
     * Triangle-based data structures are known to have better performance than
     * quad-edge structures.
     * See: J. Shewchuk, &quot;Triangle: Engineering a 2D Quality Mesh Generator and
     * Delaunay Triangulator&quot;, &quot;Triangulations in CGAL&quot;
     * 
     * @param   a,b,c   any &quot;Point like&quot; objects with {x,y} (duck typing)
     *&#x2F;
    var Triangle = function(a, b, c) {
        &#x2F;&#x2F; Triangle points
        this.points_ = [a, b, c];
        &#x2F;&#x2F; Neighbor list
        this.neighbors_ = [null, null, null];
        &#x2F;&#x2F; Has this triangle been marked as an interior triangle?
        this.interior_ = false;
        &#x2F;&#x2F; Flags to determine if an edge is a Constrained edge
        this.constrained_edge = [false, false, false];
        &#x2F;&#x2F; Flags to determine if an edge is a Delauney edge
        this.delaunay_edge = [false, false, false];
    };

    &#x2F;**
     * For pretty printing ex. &lt;i&gt;&quot;[(5;42)(10;20)(21;30)]&quot;&lt;&#x2F;i&gt;)
     *&#x2F;
    Triangle.prototype.toString = function() {
        var p2s = Point.toString;
        return (&quot;[&quot; + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + &quot;]&quot;);
    };

    Triangle.prototype.getPoint = function(index) {
        return this.points_[index];
    };
    &#x2F;&#x2F; for backward compatibility
    Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

    Triangle.prototype.getNeighbor = function(index) {
        return this.neighbors_[index];
    };

    &#x2F;**
     * Test if this Triangle contains the Point object given as parameters as its
     * vertices. Only point references are compared, not values.
     * @return &lt;code&gt;True&lt;&#x2F;code&gt; if the Point object is of the Triangle&#x27;s vertices,
     *         &lt;code&gt;false&lt;&#x2F;code&gt; otherwise.
     *&#x2F;
    Triangle.prototype.containsPoint = function(point) {
        var points = this.points_;
        &#x2F;&#x2F; Here we are comparing point references, not values
        return (point === points[0] || point === points[1] || point === points[2]);
    };

    &#x2F;**
     * Test if this Triangle contains the Edge object given as parameter as its
     * bounding edges. Only point references are compared, not values.
     * @return &lt;code&gt;True&lt;&#x2F;code&gt; if the Edge object is of the Triangle&#x27;s bounding
     *         edges, &lt;code&gt;false&lt;&#x2F;code&gt; otherwise.
     *&#x2F;
    Triangle.prototype.containsEdge = function(edge) {
        return this.containsPoint(edge.p) &amp;&amp; this.containsPoint(edge.q);
    };
    Triangle.prototype.containsPoints = function(p1, p2) {
        return this.containsPoint(p1) &amp;&amp; this.containsPoint(p2);
    };


    Triangle.prototype.isInterior = function() {
        return this.interior_;
    };
    Triangle.prototype.setInterior = function(interior) {
        this.interior_ = interior;
        return this;
    };

    &#x2F;**
     * Update neighbor pointers.
     * @param {Point} p1 Point object.
     * @param {Point} p2 Point object.
     * @param {Triangle} t Triangle object.
     *&#x2F;
    Triangle.prototype.markNeighborPointers = function(p1, p2, t) {
        var points = this.points_;
        &#x2F;&#x2F; Here we are comparing point references, not values
        if ((p1 === points[2] &amp;&amp; p2 === points[1]) || (p1 === points[1] &amp;&amp; p2 === points[2])) {
            this.neighbors_[0] = t;
        } else if ((p1 === points[0] &amp;&amp; p2 === points[2]) || (p1 === points[2] &amp;&amp; p2 === points[0])) {
            this.neighbors_[1] = t;
        } else if ((p1 === points[0] &amp;&amp; p2 === points[1]) || (p1 === points[1] &amp;&amp; p2 === points[0])) {
            this.neighbors_[2] = t;
        } else {
            throw new Error(&#x27;poly2tri Invalid Triangle.markNeighborPointers() call&#x27;);
        }
    };

    &#x2F;**
     * Exhaustive search to update neighbor pointers
     * @param {Triangle} t
     *&#x2F;
    Triangle.prototype.markNeighbor = function(t) {
        var points = this.points_;
        if (t.containsPoints(points[1], points[2])) {
            this.neighbors_[0] = t;
            t.markNeighborPointers(points[1], points[2], this);
        } else if (t.containsPoints(points[0], points[2])) {
            this.neighbors_[1] = t;
            t.markNeighborPointers(points[0], points[2], this);
        } else if (t.containsPoints(points[0], points[1])) {
            this.neighbors_[2] = t;
            t.markNeighborPointers(points[0], points[1], this);
        }
    };


    Triangle.prototype.clearNeigbors = function() {
        this.neighbors_[0] = null;
        this.neighbors_[1] = null;
        this.neighbors_[2] = null;
    };

    Triangle.prototype.clearDelunayEdges = function() {
        this.delaunay_edge[0] = false;
        this.delaunay_edge[1] = false;
        this.delaunay_edge[2] = false;
    };

    &#x2F;**
     * Returns the point clockwise to the given point.
     *&#x2F;
    Triangle.prototype.pointCW = function(p) {
        var points = this.points_;
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p === points[0]) {
            return points[2];
        } else if (p === points[1]) {
            return points[0];
        } else if (p === points[2]) {
            return points[1];
        } else {
            return null;
        }
    };

    &#x2F;**
     * Returns the point counter-clockwise to the given point.
     *&#x2F;
    Triangle.prototype.pointCCW = function(p) {
        var points = this.points_;
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p === points[0]) {
            return points[1];
        } else if (p === points[1]) {
            return points[2];
        } else if (p === points[2]) {
            return points[0];
        } else {
            return null;
        }
    };

    &#x2F;**
     * Returns the neighbor clockwise to given point.
     *&#x2F;
    Triangle.prototype.neighborCW = function(p) {
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.neighbors_[1];
        } else if (p === this.points_[1]) {
            return this.neighbors_[2];
        } else {
            return this.neighbors_[0];
        }
    };

    &#x2F;**
     * Returns the neighbor counter-clockwise to given point.
     *&#x2F;
    Triangle.prototype.neighborCCW = function(p) {
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.neighbors_[2];
        } else if (p === this.points_[1]) {
            return this.neighbors_[0];
        } else {
            return this.neighbors_[1];
        }
    };

    Triangle.prototype.getConstrainedEdgeCW = function(p) {
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.constrained_edge[1];
        } else if (p === this.points_[1]) {
            return this.constrained_edge[2];
        } else {
            return this.constrained_edge[0];
        }
    };

    Triangle.prototype.getConstrainedEdgeCCW = function(p) {
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.constrained_edge[2];
        } else if (p === this.points_[1]) {
            return this.constrained_edge[0];
        } else {
            return this.constrained_edge[1];
        }
    };

    Triangle.prototype.setConstrainedEdgeCW = function(p, ce) {
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.constrained_edge[1] = ce;
        } else if (p === this.points_[1]) {
            this.constrained_edge[2] = ce;
        } else {
            this.constrained_edge[0] = ce;
        }
    };

    Triangle.prototype.setConstrainedEdgeCCW = function(p, ce) {
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.constrained_edge[2] = ce;
        } else if (p === this.points_[1]) {
            this.constrained_edge[0] = ce;
        } else {
            this.constrained_edge[1] = ce;
        }
    };

    Triangle.prototype.getDelaunayEdgeCW = function(p) {
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.delaunay_edge[1];
        } else if (p === this.points_[1]) {
            return this.delaunay_edge[2];
        } else {
            return this.delaunay_edge[0];
        }
    };

    Triangle.prototype.getDelaunayEdgeCCW = function(p) {
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.delaunay_edge[2];
        } else if (p === this.points_[1]) {
            return this.delaunay_edge[0];
        } else {
            return this.delaunay_edge[1];
        }
    };

    Triangle.prototype.setDelaunayEdgeCW = function(p, e) {
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.delaunay_edge[1] = e;
        } else if (p === this.points_[1]) {
            this.delaunay_edge[2] = e;
        } else {
            this.delaunay_edge[0] = e;
        }
    };

    Triangle.prototype.setDelaunayEdgeCCW = function(p, e) {
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p === this.points_[0]) {
            this.delaunay_edge[2] = e;
        } else if (p === this.points_[1]) {
            this.delaunay_edge[0] = e;
        } else {
            this.delaunay_edge[1] = e;
        }
    };

    &#x2F;**
     * The neighbor across to given point.
     *&#x2F;
    Triangle.prototype.neighborAcross = function(p) {
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p === this.points_[0]) {
            return this.neighbors_[0];
        } else if (p === this.points_[1]) {
            return this.neighbors_[1];
        } else {
            return this.neighbors_[2];
        }
    };

    Triangle.prototype.oppositePoint = function(t, p) {
        var cw = t.pointCW(p);
        return this.pointCW(cw);
    };

    &#x2F;**
     * Legalize triangle by rotating clockwise around oPoint
     * @param {Point} opoint
     * @param {Point} npoint
     *&#x2F;
    Triangle.prototype.legalize = function(opoint, npoint) {
        var points = this.points_;
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (opoint === points[0]) {
            points[1] = points[0];
            points[0] = points[2];
            points[2] = npoint;
        } else if (opoint === points[1]) {
            points[2] = points[1];
            points[1] = points[0];
            points[0] = npoint;
        } else if (opoint === points[2]) {
            points[0] = points[2];
            points[2] = points[1];
            points[1] = npoint;
        } else {
            throw new Error(&#x27;poly2tri Invalid Triangle.legalize() call&#x27;);
        }
    };

    &#x2F;**
     * Returns the index of a point in the triangle. 
     * The point *must* be a reference to one of the triangle&#x27;s vertices.
     * @param {Point} p Point object
     * @returns {Number} index 0, 1 or 2
     *&#x2F;
    Triangle.prototype.index = function(p) {
        var points = this.points_;
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p === points[0]) {
            return 0;
        } else if (p === points[1]) {
            return 1;
        } else if (p === points[2]) {
            return 2;
        } else {
            throw new Error(&#x27;poly2tri Invalid Triangle.index() call&#x27;);
        }
    };

    Triangle.prototype.edgeIndex = function(p1, p2) {
        var points = this.points_;
        &#x2F;&#x2F; Here we are comparing point references, not values
        if (p1 === points[0]) {
            if (p2 === points[1]) {
                return 2;
            } else if (p2 === points[2]) {
                return 1;
            }
        } else if (p1 === points[1]) {
            if (p2 === points[2]) {
                return 0;
            } else if (p2 === points[0]) {
                return 2;
            }
        } else if (p1 === points[2]) {
            if (p2 === points[0]) {
                return 1;
            } else if (p2 === points[1]) {
                return 0;
            }
        }
        return -1;
    };

    &#x2F;**
     * Mark an edge of this triangle as constrained.&lt;br&gt;
     * This method takes either 1 parameter (an edge index or an Edge instance) or
     * 2 parameters (two Point instances defining the edge of the triangle).
     *&#x2F;
    Triangle.prototype.markConstrainedEdgeByIndex = function(index) {
        this.constrained_edge[index] = true;
    };
    Triangle.prototype.markConstrainedEdgeByEdge = function(edge) {
        this.markConstrainedEdgeByPoints(edge.p, edge.q);
    };
    Triangle.prototype.markConstrainedEdgeByPoints = function(p, q) {
        var points = this.points_;
        &#x2F;&#x2F; Here we are comparing point references, not values        
        if ((q === points[0] &amp;&amp; p === points[1]) || (q === points[1] &amp;&amp; p === points[0])) {
            this.constrained_edge[2] = true;
        } else if ((q === points[0] &amp;&amp; p === points[2]) || (q === points[2] &amp;&amp; p === points[0])) {
            this.constrained_edge[1] = true;
        } else if ((q === points[1] &amp;&amp; p === points[2]) || (q === points[2] &amp;&amp; p === points[1])) {
            this.constrained_edge[0] = true;
        }
    };

&#x2F;&#x2F; ------------------------------------------------------------------------utils
    var PI_3div4 = 3 * Math.PI &#x2F; 4;
    var PI_2 = Math.PI &#x2F; 2;
    var EPSILON = 1e-12;

    &#x2F;* 
     * Inital triangle factor, seed triangle will extend 30% of
     * PointSet width to both left and right.
     *&#x2F;
    var kAlpha = 0.3;

    var Orientation = {
        &quot;CW&quot;: 1,
        &quot;CCW&quot;: -1,
        &quot;COLLINEAR&quot;: 0
    };

    &#x2F;**
     * Forumla to calculate signed area&lt;br&gt;
     * Positive if CCW&lt;br&gt;
     * Negative if CW&lt;br&gt;
     * 0 if collinear&lt;br&gt;
     * &lt;pre&gt;
     * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
     *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
     * &lt;&#x2F;pre&gt;
     *&#x2F;
    function orient2d(pa, pb, pc) {
        var detleft = (pa.x - pc.x) * (pb.y - pc.y);
        var detright = (pa.y - pc.y) * (pb.x - pc.x);
        var val = detleft - detright;
        if (val &gt; -(EPSILON) &amp;&amp; val &lt; (EPSILON)) {
            return Orientation.COLLINEAR;
        } else if (val &gt; 0) {
            return Orientation.CCW;
        } else {
            return Orientation.CW;
        }
    }

    function inScanArea(pa, pb, pc, pd) {
        var pdx = pd.x;
        var pdy = pd.y;
        var adx = pa.x - pdx;
        var ady = pa.y - pdy;
        var bdx = pb.x - pdx;
        var bdy = pb.y - pdy;

        var adxbdy = adx * bdy;
        var bdxady = bdx * ady;
        var oabd = adxbdy - bdxady;

        if (oabd &lt;= (EPSILON)) {
            return false;
        }

        var cdx = pc.x - pdx;
        var cdy = pc.y - pdy;

        var cdxady = cdx * ady;
        var adxcdy = adx * cdy;
        var ocad = cdxady - adxcdy;

        if (ocad &lt;= (EPSILON)) {
            return false;
        }

        return true;
    }

&#x2F;&#x2F; ---------------------------------------------------------------AdvancingFront
    &#x2F;**
     * Advancing front node
     * @param {Point} p any &quot;Point like&quot; object with {x,y} (duck typing)
     * @param {Triangle} t triangle (optionnal)
     *&#x2F;
    var Node = function(p, t) {
        this.point = p;
        this.triangle = t || null;

        this.next = null; &#x2F;&#x2F; Node
        this.prev = null; &#x2F;&#x2F; Node

        this.value = p.x;
    };

    var AdvancingFront = function(head, tail) {
        this.head_ = head; &#x2F;&#x2F; Node
        this.tail_ = tail; &#x2F;&#x2F; Node
        this.search_node_ = head; &#x2F;&#x2F; Node
    };

    AdvancingFront.prototype.head = function() {
        return this.head_;
    };

    AdvancingFront.prototype.setHead = function(node) {
        this.head_ = node;
    };

    AdvancingFront.prototype.tail = function() {
        return this.tail_;
    };

    AdvancingFront.prototype.setTail = function(node) {
        this.tail_ = node;
    };

    AdvancingFront.prototype.search = function() {
        return this.search_node_;
    };

    AdvancingFront.prototype.setSearch = function(node) {
        this.search_node_ = node;
    };

    AdvancingFront.prototype.findSearchNode = function(&#x2F;*x*&#x2F;) {
        &#x2F;&#x2F; TODO: implement BST index
        return this.search_node_;
    };

    AdvancingFront.prototype.locateNode = function(x) {
        var node = this.search_node_;

        &#x2F;* jshint boss:true *&#x2F;
        if (x &lt; node.value) {
            while (node = node.prev) {
                if (x &gt;= node.value) {
                    this.search_node_ = node;
                    return node;
                }
            }
        } else {
            while (node = node.next) {
                if (x &lt; node.value) {
                    this.search_node_ = node.prev;
                    return node.prev;
                }
            }
        }
        return null;
    };

    AdvancingFront.prototype.locatePoint = function(point) {
        var px = point.x;
        var node = this.findSearchNode(px);
        var nx = node.point.x;

        if (px === nx) {
            &#x2F;&#x2F; Here we are comparing point references, not values
            if (point !== node.point) {
                &#x2F;&#x2F; We might have two nodes with same x value for a short time
                if (point === node.prev.point) {
                    node = node.prev;
                } else if (point === node.next.point) {
                    node = node.next;
                } else {
                    throw new Error(&#x27;poly2tri Invalid AdvancingFront.locatePoint() call&#x27;);
                }
            }
        } else if (px &lt; nx) {
            &#x2F;* jshint boss:true *&#x2F;
            while (node = node.prev) {
                if (point === node.point) {
                    break;
                }
            }
        } else {
            while (node = node.next) {
                if (point === node.point) {
                    break;
                }
            }
        }

        if (node) {
            this.search_node_ = node;
        }
        return node;
    };

&#x2F;&#x2F; ------------------------------------------------------------------------Basin
    var Basin = function() {
        this.left_node = null; &#x2F;&#x2F; Node
        this.bottom_node = null; &#x2F;&#x2F; Node
        this.right_node = null; &#x2F;&#x2F; Node
        this.width = 0.0; &#x2F;&#x2F; number
        this.left_highest = false;
    };

    Basin.prototype.clear = function() {
        this.left_node = null;
        this.bottom_node = null;
        this.right_node = null;
        this.width = 0.0;
        this.left_highest = false;
    };

&#x2F;&#x2F; --------------------------------------------------------------------EdgeEvent
    var EdgeEvent = function() {
        this.constrained_edge = null; &#x2F;&#x2F; Edge
        this.right = false;
    };

&#x2F;&#x2F; ----------------------------------------------------SweepContext (public API)
    &#x2F;**
     * Constructor for the triangulation context.
     * It accepts a simple polyline, which defines the constrained edges.
     * Possible options are:
     *    cloneArrays:  if true, do a shallow copy of the Array parameters 
     *                  (contour, holes). Points inside arrays are never copied.
     *                  Default is false : keep a reference to the array arguments,
     *                  who will be modified in place.
     * @param {Array} contour  array of &quot;Point like&quot; objects with {x,y} (duck typing)
     * @param {Object} options  constructor options
     *&#x2F;
    var SweepContext = function(contour, options) {
        options = options || {};
        this.triangles_ = [];
        this.map_ = [];
        this.points_ = (options.cloneArrays ? contour.slice(0) : contour);
        this.edge_list = [];

        &#x2F;&#x2F; Bounding box of all points. Computed at the start of the triangulation, 
        &#x2F;&#x2F; it is stored in case it is needed by the caller.
        this.pmin_ = this.pmax_ = null;

        &#x2F;&#x2F; Advancing front
        this.front_ = null; &#x2F;&#x2F; AdvancingFront
        &#x2F;&#x2F; head point used with advancing front
        this.head_ = null; &#x2F;&#x2F; Point
        &#x2F;&#x2F; tail point used with advancing front
        this.tail_ = null; &#x2F;&#x2F; Point

        this.af_head_ = null; &#x2F;&#x2F; Node
        this.af_middle_ = null; &#x2F;&#x2F; Node
        this.af_tail_ = null; &#x2F;&#x2F; Node

        this.basin = new Basin();
        this.edge_event = new EdgeEvent();

        this.initEdges(this.points_);
    };


    &#x2F;**
     * Add a hole to the constraints
     * @param {Array} polyline  array of &quot;Point like&quot; objects with {x,y} (duck typing)
     *&#x2F;
    SweepContext.prototype.addHole = function(polyline) {
        this.initEdges(polyline);
        var i, len = polyline.length;
        for (i = 0; i &lt; len; i++) {
            this.points_.push(polyline[i]);
        }
        return this; &#x2F;&#x2F; for chaining
    };
    &#x2F;&#x2F; Backward compatibility
    SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


    &#x2F;**
     * Add a Steiner point to the constraints
     * @param {Point} point     any &quot;Point like&quot; object with {x,y} (duck typing)
     *&#x2F;
    SweepContext.prototype.addPoint = function(point) {
        this.points_.push(point);
        return this; &#x2F;&#x2F; for chaining
    };
    &#x2F;&#x2F; Backward compatibility
    SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


    &#x2F;**
     * Add several Steiner points to the constraints
     * @param {array&lt;Point&gt;} points     array of &quot;Point like&quot; object with {x,y} 
     *&#x2F;
    &#x2F;&#x2F; Method added in the JavaScript version (was not present in the c++ version)
    SweepContext.prototype.addPoints = function(points) {
        this.points_ = this.points_.concat(points);
        return this; &#x2F;&#x2F; for chaining
    };


    &#x2F;**
     * Triangulate the polygon with holes and Steiner points.
     *&#x2F;
    &#x2F;&#x2F; Shortcut method for Sweep.triangulate(SweepContext).
    &#x2F;&#x2F; Method added in the JavaScript version (was not present in the c++ version)
    SweepContext.prototype.triangulate = function() {
        Sweep.triangulate(this);
        return this; &#x2F;&#x2F; for chaining
    };


    &#x2F;**
     * Get the bounding box of the provided constraints (contour, holes and 
     * Steinter points). Warning : these values are not available if the triangulation 
     * has not been done yet.
     * @returns {Object} object with &#x27;min&#x27; and &#x27;max&#x27; Point
     *&#x2F;
    &#x2F;&#x2F; Method added in the JavaScript version (was not present in the c++ version)
    SweepContext.prototype.getBoundingBox = function() {
        return {min: this.pmin_, max: this.pmax_};
    };

    &#x2F;**
     * Get result of triangulation
     * @returns {array&lt;Triangle&gt;}   array of triangles
     *&#x2F;
    SweepContext.prototype.getTriangles = function() {
        return this.triangles_;
    };
    &#x2F;&#x2F; Backward compatibility
    SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;


&#x2F;&#x2F; ---------------------------------------------------SweepContext (private API)

    SweepContext.prototype.front = function() {
        return this.front_;
    };

    SweepContext.prototype.pointCount = function() {
        return this.points_.length;
    };

    SweepContext.prototype.head = function() {
        return this.head_;
    };

    SweepContext.prototype.setHead = function(p1) {
        this.head_ = p1;
    };

    SweepContext.prototype.tail = function() {
        return this.tail_;
    };

    SweepContext.prototype.setTail = function(p1) {
        this.tail_ = p1;
    };

    SweepContext.prototype.getMap = function() {
        return this.map_;
    };

    SweepContext.prototype.initTriangulation = function() {
        var xmax = this.points_[0].x;
        var xmin = this.points_[0].x;
        var ymax = this.points_[0].y;
        var ymin = this.points_[0].y;

        &#x2F;&#x2F; Calculate bounds
        var i, len = this.points_.length;
        for (i = 1; i &lt; len; i++) {
            var p = this.points_[i];
            &#x2F;* jshint expr:true *&#x2F;
            (p.x &gt; xmax) &amp;&amp; (xmax = p.x);
            (p.x &lt; xmin) &amp;&amp; (xmin = p.x);
            (p.y &gt; ymax) &amp;&amp; (ymax = p.y);
            (p.y &lt; ymin) &amp;&amp; (ymin = p.y);
        }
        this.pmin_ = new Point(xmin, ymin);
        this.pmax_ = new Point(xmax, ymax);

        var dx = kAlpha * (xmax - xmin);
        var dy = kAlpha * (ymax - ymin);
        this.head_ = new Point(xmax + dx, ymin - dy);
        this.tail_ = new Point(xmin - dx, ymin - dy);

        &#x2F;&#x2F; Sort points along y-axis
        this.points_.sort(Point.compare);
    };

    SweepContext.prototype.initEdges = function(polyline) {
        var i, len = polyline.length;
        for (i = 0; i &lt; len; ++i) {
            this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
        }
    };

    SweepContext.prototype.getPoint = function(index) {
        return this.points_[index];
    };

    SweepContext.prototype.addToMap = function(triangle) {
        this.map_.push(triangle);
    };

    SweepContext.prototype.locateNode = function(point) {
        return this.front_.locateNode(point.x);
    };

    SweepContext.prototype.createAdvancingFront = function() {
        var head;
        var middle;
        var tail;
        &#x2F;&#x2F; Initial triangle
        var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

        this.map_.push(triangle);

        head = new Node(triangle.getPoint(1), triangle);
        middle = new Node(triangle.getPoint(0), triangle);
        tail = new Node(triangle.getPoint(2));

        this.front_ = new AdvancingFront(head, tail);

        head.next = middle;
        middle.next = tail;
        middle.prev = head;
        tail.prev = middle;
    };

    SweepContext.prototype.removeNode = function(node) {
        &#x2F;&#x2F; do nothing
        &#x2F;* jshint unused:false *&#x2F;
    };

    SweepContext.prototype.mapTriangleToNodes = function(t) {
        for (var i = 0; i &lt; 3; ++i) {
            if (! t.getNeighbor(i)) {
                var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
                if (n) {
                    n.triangle = t;
                }
            }
        }
    };

    SweepContext.prototype.removeFromMap = function(triangle) {
        var i, map = this.map_, len = map.length;
        for (i = 0; i &lt; len; i++) {
            if (map[i] === triangle) {
                map.splice(i, 1);
                break;
            }
        }
    };

    &#x2F;**
     * Do a depth first traversal to collect triangles
     * @param {Triangle} triangle start
     *&#x2F;
    SweepContext.prototype.meshClean = function(triangle) {
        &#x2F;&#x2F; New implementation avoids recursive calls and use a loop instead.
        &#x2F;&#x2F; Cf. issues # 57, 65 and 69.
        var triangles = [triangle], t, i;
        &#x2F;* jshint boss:true *&#x2F;
        while (t = triangles.pop()) {
            if (!t.isInterior()) {
                t.setInterior(true);
                this.triangles_.push(t);
                for (i = 0; i &lt; 3; i++) {
                    if (!t.constrained_edge[i]) {
                        triangles.push(t.getNeighbor(i));
                    }
                }
            }
        }
    };

&#x2F;&#x2F; ------------------------------------------------------------------------Sweep

    &#x2F;**
     * The &#x27;Sweep&#x27; object is present in order to keep this JavaScript version 
     * as close as possible to the reference C++ version, even though almost
     * all Sweep methods could be declared as members of the SweepContext object.
     *&#x2F;
    var Sweep = {};


    &#x2F;**
     * Triangulate the polygon with holes and Steiner points.
     * @param   tcx SweepContext object.
     *&#x2F;
    Sweep.triangulate = function(tcx) {
        tcx.initTriangulation();
        tcx.createAdvancingFront();
        &#x2F;&#x2F; Sweep points; build mesh
        Sweep.sweepPoints(tcx);
        &#x2F;&#x2F; Clean up
        Sweep.finalizationPolygon(tcx);
    };

    Sweep.sweepPoints = function(tcx) {
        var i, len = tcx.pointCount();
        for (i = 1; i &lt; len; ++i) {
            var point = tcx.getPoint(i);
            var node = Sweep.pointEvent(tcx, point);
            var edges = point._p2t_edge_list;
            for (var j = 0; edges &amp;&amp; j &lt; edges.length; ++j) {
                Sweep.edgeEventByEdge(tcx, edges[j], node);
            }
        }
    };

    Sweep.finalizationPolygon = function(tcx) {
        &#x2F;&#x2F; Get an Internal triangle to start with
        var t = tcx.front().head().next.triangle;
        var p = tcx.front().head().next.point;
        while (!t.getConstrainedEdgeCW(p)) {
            t = t.neighborCCW(p);
        }

        &#x2F;&#x2F; Collect interior triangles constrained by edges
        tcx.meshClean(t);
    };

    &#x2F;**
     * Find closes node to the left of the new point and
     * create a new triangle. If needed new holes and basins
     * will be filled to.
     *&#x2F;
    Sweep.pointEvent = function(tcx, point) {
        var node = tcx.locateNode(point);
        var new_node = Sweep.newFrontTriangle(tcx, point, node);

        &#x2F;&#x2F; Only need to check +epsilon since point never have smaller
        &#x2F;&#x2F; x value than node due to how we fetch nodes from the front
        if (point.x &lt;= node.point.x + (EPSILON)) {
            Sweep.fill(tcx, node);
        }

        &#x2F;&#x2F;tcx.AddNode(new_node);

        Sweep.fillAdvancingFront(tcx, new_node);
        return new_node;
    };

    Sweep.edgeEventByEdge = function(tcx, edge, node) {
        tcx.edge_event.constrained_edge = edge;
        tcx.edge_event.right = (edge.p.x &gt; edge.q.x);

        if (Sweep.isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
            return;
        }

        &#x2F;&#x2F; For now we will do all needed filling
        &#x2F;&#x2F; TODO: integrate with flip process might give some better performance
        &#x2F;&#x2F;       but for now this avoid the issue with cases that needs both flips and fills
        Sweep.fillEdgeEvent(tcx, edge, node);
        Sweep.edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
    };

    Sweep.edgeEventByPoints = function(tcx, ep, eq, triangle, point) {
        if (Sweep.isEdgeSideOfTriangle(triangle, ep, eq)) {
            return;
        }

        var p1 = triangle.pointCCW(point);
        var o1 = orient2d(eq, p1, ep);
        if (o1 === Orientation.COLLINEAR) {
            &#x2F;&#x2F; TODO integrate here changes from C++ version
            throw new PointError(&#x27;poly2tri EdgeEvent: Collinear not supported!&#x27;, [eq, p1, ep]);
        }

        var p2 = triangle.pointCW(point);
        var o2 = orient2d(eq, p2, ep);
        if (o2 === Orientation.COLLINEAR) {
            &#x2F;&#x2F; TODO integrate here changes from C++ version
            throw new PointError(&#x27;poly2tri EdgeEvent: Collinear not supported!&#x27;, [eq, p2, ep]);
        }

        if (o1 === o2) {
            &#x2F;&#x2F; Need to decide if we are rotating CW or CCW to get to a triangle
            &#x2F;&#x2F; that will cross edge
            if (o1 === Orientation.CW) {
                triangle = triangle.neighborCCW(point);
            } else {
                triangle = triangle.neighborCW(point);
            }
            Sweep.edgeEventByPoints(tcx, ep, eq, triangle, point);
        } else {
            &#x2F;&#x2F; This triangle crosses constraint so lets flippin start!
            Sweep.flipEdgeEvent(tcx, ep, eq, triangle, point);
        }
    };

    Sweep.isEdgeSideOfTriangle = function(triangle, ep, eq) {
        var index = triangle.edgeIndex(ep, eq);
        if (index !== -1) {
            triangle.markConstrainedEdgeByIndex(index);
            var t = triangle.getNeighbor(index);
            if (t) {
                t.markConstrainedEdgeByPoints(ep, eq);
            }
            return true;
        }
        return false;
    };

    Sweep.newFrontTriangle = function(tcx, point, node) {
        var triangle = new Triangle(point, node.point, node.next.point);

        triangle.markNeighbor(node.triangle);
        tcx.addToMap(triangle);

        var new_node = new Node(point);
        new_node.next = node.next;
        new_node.prev = node;
        node.next.prev = new_node;
        node.next = new_node;

        if (!Sweep.legalize(tcx, triangle)) {
            tcx.mapTriangleToNodes(triangle);
        }

        return new_node;
    };

    &#x2F;**
     * Adds a triangle to the advancing front to fill a hole.
     * @param tcx
     * @param node - middle node, that is the bottom of the hole
     *&#x2F;
    Sweep.fill = function(tcx, node) {
        var triangle = new Triangle(node.prev.point, node.point, node.next.point);

        &#x2F;&#x2F; TODO: should copy the constrained_edge value from neighbor triangles
        &#x2F;&#x2F;       for now constrained_edge values are copied during the legalize
        triangle.markNeighbor(node.prev.triangle);
        triangle.markNeighbor(node.triangle);

        tcx.addToMap(triangle);

        &#x2F;&#x2F; Update the advancing front
        node.prev.next = node.next;
        node.next.prev = node.prev;


        &#x2F;&#x2F; If it was legalized the triangle has already been mapped
        if (!Sweep.legalize(tcx, triangle)) {
            tcx.mapTriangleToNodes(triangle);
        }

        &#x2F;&#x2F;tcx.removeNode(node);
    };

    &#x2F;**
     * Fills holes in the Advancing Front
     *&#x2F;
    Sweep.fillAdvancingFront = function(tcx, n) {
        &#x2F;&#x2F; Fill right holes
        var node = n.next;
        var angle;
        while (node.next) {
            angle = Sweep.holeAngle(node);
            if (angle &gt; PI_2 || angle &lt; -(PI_2)) {
                break;
            }
            Sweep.fill(tcx, node);
            node = node.next;
        }

        &#x2F;&#x2F; Fill left holes
        node = n.prev;
        while (node.prev) {
            angle = Sweep.holeAngle(node);
            if (angle &gt; PI_2 || angle &lt; -(PI_2)) {
                break;
            }
            Sweep.fill(tcx, node);
            node = node.prev;
        }

        &#x2F;&#x2F; Fill right basins
        if (n.next &amp;&amp; n.next.next) {
            angle = Sweep.basinAngle(n);
            if (angle &lt; PI_3div4) {
                Sweep.fillBasin(tcx, n);
            }
        }
    };

    Sweep.basinAngle = function(node) {
        var ax = node.point.x - node.next.next.point.x;
        var ay = node.point.y - node.next.next.point.y;
        return Math.atan2(ay, ax);
    };

    &#x2F;**
     *
     * @param node - middle node
     * @return the angle between 3 front nodes
     *&#x2F;
    Sweep.holeAngle = function(node) {
        &#x2F;* Complex plane
         * ab = cosA +i*sinA
         * ab = (ax + ay*i)(bx + by*i) = (ax*bx + ay*by) + i(ax*by-ay*bx)
         * atan2(y,x) computes the principal value of the argument function
         * applied to the complex number x+iy
         * Where x = ax*bx + ay*by
         *       y = ax*by - ay*bx
         *&#x2F;
        var ax = node.next.point.x - node.point.x;
        var ay = node.next.point.y - node.point.y;
        var bx = node.prev.point.x - node.point.x;
        var by = node.prev.point.y - node.point.y;
        return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
    };

    &#x2F;**
     * Returns true if triangle was legalized
     *&#x2F;
    Sweep.legalize = function(tcx, t) {
        &#x2F;&#x2F; To legalize a triangle we start by finding if any of the three edges
        &#x2F;&#x2F; violate the Delaunay condition
        for (var i = 0; i &lt; 3; ++i) {
            if (t.delaunay_edge[i]) {
                continue;
            }
            var ot = t.getNeighbor(i);
            if (ot) {
                var p = t.getPoint(i);
                var op = ot.oppositePoint(t, p);
                var oi = ot.index(op);

                &#x2F;&#x2F; If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
                &#x2F;&#x2F; then we should not try to legalize
                if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
                    t.constrained_edge[i] = ot.constrained_edge[oi];
                    continue;
                }

                var inside = Sweep.inCircle(p, t.pointCCW(p), t.pointCW(p), op);
                if (inside) {
                    &#x2F;&#x2F; Lets mark this shared edge as Delaunay
                    t.delaunay_edge[i] = true;
                    ot.delaunay_edge[oi] = true;

                    &#x2F;&#x2F; Lets rotate shared edge one vertex CW to legalize it
                    Sweep.rotateTrianglePair(t, p, ot, op);

                    &#x2F;&#x2F; We now got one valid Delaunay Edge shared by two triangles
                    &#x2F;&#x2F; This gives us 4 new edges to check for Delaunay

                    &#x2F;&#x2F; Make sure that triangle to node mapping is done only one time for a specific triangle
                    var not_legalized = !Sweep.legalize(tcx, t);
                    if (not_legalized) {
                        tcx.mapTriangleToNodes(t);
                    }

                    not_legalized = !Sweep.legalize(tcx, ot);
                    if (not_legalized) {
                        tcx.mapTriangleToNodes(ot);
                    }
                    &#x2F;&#x2F; Reset the Delaunay edges, since they only are valid Delaunay edges
                    &#x2F;&#x2F; until we add a new triangle or point.
                    &#x2F;&#x2F; XXX: need to think about this. Can these edges be tried after we
                    &#x2F;&#x2F;      return to previous recursive level?
                    t.delaunay_edge[i] = false;
                    ot.delaunay_edge[oi] = false;

                    &#x2F;&#x2F; If triangle have been legalized no need to check the other edges since
                    &#x2F;&#x2F; the recursive legalization will handles those so we can end here.
                    return true;
                }
            }
        }
        return false;
    };

    &#x2F;**
     * &lt;b&gt;Requirement&lt;&#x2F;b&gt;:&lt;br&gt;
     * 1. a,b and c form a triangle.&lt;br&gt;
     * 2. a and d is know to be on opposite side of bc&lt;br&gt;
     * &lt;pre&gt;
     *                a
     *                +
     *               &#x2F; \
     *              &#x2F;   \
     *            b&#x2F;     \c
     *            +-------+
     *           &#x2F;    d    \
     *          &#x2F;           \
     * &lt;&#x2F;pre&gt;
     * &lt;b&gt;Fact&lt;&#x2F;b&gt;: d has to be in area B to have a chance to be inside the circle formed by
     *  a,b and c&lt;br&gt;
     *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW&lt;br&gt;
     *  This preknowledge gives us a way to optimize the incircle test
     * @param pa - triangle point, opposite d
     * @param pb - triangle point
     * @param pc - triangle point
     * @param pd - point opposite a
     * @return true if d is inside circle, false if on circle edge
     *&#x2F;
    Sweep.inCircle = function(pa, pb, pc, pd) {
        var adx = pa.x - pd.x;
        var ady = pa.y - pd.y;
        var bdx = pb.x - pd.x;
        var bdy = pb.y - pd.y;

        var adxbdy = adx * bdy;
        var bdxady = bdx * ady;
        var oabd = adxbdy - bdxady;
        if (oabd &lt;= 0) {
            return false;
        }

        var cdx = pc.x - pd.x;
        var cdy = pc.y - pd.y;

        var cdxady = cdx * ady;
        var adxcdy = adx * cdy;
        var ocad = cdxady - adxcdy;
        if (ocad &lt;= 0) {
            return false;
        }

        var bdxcdy = bdx * cdy;
        var cdxbdy = cdx * bdy;

        var alift = adx * adx + ady * ady;
        var blift = bdx * bdx + bdy * bdy;
        var clift = cdx * cdx + cdy * cdy;

        var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
        return det &gt; 0;
    };

    &#x2F;**
     * Rotates a triangle pair one vertex CW
     *&lt;pre&gt;
     *       n2                    n2
     *  P +-----+             P +-----+
     *    | t  &#x2F;|               |\  t |
     *    |   &#x2F; |               | \   |
     *  n1|  &#x2F;  |n3           n1|  \  |n3
     *    | &#x2F;   |    after CW   |   \ |
     *    |&#x2F; oT |               | oT \|
     *    +-----+ oP            +-----+
     *       n4                    n4
     * &lt;&#x2F;pre&gt;
     *&#x2F;
    Sweep.rotateTrianglePair = function(t, p, ot, op) {
        var n1, n2, n3, n4;
        n1 = t.neighborCCW(p);
        n2 = t.neighborCW(p);
        n3 = ot.neighborCCW(op);
        n4 = ot.neighborCW(op);

        var ce1, ce2, ce3, ce4;
        ce1 = t.getConstrainedEdgeCCW(p);
        ce2 = t.getConstrainedEdgeCW(p);
        ce3 = ot.getConstrainedEdgeCCW(op);
        ce4 = ot.getConstrainedEdgeCW(op);

        var de1, de2, de3, de4;
        de1 = t.getDelaunayEdgeCCW(p);
        de2 = t.getDelaunayEdgeCW(p);
        de3 = ot.getDelaunayEdgeCCW(op);
        de4 = ot.getDelaunayEdgeCW(op);

        t.legalize(p, op);
        ot.legalize(op, p);

        &#x2F;&#x2F; Remap delaunay_edge
        ot.setDelaunayEdgeCCW(p, de1);
        t.setDelaunayEdgeCW(p, de2);
        t.setDelaunayEdgeCCW(op, de3);
        ot.setDelaunayEdgeCW(op, de4);

        &#x2F;&#x2F; Remap constrained_edge
        ot.setConstrainedEdgeCCW(p, ce1);
        t.setConstrainedEdgeCW(p, ce2);
        t.setConstrainedEdgeCCW(op, ce3);
        ot.setConstrainedEdgeCW(op, ce4);

        &#x2F;&#x2F; Remap neighbors
        &#x2F;&#x2F; XXX: might optimize the markNeighbor by keeping track of
        &#x2F;&#x2F;      what side should be assigned to what neighbor after the
        &#x2F;&#x2F;      rotation. Now mark neighbor does lots of testing to find
        &#x2F;&#x2F;      the right side.
        t.clearNeigbors();
        ot.clearNeigbors();
        if (n1) {
            ot.markNeighbor(n1);
        }
        if (n2) {
            t.markNeighbor(n2);
        }
        if (n3) {
            t.markNeighbor(n3);
        }
        if (n4) {
            ot.markNeighbor(n4);
        }
        t.markNeighbor(ot);
    };

    &#x2F;**
     * Fills a basin that has formed on the Advancing Front to the right
     * of given node.&lt;br&gt;
     * First we decide a left,bottom and right node that forms the
     * boundaries of the basin. Then we do a reqursive fill.
     *
     * @param tcx
     * @param node - starting node, this or next node will be left node
     *&#x2F;
    Sweep.fillBasin = function(tcx, node) {
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
            tcx.basin.left_node = node.next.next;
        } else {
            tcx.basin.left_node = node.next;
        }

        &#x2F;&#x2F; Find the bottom and right node
        tcx.basin.bottom_node = tcx.basin.left_node;
        while (tcx.basin.bottom_node.next &amp;&amp; tcx.basin.bottom_node.point.y &gt;= tcx.basin.bottom_node.next.point.y) {
            tcx.basin.bottom_node = tcx.basin.bottom_node.next;
        }
        if (tcx.basin.bottom_node === tcx.basin.left_node) {
            &#x2F;&#x2F; No valid basin
            return;
        }

        tcx.basin.right_node = tcx.basin.bottom_node;
        while (tcx.basin.right_node.next &amp;&amp; tcx.basin.right_node.point.y &lt; tcx.basin.right_node.next.point.y) {
            tcx.basin.right_node = tcx.basin.right_node.next;
        }
        if (tcx.basin.right_node === tcx.basin.bottom_node) {
            &#x2F;&#x2F; No valid basins
            return;
        }

        tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
        tcx.basin.left_highest = tcx.basin.left_node.point.y &gt; tcx.basin.right_node.point.y;

        Sweep.fillBasinReq(tcx, tcx.basin.bottom_node);
    };

    &#x2F;**
     * Recursive algorithm to fill a Basin with triangles
     *
     * @param tcx
     * @param node - bottom_node
     *&#x2F;
    Sweep.fillBasinReq = function(tcx, node) {
        &#x2F;&#x2F; if shallow stop filling
        if (Sweep.isShallow(tcx, node)) {
            return;
        }

        Sweep.fill(tcx, node);

        var o;
        if (node.prev === tcx.basin.left_node &amp;&amp; node.next === tcx.basin.right_node) {
            return;
        } else if (node.prev === tcx.basin.left_node) {
            o = orient2d(node.point, node.next.point, node.next.next.point);
            if (o === Orientation.CW) {
                return;
            }
            node = node.next;
        } else if (node.next === tcx.basin.right_node) {
            o = orient2d(node.point, node.prev.point, node.prev.prev.point);
            if (o === Orientation.CCW) {
                return;
            }
            node = node.prev;
        } else {
            &#x2F;&#x2F; Continue with the neighbor node with lowest Y value
            if (node.prev.point.y &lt; node.next.point.y) {
                node = node.prev;
            } else {
                node = node.next;
            }
        }

        Sweep.fillBasinReq(tcx, node);
    };

    Sweep.isShallow = function(tcx, node) {
        var height;
        if (tcx.basin.left_highest) {
            height = tcx.basin.left_node.point.y - node.point.y;
        } else {
            height = tcx.basin.right_node.point.y - node.point.y;
        }

        &#x2F;&#x2F; if shallow stop filling
        if (tcx.basin.width &gt; height) {
            return true;
        }
        return false;
    };

    Sweep.fillEdgeEvent = function(tcx, edge, node) {
        if (tcx.edge_event.right) {
            Sweep.fillRightAboveEdgeEvent(tcx, edge, node);
        } else {
            Sweep.fillLeftAboveEdgeEvent(tcx, edge, node);
        }
    };

    Sweep.fillRightAboveEdgeEvent = function(tcx, edge, node) {
        while (node.next.point.x &lt; edge.p.x) {
            &#x2F;&#x2F; Check if next node is below the edge
            if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
                Sweep.fillRightBelowEdgeEvent(tcx, edge, node);
            } else {
                node = node.next;
            }
        }
    };

    Sweep.fillRightBelowEdgeEvent = function(tcx, edge, node) {
        if (node.point.x &lt; edge.p.x) {
            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                &#x2F;&#x2F; Concave
                Sweep.fillRightConcaveEdgeEvent(tcx, edge, node);
            } else {
                &#x2F;&#x2F; Convex
                Sweep.fillRightConvexEdgeEvent(tcx, edge, node);
                &#x2F;&#x2F; Retry this one
                Sweep.fillRightBelowEdgeEvent(tcx, edge, node);
            }
        }
    };

    Sweep.fillRightConcaveEdgeEvent = function(tcx, edge, node) {
        Sweep.fill(tcx, node.next);
        if (node.next.point !== edge.p) {
            &#x2F;&#x2F; Next above or below edge?
            if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
                &#x2F;&#x2F; Below
                if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                    &#x2F;&#x2F; Next is concave
                    Sweep.fillRightConcaveEdgeEvent(tcx, edge, node);
                } else {
                    &#x2F;&#x2F; Next is convex
                    &#x2F;* jshint noempty:false *&#x2F;
                }
            }
        }
    };

    Sweep.fillRightConvexEdgeEvent = function(tcx, edge, node) {
        &#x2F;&#x2F; Next concave or convex?
        if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
            &#x2F;&#x2F; Concave
            Sweep.fillRightConcaveEdgeEvent(tcx, edge, node.next);
        } else {
            &#x2F;&#x2F; Convex
            &#x2F;&#x2F; Next above or below edge?
            if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
                &#x2F;&#x2F; Below
                Sweep.fillRightConvexEdgeEvent(tcx, edge, node.next);
            } else {
                &#x2F;&#x2F; Above
                &#x2F;* jshint noempty:false *&#x2F;
            }
        }
    };

    Sweep.fillLeftAboveEdgeEvent = function(tcx, edge, node) {
        while (node.prev.point.x &gt; edge.p.x) {
            &#x2F;&#x2F; Check if next node is below the edge
            if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
                Sweep.fillLeftBelowEdgeEvent(tcx, edge, node);
            } else {
                node = node.prev;
            }
        }
    };

    Sweep.fillLeftBelowEdgeEvent = function(tcx, edge, node) {
        if (node.point.x &gt; edge.p.x) {
            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                &#x2F;&#x2F; Concave
                Sweep.fillLeftConcaveEdgeEvent(tcx, edge, node);
            } else {
                &#x2F;&#x2F; Convex
                Sweep.fillLeftConvexEdgeEvent(tcx, edge, node);
                &#x2F;&#x2F; Retry this one
                Sweep.fillLeftBelowEdgeEvent(tcx, edge, node);
            }
        }
    };

    Sweep.fillLeftConvexEdgeEvent = function(tcx, edge, node) {
        &#x2F;&#x2F; Next concave or convex?
        if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
            &#x2F;&#x2F; Concave
            Sweep.fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
        } else {
            &#x2F;&#x2F; Convex
            &#x2F;&#x2F; Next above or below edge?
            if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
                &#x2F;&#x2F; Below
                Sweep.fillLeftConvexEdgeEvent(tcx, edge, node.prev);
            } else {
                &#x2F;&#x2F; Above
                &#x2F;* jshint noempty:false *&#x2F;
            }
        }
    };

    Sweep.fillLeftConcaveEdgeEvent = function(tcx, edge, node) {
        Sweep.fill(tcx, node.prev);
        if (node.prev.point !== edge.p) {
            &#x2F;&#x2F; Next above or below edge?
            if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
                &#x2F;&#x2F; Below
                if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                    &#x2F;&#x2F; Next is concave
                    Sweep.fillLeftConcaveEdgeEvent(tcx, edge, node);
                } else {
                    &#x2F;&#x2F; Next is convex
                    &#x2F;* jshint noempty:false *&#x2F;
                }
            }
        }
    };

    Sweep.flipEdgeEvent = function(tcx, ep, eq, t, p) {
        var ot = t.neighborAcross(p);
        if (!ot) {
            &#x2F;&#x2F; If we want to integrate the fillEdgeEvent do it here
            &#x2F;&#x2F; With current implementation we should never get here
            throw new Error(&#x27;poly2tri [BUG:FIXME] FLIP failed due to missing triangle!&#x27;);
        }
        var op = ot.oppositePoint(t, p);

        if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
            &#x2F;&#x2F; Lets rotate shared edge one vertex CW
            Sweep.rotateTrianglePair(t, p, ot, op);
            tcx.mapTriangleToNodes(t);
            tcx.mapTriangleToNodes(ot);

            &#x2F;&#x2F; XXX: in the original C++ code for the next 2 lines, we are
            &#x2F;&#x2F; comparing point values (and not pointers). In this JavaScript
            &#x2F;&#x2F; code, we are comparing point references (pointers). This works
            &#x2F;&#x2F; because we can&#x27;t have 2 different points with the same values.
            &#x2F;&#x2F; But to be really equivalent, we should use &quot;Point.equals&quot; here.
            if (p === eq &amp;&amp; op === ep) {
                if (eq === tcx.edge_event.constrained_edge.q &amp;&amp; ep === tcx.edge_event.constrained_edge.p) {
                    t.markConstrainedEdgeByPoints(ep, eq);
                    ot.markConstrainedEdgeByPoints(ep, eq);
                    Sweep.legalize(tcx, t);
                    Sweep.legalize(tcx, ot);
                } else {
                    &#x2F;&#x2F; XXX: I think one of the triangles should be legalized here?
                    &#x2F;* jshint noempty:false *&#x2F;
                }
            } else {
                var o = orient2d(eq, op, ep);
                t = Sweep.nextFlipTriangle(tcx, o, t, ot, p, op);
                Sweep.flipEdgeEvent(tcx, ep, eq, t, p);
            }
        } else {
            var newP = Sweep.nextFlipPoint(ep, eq, ot, op);
            Sweep.flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
            Sweep.edgeEventByPoints(tcx, ep, eq, t, p);
        }
    };

    Sweep.nextFlipTriangle = function(tcx, o, t, ot, p, op) {
        var edge_index;
        if (o === Orientation.CCW) {
            &#x2F;&#x2F; ot is not crossing edge after flip
            edge_index = ot.edgeIndex(p, op);
            ot.delaunay_edge[edge_index] = true;
            Sweep.legalize(tcx, ot);
            ot.clearDelunayEdges();
            return t;
        }

        &#x2F;&#x2F; t is not crossing edge after flip
        edge_index = t.edgeIndex(p, op);

        t.delaunay_edge[edge_index] = true;
        Sweep.legalize(tcx, t);
        t.clearDelunayEdges();
        return ot;
    };

    Sweep.nextFlipPoint = function(ep, eq, ot, op) {
        var o2d = orient2d(eq, op, ep);
        if (o2d === Orientation.CW) {
            &#x2F;&#x2F; Right
            return ot.pointCCW(op);
        } else if (o2d === Orientation.CCW) {
            &#x2F;&#x2F; Left
            return ot.pointCW(op);
        } else {
            throw new PointError(&quot;poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!&quot;, [eq, op, ep]);
        }
    };

    Sweep.flipScanEdgeEvent = function(tcx, ep, eq, flip_triangle, t, p) {
        var ot = t.neighborAcross(p);
        if (!ot) {
            &#x2F;&#x2F; If we want to integrate the fillEdgeEvent do it here
            &#x2F;&#x2F; With current implementation we should never get here
            throw new Error(&#x27;poly2tri [BUG:FIXME] FLIP failed due to missing triangle&#x27;);
        }
        var op = ot.oppositePoint(t, p);

        if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
            &#x2F;&#x2F; flip with new edge op.eq
            Sweep.flipEdgeEvent(tcx, eq, op, ot, op);
            &#x2F;&#x2F; TODO: Actually I just figured out that it should be possible to
            &#x2F;&#x2F;       improve this by getting the next ot and op before the the above
            &#x2F;&#x2F;       flip and continue the flipScanEdgeEvent here
            &#x2F;&#x2F; set new ot and op here and loop back to inScanArea test
            &#x2F;&#x2F; also need to set a new flip_triangle first
            &#x2F;&#x2F; Turns out at first glance that this is somewhat complicated
            &#x2F;&#x2F; so it will have to wait.
        } else {
            var newP = Sweep.nextFlipPoint(ep, eq, ot, op);
            Sweep.flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
        }
    };

&#x2F;&#x2F; ---------------------------------------------------------Exports (public API)

    poly2tri.PointError     = PointError;
    poly2tri.Point          = Point;
    poly2tri.Triangle       = Triangle;
    poly2tri.SweepContext   = SweepContext;

    &#x2F;&#x2F; Backward compatibility
    poly2tri.triangulate    = Sweep.triangulate;
    poly2tri.sweep = {Triangulate: Sweep.triangulate};

}(this));


&#x2F;&#x2F; ----------------------------------------------------Namespace.js (deprecated)

(function() { &#x2F;&#x2F; to scope jshint directives
    &quot;use strict&quot;;
    &#x2F;* jshint newcap:false *&#x2F;
    &#x2F;* global Namespace, js, poly2tri *&#x2F;

    &#x2F;&#x2F; Tests &quot;Namespace.js&quot; support, for backward compatilibilty
    if (typeof Namespace === &#x27;function&#x27;) {
        &#x2F;&#x2F; Put in the &quot;js.poly2tri&quot; namespace
        Namespace(&#x27;js.poly2tri&#x27;);
        js.poly2tri = poly2tri;
        Namespace.provide(&#x27;js.poly2tri&#x27;);
    }
}());


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
